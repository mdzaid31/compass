"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-wallet-selector";
exports.ids = ["vendor-chunks/@near-wallet-selector"];
exports.modules = {

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css":
/*!****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/styles.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f7b68a6f96ce\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRiYXNlbWludC8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3IvbW9kYWwtdWkvc3R5bGVzLmNzcz80MWYyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZjdiNjhhNmY5NmNlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/core/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@near-wallet-selector/core/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),\n/* harmony export */   allowOnlyLanguage: () => (/* binding */ allowOnlyLanguage),\n/* harmony export */   getActiveAccount: () => (/* binding */ getActiveAccount),\n/* harmony export */   isCurrentBrowserSupported: () => (/* binding */ isCurrentBrowserSupported),\n/* harmony export */   serializeNep413: () => (/* binding */ serializeNep413),\n/* harmony export */   setupWalletSelector: () => (/* binding */ setupWalletSelector),\n/* harmony export */   translate: () => (/* binding */ translate),\n/* harmony export */   verifyFullKeyBelongsToUser: () => (/* binding */ verifyFullKeyBelongsToUser),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/scan.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\");\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass Provider {\n  constructor(url) {\n    this.provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n      url\n    });\n  }\n  query(params) {\n    return this.provider.query(params);\n  }\n  viewAccessKey({\n    accountId,\n    publicKey\n  }) {\n    return this.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: accountId,\n      public_key: publicKey\n    });\n  }\n  block(reference) {\n    return this.provider.block(reference);\n  }\n  sendTransaction(signedTransaction) {\n    return this.provider.sendTransaction(signedTransaction);\n  }\n}\n\nconst KEY_DELIMITER = \":\";\nclass JsonStorage {\n  constructor(storage, namespace) {\n    this.storage = storage;\n    this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;\n  }\n  resolveKey(key) {\n    return [this.namespace, key].join(KEY_DELIMITER);\n  }\n  getItem(key) {\n    return this.storage.getItem(this.resolveKey(key)).then(item => {\n      return typeof item === \"string\" ? JSON.parse(item) : null;\n    });\n  }\n  setItem(key, value) {\n    return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));\n  }\n  removeItem(key) {\n    return this.storage.removeItem(this.resolveKey(key));\n  }\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$t =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$s = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$r = fails$s;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$r(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$q = fails$s;\n\nvar functionBindNative = !fails$q(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$l = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$l.bind(call$l) : function () {\n  return call$l.apply(call$l, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$7 = FunctionPrototype$2.bind;\nvar call$k = FunctionPrototype$2.call;\nvar uncurryThis$p = NATIVE_BIND$2 && bind$7.bind(call$k, call$k);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$p(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$k.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$o = functionUncurryThis;\n\nvar toString$7 = uncurryThis$o({}.toString);\nvar stringSlice$3 = uncurryThis$o(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$3(toString$7(it), 8, -1);\n};\n\nvar uncurryThis$n = functionUncurryThis;\nvar fails$p = fails$s;\nvar classof$b = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$n(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$p(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$b(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$f = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$6 = function (it) {\n  if (it == undefined) throw $TypeError$f(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$5 = requireObjectCoercible$6;\n\nvar toIndexedObject$6 = function (it) {\n  return IndexedObject$3(requireObjectCoercible$5(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$d = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$s = global$t;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$s[namespace]) : global$s[namespace] && global$s[namespace][method];\n};\n\nvar uncurryThis$m = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$r = global$t;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$r.process;\nvar Deno$1 = global$r.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$o = fails$s;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$o(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$e = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$e(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$j = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$c = isObject$d;\n\nvar $TypeError$d = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$c(val = call$j(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  throw $TypeError$d(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar global$q = global$t;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$7 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$7(global$q, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$q[key] = value;\n  } return value;\n};\n\nvar global$p = global$t;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$4 = requireObjectCoercible$6;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$7 = function (argument) {\n  return $Object$2(requireObjectCoercible$4(argument));\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toObject$6 = toObject$7;\n\nvar hasOwnProperty = uncurryThis$l({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$6(it), key);\n};\n\nvar uncurryThis$k = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$6 = uncurryThis$k(1.0.toString);\n\nvar uid$3 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id + postfix, 36);\n};\n\nvar global$o = global$t;\nvar shared$3 = shared$4.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$2 = uid$3;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$o.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;\n\nvar wellKnownSymbol$j = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$i = functionCall;\nvar isObject$b = isObject$d;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\n\nvar $TypeError$c = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$i('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$2 = function (input, pref) {\n  if (!isObject$b(input) || isSymbol$2(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$i(exoticToPrim, input, pref);\n    if (!isObject$b(result) || isSymbol$2(result)) return result;\n    throw $TypeError$c(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$1 = toPrimitive$2;\nvar isSymbol$1 = isSymbol$3;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$1(argument, 'string');\n  return isSymbol$1(key) ? key : key + '';\n};\n\nvar global$n = global$t;\nvar isObject$a = isObject$d;\n\nvar document$3 = global$n.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$a(document$3) && isObject$a(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar fails$n = fails$s;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$d && !fails$n(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$c = descriptors;\nvar call$h = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$5 = toIndexedObject$6;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$a = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$5(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$h(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$m = fails$s;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$m(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$9 = isObject$d;\n\nvar $String$2 = String;\nvar $TypeError$b = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$e = function (argument) {\n  if (isObject$9(argument)) return argument;\n  throw $TypeError$b($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$d = anObject$e;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$a = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$a('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar definePropertyModule$6 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$8 = DESCRIPTORS$9 ? function (object, key, value) {\n  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$8 = descriptors;\nvar hasOwn$9 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$9(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || (DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$m = global$t;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$m.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid$1 = uid$3;\n\nvar keys$1 = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys$1[key] || (keys$1[key] = uid$1(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$l = global$t;\nvar uncurryThis$i = functionUncurryThis;\nvar isObject$8 = isObject$d;\nvar createNonEnumerableProperty$7 = createNonEnumerableProperty$8;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$3 = global$l.TypeError;\nvar WeakMap = global$l.WeakMap;\nvar set$2, get$1, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$1(it) : set$2(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {\n      throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$i(store.get);\n  var wmhas = uncurryThis$i(store.has);\n  var wmset = uncurryThis$i(store.set);\n  set$2 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$2 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$7(it, STATE, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$2,\n  get: get$1,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$l = fails$s;\nvar isCallable$f = isCallable$n;\nvar hasOwn$7 = hasOwnProperty_1;\nvar DESCRIPTORS$7 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState$2 = InternalStateModule$5.enforce;\nvar getInternalState$5 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$l(function () {\n  return defineProperty$6(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$7(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {\n    if (DESCRIPTORS$7) defineProperty$6(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, 'arity') && value.length !== options.arity) {\n    defineProperty$6(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$7(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$7) defineProperty$6(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState$2(value);\n  if (!hasOwn$7(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$f(this) && getInternalState$5(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$5 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$8 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$5.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$3 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$3 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$6 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$5 = toIntegerOrInfinity$6;\n\nvar max$1 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$4 = function (index, length) {\n  var integer = toIntegerOrInfinity$5(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$4 = toIntegerOrInfinity$6;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$6 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$5 = toLength$6;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$8 = function (obj) {\n  return toLength$5(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$6;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$8;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$7(O);\n    var index = toAbsoluteIndex$3(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar uncurryThis$h = functionUncurryThis;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$6;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$2 = uncurryThis$h([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$2(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$g = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$c = anObject$e;\n\nvar concat$1 = uncurryThis$g([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$c(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$4.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$k = fails$s;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$k(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$k = global$t;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$6 = createNonEnumerableProperty$8;\nvar defineBuiltIn$7 = defineBuiltIn$8;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$k;\n  } else if (STATIC) {\n    target = global$k[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$k[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$6(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$7(target, key, sourceProperty, options);\n  }\n};\n\nvar classof$a = classofRaw$1;\nvar global$j = global$t;\n\nvar engineIsNode = classof$a(global$j.process) == 'process';\n\nvar isCallable$c = isCallable$n;\n\nvar $String$1 = String;\nvar $TypeError$9 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$c(argument)) return argument;\n  throw $TypeError$9(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$f = functionUncurryThis;\nvar anObject$b = anObject$e;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$f(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$b(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar defineProperty$5 = objectDefineProperty.f;\nvar hasOwn$4 = hasOwnProperty_1;\nvar wellKnownSymbol$h = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$4 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$4 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$4(target, TO_STRING_TAG$4)) {\n    defineProperty$5(target, TO_STRING_TAG$4, { configurable: true, value: TAG });\n  }\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar DESCRIPTORS$6 = descriptors;\n\nvar SPECIES$4 = wellKnownSymbol$g('species');\n\nvar setSpecies$2 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$3.f;\n\n  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$4]) {\n    defineProperty(Constructor, SPECIES$4, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$3 = objectIsPrototypeOf;\n\nvar $TypeError$8 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$3(Prototype, it)) return it;\n  throw $TypeError$8('Incorrect invocation');\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$b = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$b(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar fails$j = fails$s;\nvar isCallable$a = isCallable$n;\nvar classof$8 = classof$9;\nvar getBuiltIn$3 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$3('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  switch (classof$8(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$j(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$2 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$7(tryToString$3(argument) + ' is not a constructor');\n};\n\nvar anObject$a = anObject$e;\nvar aConstructor$1 = aConstructor$2;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\n\nvar SPECIES$3 = wellKnownSymbol$d('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$3 = function (O, defaultConstructor) {\n  var C = anObject$a(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$a(C)[SPECIES$3]) == undefined ? defaultConstructor : aConstructor$1(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$g = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$g.bind(apply$3) : function () {\n  return call$g.apply(apply$3, arguments);\n});\n\nvar uncurryThis$d = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$6 = uncurryThis$d(uncurryThis$d.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$7(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$6(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar getBuiltIn$2 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$2('document', 'documentElement');\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$c([].slice);\n\nvar $TypeError$6 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$6('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);\n\nvar global$i = global$t;\nvar apply$2 = functionApply;\nvar bind$5 = functionBindContext;\nvar isCallable$9 = isCallable$n;\nvar hasOwn$3 = hasOwnProperty_1;\nvar fails$i = fails$s;\nvar html$1 = html$2;\nvar arraySlice$4 = arraySlice$5;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\n\nvar set$1 = global$i.setImmediate;\nvar clear = global$i.clearImmediate;\nvar process$2 = global$i.process;\nvar Dispatch = global$i.Dispatch;\nvar Function$1 = global$i.Function;\nvar MessageChannel = global$i.MessageChannel;\nvar String$1 = global$i.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$i.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$3(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$i.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set$1 || !clear) {\n  set$1 = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$9(handler) ? handler : Function$1(handler);\n    var args = arraySlice$4(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$2(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$3) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$5(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$i.addEventListener &&\n    isCallable$9(global$i.postMessage) &&\n    !global$i.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$i(post)\n  ) {\n    defer = post;\n    global$i.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html$1.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set$1,\n  clear: clear\n};\n\nvar userAgent$3 = engineUserAgent;\nvar global$h = global$t;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && global$h.Pebble !== undefined;\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);\n\nvar global$g = global$t;\nvar bind$4 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\n\nvar MutationObserver = global$g.MutationObserver || global$g.WebKitMutationObserver;\nvar document$2 = global$g.document;\nvar process$1 = global$g.process;\nvar Promise$1 = global$g.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$g, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$4(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$2) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$4(macrotask, global$g);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$f = global$t;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$f.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$e = global$t;\n\nvar promiseNativeConstructor = global$e.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$d = global$t;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$8 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$2 = wellKnownSymbol$c('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$8(global$d.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$2] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$6 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$6(resolve);\n  this.reject = aCallable$6(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$e = _export;\nvar IS_NODE$1 = engineIsNode;\nvar global$c = global$t;\nvar call$f = functionCall;\nvar defineBuiltIn$6 = defineBuiltIn$8;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$4;\nvar setSpecies$1 = setSpecies$2;\nvar aCallable$5 = aCallable$9;\nvar isCallable$7 = isCallable$n;\nvar isObject$7 = isObject$d;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor$2 = speciesConstructor$3;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$4 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$4.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$2 = global$c.TypeError;\nvar document$1 = global$c.document;\nvar process = global$c.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$c.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$7(it) && isCallable$7(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$2('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$f(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$c.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$c['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE$1) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    if (IS_NODE$1) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$3 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$2(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$f(then, value,\n            bind$3(internalResolve, wrapper, state),\n            bind$3(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$5(executor);\n    call$f(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$3(internalResolve, state), bind$3(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$6(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor$2(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$7(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$7(onRejected) && onRejected;\n    reaction.domain = IS_NODE$1 ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$3(internalResolve, state);\n    this.reject = bind$3(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$7(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$6(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$f(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf$5) {\n      setPrototypeOf$5(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$e({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$3(PromiseConstructor, PROMISE, false);\nsetSpecies$1(PROMISE);\n\nvar iterators = {};\n\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar ArrayPrototype$1 = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);\n};\n\nvar classof$7 = classof$9;\nvar getMethod$2 = getMethod$4;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$a = wellKnownSymbol$j;\n\nvar ITERATOR$4 = wellKnownSymbol$a('iterator');\n\nvar getIteratorMethod$3 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators$3[classof$7(it)];\n};\n\nvar call$e = functionCall;\nvar aCallable$4 = aCallable$9;\nvar anObject$9 = anObject$e;\nvar tryToString$2 = tryToString$5;\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar $TypeError$5 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;\n  if (aCallable$4(iteratorMethod)) return anObject$9(call$e(iteratorMethod, argument));\n  throw $TypeError$5(tryToString$2(argument) + ' is not iterable');\n};\n\nvar call$d = functionCall;\nvar anObject$8 = anObject$e;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$d(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$c = functionCall;\nvar anObject$7 = anObject$e;\nvar tryToString$1 = tryToString$5;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$8;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$1 = getIteratorMethod$3;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError$4 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$2(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$7(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$1(iterable);\n    if (!iterFn) throw $TypeError$4(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$6(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$1(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$c(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\n\nvar ITERATOR$3 = wellKnownSymbol$9('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$2 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$d = _export;\nvar call$b = functionCall;\nvar aCallable$3 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$d({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$3(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$b($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$c = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$6 = isCallable$n;\nvar defineBuiltIn$5 = defineBuiltIn$8;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$c({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$6(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$5(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$b = _export;\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$b({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable$2(C.resolve);\n      iterate(iterable, function (promise) {\n        call$a($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$a = _export;\nvar call$9 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$a({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$9(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$6 = anObject$e;\nvar isObject$6 = isObject$d;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$6(C);\n  if (isObject$6(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$9 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$9({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nclass WebStorageService {\n  getItem(key) {\n    return new Promise(resolve => {\n      const value = localStorage.getItem(key);\n      resolve(value);\n    });\n  }\n  setItem(key, value) {\n    return new Promise(resolve => {\n      localStorage.setItem(key, value);\n      resolve();\n    });\n  }\n  removeItem(key) {\n    return new Promise(resolve => {\n      localStorage.removeItem(key);\n      resolve();\n    });\n  }\n}\n\nvar objectDefineProperties = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$5 = anObject$e;\nvar toIndexedObject$2 = toIndexedObject$6;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$5(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$4 = anObject$e;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$4(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar create$3 = objectCreate;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$8('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty$4(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\nvar fails$h = fails$s;\n\nvar correctPrototypeGetter = !fails$h(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$n;\nvar toObject$5 = toObject$7;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype$2 = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$5(O);\n  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$5(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype$2 : null;\n};\n\nvar fails$g = fails$s;\nvar isCallable$4 = isCallable$n;\nvar getPrototypeOf$3 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$8;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\n\nvar ITERATOR$2 = wellKnownSymbol$7('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$g(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$2 = setToStringTag$4;\nvar Iterators$2 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$2[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar $$8 = _export;\nvar call$8 = functionCall;\nvar FunctionName$1 = functionName;\nvar isCallable$3 = isCallable$n;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$2 = objectGetPrototypeOf;\nvar setPrototypeOf$4 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$4;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$8;\nvar defineBuiltIn$3 = defineBuiltIn$8;\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$2 = FunctionName$1.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$6('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$4) {\n          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME$1) {\n      createNonEnumerableProperty$5(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$8({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$1[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject$1 = toIndexedObject$6;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineProperty$3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$4 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$2 = InternalStateModule$3.set;\nvar getInternalState$4 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$2(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$1(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$4(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$4 && values.name !== 'values') try {\n  defineProperty$3(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$b = global$t;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$8;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\n\nvar ITERATOR = wellKnownSymbol$5('iterator');\nvar TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty$4(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$1]) {\n      createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$b[COLLECTION_NAME] && global$b[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nclass Logger {\n  constructor(namespace) {\n    this.namespace = namespace;\n  }\n  emit(method, ...params) {\n    if (!Logger.debug) {\n      return;\n    }\n    if (this.namespace && method !== \"error\") {\n      // eslint-disable-next-line no-console\n      console[method](this.namespace, ...params);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console[method](...params);\n  }\n  log(...params) {\n    this.emit(\"log\", ...params);\n  }\n  info(...params) {\n    this.emit(\"info\", ...params);\n  }\n  warn(...params) {\n    this.emit(\"warn\", ...params);\n  }\n  error(...params) {\n    this.emit(\"error\", ...params);\n  }\n}\nLogger.debug = false;\nconst logger = new Logger();\n\nvar $$7 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$f = fails$s;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$f(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$7({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$5 = isObject$d;\nvar classof$6 = classofRaw$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\n\nvar MATCH$1 = wellKnownSymbol$4('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$5(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$6(it) == 'RegExp');\n};\n\nvar isRegExp$1 = isRegexp;\n\nvar $TypeError$3 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp$1(it)) {\n    throw $TypeError$3(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar classof$5 = classof$9;\n\nvar $String = String;\n\nvar toString$5 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\n\nvar MATCH = wellKnownSymbol$3('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$6 = _export;\nvar uncurryThis$b = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$6;\nvar toString$4 = toString$5;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$b(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$6({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$3(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\n// a string of all valid unicode whitespaces\nvar whitespaces$2 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$a = functionUncurryThis;\nvar requireObjectCoercible$2 = requireObjectCoercible$6;\nvar toString$3 = toString$5;\nvar whitespaces$1 = whitespaces$2;\n\nvar replace$1 = uncurryThis$a(''.replace);\nvar whitespace = '[' + whitespaces$1 + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$3 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible$2($this));\n    if (TYPE & 1) string = replace$1(string, ltrim, '');\n    if (TYPE & 2) string = replace$1(string, rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$3(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$3(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$3(3)\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$e = fails$s;\nvar whitespaces = whitespaces$2;\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails$e(function () {\n    return !!whitespaces[METHOD_NAME]()\n      || non[METHOD_NAME]() !== non\n      || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);\n  });\n};\n\nvar $$5 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$$5({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar DESCRIPTORS$3 = descriptors;\nvar uncurryThis$9 = functionUncurryThis;\nvar call$7 = functionCall;\nvar fails$d = fails$s;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$4 = toObject$7;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$2 = Object.defineProperty;\nvar concat = uncurryThis$9([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$d(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$2({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$2(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$4(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$3 || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$4 = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$4({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nclass EventEmitter {\n  constructor() {\n    this.emitter = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n  }\n  on(eventName, callback) {\n    this.emitter.on(eventName, callback);\n    return {\n      remove: () => this.emitter.off(eventName, callback)\n    };\n  }\n  off(eventName, callback) {\n    this.emitter.off(eventName, callback);\n  }\n  emit(eventName, event) {\n    this.emitter.emit(eventName, event);\n  }\n}\n\nconst PACKAGE_NAME = \"near-wallet-selector\";\nconst RECENTLY_SIGNED_IN_WALLETS = \"recentlySignedInWallets\";\nconst CONTRACT = \"contract\";\nconst PENDING_CONTRACT = \"contract:pending\";\nconst SELECTED_WALLET_ID = `selectedWalletId`;\nconst PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;\n\nclass WalletModules {\n  constructor({\n    factories,\n    storage,\n    options,\n    store,\n    emitter,\n    provider\n  }) {\n    this.factories = factories;\n    this.storage = storage;\n    this.options = options;\n    this.store = store;\n    this.emitter = emitter;\n    this.provider = provider;\n    this.modules = [];\n    this.instances = {};\n  }\n  validateWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let accounts = [];\n      const wallet = yield this.getWallet(id);\n      if (wallet) {\n        // Ensure our persistent state aligns with the selected wallet.\n        // For example a wallet is selected, but it returns no accounts (not signed in).\n        accounts = yield wallet.getAccounts().catch(err => {\n          logger.log(`Failed to validate ${wallet.id} during setup`);\n          logger.error(err);\n          return [];\n        });\n      }\n      return accounts;\n    });\n  }\n  resolveStorageState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);\n      const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);\n      if (pendingSelectedWalletId && pendingContract) {\n        const _accounts = yield this.validateWallet(pendingSelectedWalletId);\n        yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);\n        yield jsonStorage.removeItem(PENDING_CONTRACT);\n        if (_accounts.length) {\n          const {\n            selectedWalletId: _selectedWalletId\n          } = this.store.getState();\n          const selectedWallet = yield this.getWallet(_selectedWalletId);\n          if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {\n            yield selectedWallet.signOut().catch(err => {\n              logger.log(\"Failed to sign out existing wallet\");\n              logger.error(err);\n            });\n          }\n          const recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);\n          return {\n            accounts: _accounts,\n            contract: pendingContract,\n            selectedWalletId: pendingSelectedWalletId,\n            recentlySignedInWallets: recentlySignedInWalletsFromPending\n          };\n        }\n      }\n      const {\n        contract,\n        selectedWalletId\n      } = this.store.getState();\n      const accounts = yield this.validateWallet(selectedWalletId);\n      const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!accounts.length) {\n        return {\n          accounts: [],\n          contract: null,\n          selectedWalletId: null,\n          recentlySignedInWallets: recentlySignedInWallets || []\n        };\n      }\n      return {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets: recentlySignedInWallets || []\n      };\n    });\n  }\n  setWalletAsRecentlySignedIn(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!recentlySignedInWallets) {\n        recentlySignedInWallets = [];\n      }\n      if (!recentlySignedInWallets.includes(walletId)) {\n        recentlySignedInWallets.unshift(walletId);\n        recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);\n        yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);\n      }\n      return recentlySignedInWallets;\n    });\n  }\n  signOutWallet(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = yield this.getWallet(walletId);\n      yield wallet.signOut().catch(err => {\n        logger.log(`Failed to sign out ${wallet.id}`);\n        logger.error(err);\n        // At least clean up state on our side.\n        this.onWalletSignedOut(wallet.id);\n      });\n    });\n  }\n  onWalletSignedIn(walletId, {\n    accounts,\n    contractId,\n    methodNames\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const contract = {\n        contractId,\n        methodNames\n      };\n      if (!accounts.length) {\n        const module = this.getModule(walletId);\n        // We can't guarantee the user will actually sign in with browser wallets.\n        // Best we can do is set in storage and validate on init.\n        if (module.type === \"browser\") {\n          yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);\n          yield jsonStorage.setItem(PENDING_CONTRACT, contract);\n        }\n        return;\n      }\n      if (selectedWalletId && selectedWalletId !== walletId) {\n        yield this.signOutWallet(selectedWalletId);\n      }\n      const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);\n      this.store.dispatch({\n        type: \"WALLET_CONNECTED\",\n        payload: {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        }\n      });\n      this.emitter.emit(\"signedIn\", {\n        walletId,\n        contractId,\n        methodNames,\n        accounts\n      });\n    });\n  }\n  onWalletSignedOut(walletId) {\n    this.store.dispatch({\n      type: \"WALLET_DISCONNECTED\",\n      payload: {\n        walletId\n      }\n    });\n    this.emitter.emit(\"signedOut\", {\n      walletId\n    });\n  }\n  setupWalletEmitter(module) {\n    const emitter = new EventEmitter();\n    emitter.on(\"signedOut\", () => {\n      this.onWalletSignedOut(module.id);\n    });\n    emitter.on(\"signedIn\", event => {\n      this.onWalletSignedIn(module.id, event);\n    });\n    emitter.on(\"accountsChanged\", ({\n      accounts\n    }) => __awaiter(this, void 0, void 0, function* () {\n      this.emitter.emit(\"accountsChanged\", {\n        walletId: module.id,\n        accounts\n      });\n      if (!accounts.length) {\n        return this.signOutWallet(module.id);\n      }\n      this.store.dispatch({\n        type: \"ACCOUNTS_CHANGED\",\n        payload: {\n          walletId: module.id,\n          accounts\n        }\n      });\n    }));\n    emitter.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      this.emitter.emit(\"networkChanged\", {\n        walletId: module.id,\n        networkId\n      });\n    });\n    emitter.on(\"uriChanged\", ({\n      uri\n    }) => {\n      this.emitter.emit(\"uriChanged\", {\n        walletId: module.id,\n        uri\n      });\n    });\n    return emitter;\n  }\n  validateSignMessageParams({\n    message,\n    nonce,\n    recipient\n  }) {\n    if (!message || message.trim() === \"\") {\n      throw new Error(\"Invalid message. It must be a non-empty string.\");\n    }\n    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {\n      throw new Error(\"Invalid nonce. It must be a Buffer with a length of 32 bytes.\");\n    }\n    if (!recipient || recipient.trim() === \"\") {\n      throw new Error(\"Invalid recipient. It must be a non-empty string.\");\n    }\n  }\n  decorateWallet(wallet) {\n    const _signIn = wallet.signIn;\n    const _signOut = wallet.signOut;\n    const _signMessage = wallet.signMessage;\n    wallet.signIn = params => __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield _signIn(params);\n      const {\n        contractId,\n        methodNames = []\n      } = params;\n      yield this.onWalletSignedIn(wallet.id, {\n        accounts,\n        contractId,\n        methodNames\n      });\n      return accounts;\n    });\n    wallet.signOut = () => __awaiter(this, void 0, void 0, function* () {\n      yield _signOut();\n      this.onWalletSignedOut(wallet.id);\n    });\n    wallet.signMessage = params => __awaiter(this, void 0, void 0, function* () {\n      if (_signMessage === undefined) {\n        throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);\n      }\n      this.validateSignMessageParams(params);\n      return yield _signMessage(params);\n    });\n    return wallet;\n  }\n  setupInstance(module) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!module.metadata.available) {\n        const message = module.type === \"injected\" ? \"not installed\" : \"not available\";\n        throw Error(`${module.metadata.name} is ${message}`);\n      }\n      const wallet = Object.assign({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata\n      }, yield module.init({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata,\n        options: this.options,\n        store: this.store.toReadOnly(),\n        provider: this.provider,\n        emitter: this.setupWalletEmitter(module),\n        logger: new Logger(module.id),\n        storage: new JsonStorage(this.storage, [PACKAGE_NAME, module.id])\n      }));\n      return this.decorateWallet(wallet);\n    });\n  }\n  getModule(id) {\n    return this.modules.find(x => x.id === id);\n  }\n  getWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const module = this.getModule(id);\n      if (!module) {\n        return null;\n      }\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      // If user uninstalled/removed a wallet which was previously signed in with\n      // best we can do is clean up state on our side.\n      if (!module.metadata.available && selectedWalletId) {\n        this.onWalletSignedOut(selectedWalletId);\n        return null;\n      }\n      return yield module.wallet();\n    });\n  }\n  setup() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const modules = [];\n      for (let i = 0; i < this.factories.length; i += 1) {\n        const module = yield this.factories[i]({\n          options: this.options\n        }).catch(err => {\n          logger.log(\"Failed to setup module\");\n          logger.error(err);\n          return null;\n        });\n        // Filter out wallets that aren't available.\n        if (!module) {\n          continue;\n        }\n        // Skip duplicated module.\n        if (modules.some(x => x.id === module.id)) {\n          continue;\n        }\n        modules.push({\n          id: module.id,\n          type: module.type,\n          metadata: module.metadata,\n          wallet: () => __awaiter(this, void 0, void 0, function* () {\n            let instance = this.instances[module.id];\n            if (instance) {\n              return instance;\n            }\n            instance = yield this.setupInstance(module);\n            this.instances[module.id] = instance;\n            return instance;\n          })\n        });\n      }\n      this.modules = modules;\n      const {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets\n      } = yield this.resolveStorageState();\n      this.store.dispatch({\n        type: \"SETUP_WALLET_MODULES\",\n        payload: {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        }\n      });\n      for (let i = 0; i < this.modules.length; i++) {\n        if (this.modules[i].type !== \"instant-link\") {\n          continue;\n        }\n        const wallet = yield this.modules[i].wallet();\n        if (!wallet.metadata.runOnStartup) {\n          continue;\n        }\n        try {\n          yield wallet.signIn({\n            contractId: wallet.getContractId()\n          });\n        } catch (err) {\n          logger.error(\"Failed to sign in to wallet. \" + err);\n        }\n      }\n    });\n  }\n}\n\nconst getNetworkPreset = networkId => {\n  switch (networkId) {\n    case \"mainnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        helperUrl: \"https://helper.mainnet.near.org\",\n        explorerUrl: \"https://nearblocks.io\",\n        indexerUrl: \"https://api.kitwallet.app\"\n      };\n    case \"testnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        helperUrl: \"https://helper.testnet.near.org\",\n        explorerUrl: \"https://testnet.nearblocks.io\",\n        indexerUrl: \"https://testnet-api.kitwallet.app\"\n      };\n    default:\n      throw Error(`Failed to find config for: '${networkId}'`);\n  }\n};\nconst resolveNetwork = network => {\n  return typeof network === \"string\" ? getNetworkPreset(network) : network;\n};\nconst resolveOptions = params => {\n  const options = {\n    languageCode: params.languageCode || undefined,\n    network: resolveNetwork(params.network),\n    debug: params.debug || false,\n    optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,\n    randomizeWalletOrder: params.randomizeWalletOrder || false,\n    relayerUrl: params.relayerUrl || undefined\n  };\n  return {\n    options,\n    storage: params.storage || new WebStorageService()\n  };\n};\n\nconst reducer = (state, action) => {\n  logger.log(\"Store Action\", action);\n  switch (action.type) {\n    case \"SETUP_WALLET_MODULES\":\n      {\n        const {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        } = action.payload;\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === 0\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          modules,\n          accounts: accountStates,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_CONNECTED\":\n      {\n        const {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        } = action.payload;\n        if (!accounts.length) {\n          return state;\n        }\n        const activeAccountIndex = state.accounts.findIndex(account => account.active);\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          contract,\n          accounts: accountStates,\n          selectedWalletId: walletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_DISCONNECTED\":\n      {\n        const {\n          walletId\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        return Object.assign(Object.assign({}, state), {\n          contract: null,\n          accounts: [],\n          selectedWalletId: null\n        });\n      }\n    case \"ACCOUNTS_CHANGED\":\n      {\n        const {\n          walletId,\n          accounts\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        const activeAccount = state.accounts.find(account => account.active);\n        const isActiveAccountRemoved = !accounts.some(account => account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    case \"SET_ACTIVE_ACCOUNT\":\n      {\n        const {\n          accountId\n        } = action.payload;\n        const accountStates = state.accounts.map(account => {\n          return Object.assign(Object.assign({}, account), {\n            active: account.accountId === accountId\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    default:\n      return state;\n  }\n};\nconst createStore = storage => __awaiter(void 0, void 0, void 0, function* () {\n  const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);\n  const initialState = {\n    modules: [],\n    accounts: [],\n    contract: yield jsonStorage.getItem(CONTRACT),\n    selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),\n    recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || []\n  };\n  const state$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__.BehaviorSubject(initialState);\n  const actions$ = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();\n  actions$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.scan)(reducer, initialState)).subscribe(state$);\n  const syncStorage = (prevState, state, storageKey, property) => __awaiter(void 0, void 0, void 0, function* () {\n    if (state[property] === prevState[property]) {\n      return;\n    }\n    if (state[property]) {\n      yield jsonStorage.setItem(storageKey, state[property]);\n      return;\n    }\n    yield jsonStorage.removeItem(storageKey);\n  });\n  let prevState = state$.getValue();\n  state$.subscribe(state => {\n    syncStorage(prevState, state, SELECTED_WALLET_ID, \"selectedWalletId\");\n    syncStorage(prevState, state, CONTRACT, \"contract\");\n    syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, \"recentlySignedInWallets\");\n    prevState = state;\n  });\n  return {\n    observable: state$,\n    getState: () => state$.getValue(),\n    dispatch: action => actions$.next(action),\n    toReadOnly: () => ({\n      getState: () => state$.getValue(),\n      observable: state$.asObservable()\n    })\n  };\n});\n\nlet walletSelectorInstance = null;\nconst createSelector = (options, store, walletModules, emitter) => {\n  return {\n    options,\n    store: store.toReadOnly(),\n    wallet: id => __awaiter(void 0, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = store.getState();\n      const wallet = yield walletModules.getWallet(id || selectedWalletId);\n      if (!wallet) {\n        if (id) {\n          throw new Error(\"Invalid wallet id\");\n        }\n        throw new Error(\"No wallet selected\");\n      }\n      return wallet;\n    }),\n    setActiveAccount: accountId => {\n      const {\n        accounts\n      } = store.getState();\n      if (!accounts.some(account => account.accountId === accountId)) {\n        throw new Error(\"Invalid account id\");\n      }\n      store.dispatch({\n        type: \"SET_ACTIVE_ACCOUNT\",\n        payload: {\n          accountId\n        }\n      });\n    },\n    isSignedIn() {\n      const {\n        accounts\n      } = store.getState();\n      return Boolean(accounts.length);\n    },\n    on: (eventName, callback) => {\n      return emitter.on(eventName, callback);\n    },\n    off: (eventName, callback) => {\n      emitter.off(eventName, callback);\n    }\n  };\n};\n/**\r\n * Initiates a wallet selector instance\r\n * @param {WalletSelectorParams} params Selector parameters (network, modules...)\r\n * @returns {Promise<WalletSelector>} Returns a WalletSelector object\r\n */\nconst setupWalletSelector = params => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    options,\n    storage\n  } = resolveOptions(params);\n  Logger.debug = options.debug;\n  const emitter = new EventEmitter();\n  const store = yield createStore(storage);\n  const walletModules = new WalletModules({\n    factories: params.modules,\n    storage,\n    options,\n    store,\n    emitter,\n    provider: new Provider(options.network.nodeUrl)\n  });\n  yield walletModules.setup();\n  if (params.allowMultipleSelectors) {\n    return createSelector(options, store, walletModules, emitter);\n  }\n  if (!walletSelectorInstance) {\n    walletSelectorInstance = createSelector(options, store, walletModules, emitter);\n  }\n  return walletSelectorInstance;\n});\n\nconst wait = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nconst poll = (cb, interval, remaining) => __awaiter(void 0, void 0, void 0, function* () {\n  const result = cb();\n  if (result) {\n    return result;\n  }\n  if (!remaining) {\n    throw new Error(\"Exceeded timeout\");\n  }\n  return wait(interval).then(() => poll(cb, interval, remaining - 1));\n});\nconst waitFor = (cb, opts = {}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    timeout = 100,\n    interval = 50\n  } = opts;\n  return Promise.race([wait(timeout).then(() => {\n    throw new Error(\"Exceeded timeout\");\n  }), poll(cb, interval, Math.floor(timeout / interval))]);\n});\n\nconst getActiveAccount = state => {\n  return state.accounts.find(account => account.active) || null;\n};\n\nvar aCallable$1 = aCallable$9;\nvar toObject$3 = toObject$7;\nvar IndexedObject$1 = indexedObject;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$8;\n\nvar $TypeError$2 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod$2 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$1(callbackfn);\n    var O = toObject$3(that);\n    var self = IndexedObject$1(O);\n    var length = lengthOfArrayLike$5(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$2('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod$2(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$2(true)\n};\n\nvar fails$c = fails$s;\n\nvar arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$c(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $$3 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$1;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$3({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar anObject$3 = anObject$e;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$3(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar fails$b = fails$s;\nvar global$a = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$a.RegExp;\n\nvar UNSUPPORTED_Y$2 = fails$b(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$b(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$b(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\n\nvar fails$a = fails$s;\nvar global$9 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$9.RegExp;\n\nvar regexpUnsupportedDotAll = fails$a(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$9 = fails$s;\nvar global$8 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$8.RegExp;\n\nvar regexpUnsupportedNcg = fails$9(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$6 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar toString$2 = toString$5;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$1 = objectCreate;\nvar getInternalState$3 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$8(''.charAt);\nvar indexOf = uncurryThis$8(''.indexOf);\nvar replace = uncurryThis$8(''.replace);\nvar stringSlice$2 = uncurryThis$8(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$6(nativeExec, re1, 'a');\n  call$6(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState$3(re);\n    var str = toString$2(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$6(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y$1 && re.sticky;\n    var flags = call$6(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$6(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$6(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create$1(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$3 = patchedExec;\n\nvar $$2 = _export;\nvar exec$1 = regexpExec$3;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$$2({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {\n  exec: exec$1\n});\n\n/* eslint-disable no-useless-escape */\n// https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\nconst SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nconst userAgentRules = [[\"aol\", /AOLShield\\/([0-9\\._]+)/], [\"edge\", /Edge\\/([0-9\\._]+)/], [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/], [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/], [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/], [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/], [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/], [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/], [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/], [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/], [\"chromium-webview\", /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/], [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/], [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/], [\"fxios\", /FxiOS\\/([0-9\\.]+)/], [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/], [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/], [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/], [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/], [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/], [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/], [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/], [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], [\"ie\", /MSIE\\s(7\\.0)/], [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/], [\"android\", /Android\\s([0-9\\.]+)/], [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/], [\"safari\", /Version\\/([0-9\\._]+).*Safari/], [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/], [\"instagram\", /Instagram\\s([0-9\\.]+)/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/], [\"curl\", /^curl\\/([0-9\\.]+)$/], [\"searchbot\", SEARCHBOX_UA_REGEX]];\nconst matchUserAgent = ua => {\n  return ua !== \"\" && userAgentRules.reduce((matched, [browser, regex]) => {\n    if (matched) {\n      return matched;\n    }\n    const uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser, uaMatch];\n  }, false);\n};\nconst isCurrentBrowserSupported = supportedBrowser => {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const matchedRule = matchUserAgent(navigator.userAgent);\n  if (!matchedRule) {\n    return false;\n  }\n  const [name] = matchedRule;\n  if (name === \"searchbot\") {\n    return false;\n  }\n  return !!supportedBrowser.find(item => item === name);\n};\n\n// eslint-disable-next-line es-x/no-typed-arrays -- safe\nvar arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\nvar NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;\nvar DESCRIPTORS$2 = descriptors;\nvar global$7 = global$t;\nvar isCallable$2 = isCallable$n;\nvar isObject$4 = isObject$d;\nvar hasOwn$1 = hasOwnProperty_1;\nvar classof$4 = classof$9;\nvar tryToString = tryToString$5;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$8;\nvar defineBuiltIn$2 = defineBuiltIn$8;\nvar defineProperty$1 = objectDefineProperty.f;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar setPrototypeOf$3 = objectSetPrototypeOf;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar uid = uid$3;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState$1 = InternalStateModule$2.enforce;\nvar getInternalState$2 = InternalStateModule$2.get;\nvar Int8Array$4 = global$7.Int8Array;\nvar Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;\nvar Uint8ClampedArray$1 = global$7.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;\nvar TypedArray$1 = Int8Array$4 && getPrototypeOf$1(Int8Array$4);\nvar TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);\nvar ObjectPrototype$1 = Object.prototype;\nvar TypeError$1 = global$7.TypeError;\n\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$7.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return klass === 'DataView'\n    || hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar getTypedArrayConstructor = function (it) {\n  var proto = getPrototypeOf$1(it);\n  if (!isObject$4(proto)) return;\n  var state = getInternalState$2(proto);\n  return (state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\n\nvar isTypedArray$1 = function (it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray$4 = function (it) {\n  if (isTypedArray$1(it)) return it;\n  throw TypeError$1('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor$2 = function (C) {\n  if (isCallable$2(C) && (!setPrototypeOf$3 || isPrototypeOf$1(TypedArray$1, C))) return C;\n  throw TypeError$1(tryToString(C) + ' is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod$4 = function (KEY, property, forced, options) {\n  if (!DESCRIPTORS$2) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {\n      delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n      // old WebKit bug - some methods are non-configurable\n      try {\n        TypedArrayConstructor.prototype[KEY] = property;\n      } catch (error2) { /* empty */ }\n    }\n  }\n  if (!TypedArrayPrototype$1[KEY] || forced) {\n    defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);\n  }\n};\n\nvar exportTypedArrayStaticMethod$1 = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS$2) return;\n  if (setPrototypeOf$3) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global$7[ARRAY];\n      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {\n        delete TypedArrayConstructor[KEY];\n      } catch (error) { /* empty */ }\n    }\n    if (!TypedArray$1[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      defineBuiltIn$2(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;\n}\n\nfor (NAME in BigIntArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$2(TypedArray$1) || TypedArray$1 === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray$1 = function TypedArray() {\n    throw TypeError$1('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME], TypedArray$1);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {\n  TypedArrayPrototype$1 = TypedArray$1.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME].prototype, TypedArrayPrototype$1);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {\n  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);\n}\n\nif (DESCRIPTORS$2 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQUIRED = true;\n  defineProperty$1(TypedArrayPrototype$1, TO_STRING_TAG, { get: function () {\n    return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global$7[NAME]) {\n    createNonEnumerableProperty$3(global$7[NAME], TYPED_ARRAY_TAG$1, NAME);\n  }\n}\n\nvar arrayBufferViewCore = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,\n  aTypedArray: aTypedArray$4,\n  aTypedArrayConstructor: aTypedArrayConstructor$2,\n  exportTypedArrayMethod: exportTypedArrayMethod$4,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,\n  getTypedArrayConstructor: getTypedArrayConstructor,\n  isView: isView,\n  isTypedArray: isTypedArray$1,\n  TypedArray: TypedArray$1,\n  TypedArrayPrototype: TypedArrayPrototype$1\n};\n\n/* eslint-disable no-new -- required for testing */\n\nvar global$6 = global$t;\nvar fails$8 = fails$s;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;\nvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\nvar ArrayBuffer$3 = global$6.ArrayBuffer;\nvar Int8Array$3 = global$6.Int8Array;\n\nvar typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$8(function () {\n  Int8Array$3(1);\n}) || !fails$8(function () {\n  new Int8Array$3(-1);\n}) || !checkCorrectnessOfIteration(function (iterable) {\n  new Int8Array$3();\n  new Int8Array$3(null);\n  new Int8Array$3(1.5);\n  new Int8Array$3(iterable);\n}, true) || fails$8(function () {\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n  return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;\n});\n\nvar bind$1 = functionBindContext;\nvar call$5 = functionCall;\nvar aConstructor = aConstructor$2;\nvar toObject$2 = toObject$7;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$8;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$3;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\n\nvar typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {\n  var C = aConstructor(this);\n  var O = toObject$2(source);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var i, length, result, step, iterator, next;\n  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    O = [];\n    while (!(step = call$5(next, iterator)).done) {\n      O.push(step.value);\n    }\n  }\n  if (mapping && argumentsLength > 2) {\n    mapfn = bind$1(mapfn, arguments[2]);\n  }\n  length = lengthOfArrayLike$4(O);\n  result = new (aTypedArrayConstructor$1(C))(length);\n  for (i = 0; length > i; i++) {\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\n  }\n  return result;\n};\n\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;\nvar exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;\nvar typedArrayFrom$1 = typedArrayFrom$2;\n\n// `%TypedArray%.from` method\n// https://tc39.es/ecma262/#sec-%typedarray%.from\nexportTypedArrayStaticMethod('from', typedArrayFrom$1, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);\n\nvar defineBuiltIn$1 = defineBuiltIn$8;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$1(target, key, src[key], options);\n  return target;\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$6;\nvar toLength$4 = toLength$6;\n\nvar $RangeError$2 = RangeError;\n\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nvar toIndex$2 = function (it) {\n  if (it === undefined) return 0;\n  var number = toIntegerOrInfinity$3(it);\n  var length = toLength$4(number);\n  if (number !== length) throw $RangeError$2('Wrong length or index');\n  return length;\n};\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar $Array$2 = Array;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor$2 = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nvar pack = function (number, mantissaLength, bytes) {\n  var buffer = $Array$2(bytes);\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n  var index = 0;\n  var exponent, mantissa, c;\n  number = abs(number);\n  // eslint-disable-next-line no-self-compare -- NaN check\n  if (number != number || number === Infinity) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    mantissa = number != number ? 1 : 0;\n    exponent = eMax;\n  } else {\n    exponent = floor$2(log(number) / LN2);\n    c = pow(2, -exponent);\n    if (number * c < 1) {\n      exponent--;\n      c *= 2;\n    }\n    if (exponent + eBias >= 1) {\n      number += rt / c;\n    } else {\n      number += rt * pow(2, 1 - eBias);\n    }\n    if (number * c >= 2) {\n      exponent++;\n      c /= 2;\n    }\n    if (exponent + eBias >= eMax) {\n      mantissa = 0;\n      exponent = eMax;\n    } else if (exponent + eBias >= 1) {\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\n      exponent = exponent + eBias;\n    } else {\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n      exponent = 0;\n    }\n  }\n  while (mantissaLength >= 8) {\n    buffer[index++] = mantissa & 255;\n    mantissa /= 256;\n    mantissaLength -= 8;\n  }\n  exponent = exponent << mantissaLength | mantissa;\n  exponentLength += mantissaLength;\n  while (exponentLength > 0) {\n    buffer[index++] = exponent & 255;\n    exponent /= 256;\n    exponentLength -= 8;\n  }\n  buffer[--index] |= sign * 128;\n  return buffer;\n};\n\nvar unpack = function (buffer, mantissaLength) {\n  var bytes = buffer.length;\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var nBits = exponentLength - 7;\n  var index = bytes - 1;\n  var sign = buffer[index--];\n  var exponent = sign & 127;\n  var mantissa;\n  sign >>= 7;\n  while (nBits > 0) {\n    exponent = exponent * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  mantissa = exponent & (1 << -nBits) - 1;\n  exponent >>= -nBits;\n  nBits += mantissaLength;\n  while (nBits > 0) {\n    mantissa = mantissa * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  if (exponent === 0) {\n    exponent = 1 - eBias;\n  } else if (exponent === eMax) {\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\n  } else {\n    mantissa = mantissa + pow(2, mantissaLength);\n    exponent = exponent - eBias;\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\n\nvar ieee754 = {\n  pack: pack,\n  unpack: unpack\n};\n\nvar toObject$1 = toObject$7;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$8;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill$1 = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$1(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex$2(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex$1 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$8;\nvar createProperty = createProperty$1;\n\nvar $Array$1 = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$2(O);\n  var k = toAbsoluteIndex$1(start, length);\n  var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);\n  var result = $Array$1(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar global$5 = global$t;\nvar uncurryThis$7 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar NATIVE_ARRAY_BUFFER = arrayBufferNative;\nvar FunctionName = functionName;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$8;\nvar defineBuiltIns = defineBuiltIns$1;\nvar fails$7 = fails$s;\nvar anInstance$1 = anInstance$3;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$6;\nvar toLength$3 = toLength$6;\nvar toIndex$1 = toIndex$2;\nvar IEEE754 = ieee754;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$2 = objectSetPrototypeOf;\nvar getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar defineProperty = objectDefineProperty.f;\nvar arrayFill = arrayFill$1;\nvar arraySlice$3 = arraySliceSimple;\nvar setToStringTag = setToStringTag$4;\nvar InternalStateModule$1 = internalState;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar getInternalState$1 = InternalStateModule$1.get;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH$1 = 'Wrong length';\nvar WRONG_INDEX = 'Wrong index';\nvar NativeArrayBuffer = global$5[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];\nvar $DataView = global$5[DATA_VIEW];\nvar DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar Array$1 = global$5.Array;\nvar RangeError$3 = global$5.RangeError;\nvar fill = uncurryThis$7(arrayFill);\nvar reverse = uncurryThis$7([].reverse);\n\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\n\nvar packInt8 = function (number) {\n  return [number & 0xFF];\n};\n\nvar packInt16 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF];\n};\n\nvar packInt32 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n};\n\nvar unpackInt32 = function (buffer) {\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\n\nvar packFloat32 = function (number) {\n  return packIEEE754(number, 23, 4);\n};\n\nvar packFloat64 = function (number) {\n  return packIEEE754(number, 52, 8);\n};\n\nvar addGetter$1 = function (Constructor, key) {\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState$1(this)[key]; } });\n};\n\nvar get = function (view, count, index, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = arraySlice$3(bytes, start, start + count);\n  return isLittleEndian ? pack : reverse(pack);\n};\n\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = conversion(+value);\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\n\nif (!NATIVE_ARRAY_BUFFER) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance$1(this, ArrayBufferPrototype$1);\n    var byteLength = toIndex$1(length);\n    setInternalState$1(this, {\n      bytes: fill(Array$1(byteLength), 0),\n      byteLength: byteLength\n    });\n    if (!DESCRIPTORS$1) this.byteLength = byteLength;\n  };\n\n  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance$1(this, DataViewPrototype$1);\n    anInstance$1(buffer, ArrayBufferPrototype$1);\n    var bufferLength = getInternalState$1(buffer).byteLength;\n    var offset = toIntegerOrInfinity$2(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength$3(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);\n    setInternalState$1(this, {\n      buffer: buffer,\n      byteLength: byteLength,\n      byteOffset: offset\n    });\n    if (!DESCRIPTORS$1) {\n      this.buffer = buffer;\n      this.byteLength = byteLength;\n      this.byteOffset = offset;\n    }\n  };\n\n  DataViewPrototype$1 = $DataView[PROTOTYPE];\n\n  if (DESCRIPTORS$1) {\n    addGetter$1($ArrayBuffer, 'byteLength');\n    addGetter$1($DataView, 'buffer');\n    addGetter$1($DataView, 'byteLength');\n    addGetter$1($DataView, 'byteOffset');\n  }\n\n  defineBuiltIns(DataViewPrototype$1, {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n    }\n  });\n} else {\n  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;\n  /* eslint-disable no-new -- required for testing */\n  if (!fails$7(function () {\n    NativeArrayBuffer(1);\n  }) || !fails$7(function () {\n    new NativeArrayBuffer(-1);\n  }) || fails$7(function () {\n    new NativeArrayBuffer();\n    new NativeArrayBuffer(1.5);\n    new NativeArrayBuffer(NaN);\n    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;\n  })) {\n  /* eslint-enable no-new -- required for testing */\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance$1(this, ArrayBufferPrototype$1);\n      return new NativeArrayBuffer(toIndex$1(length));\n    };\n\n    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;\n\n    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\n        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);\n      }\n    }\n\n    ArrayBufferPrototype$1.constructor = $ArrayBuffer;\n  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {\n    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);\n  }\n\n  // WebKit bug - the same parent prototype for typed arrays and data view\n  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype$1) !== ObjectPrototype) {\n    setPrototypeOf$2(DataViewPrototype$1, ObjectPrototype);\n  }\n\n  // iOS Safari 7.x bug\n  var testView = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = uncurryThis$7(DataViewPrototype$1.setInt8);\n  testView.setInt8(0, 2147483648);\n  testView.setInt8(1, 2147483649);\n  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype$1, {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    }\n  }, { unsafe: true });\n}\n\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\n\nvar arrayBuffer = {\n  ArrayBuffer: $ArrayBuffer,\n  DataView: $DataView\n};\n\nvar $$1 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar fails$6 = fails$s;\nvar ArrayBufferModule$1 = arrayBuffer;\nvar anObject$2 = anObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$4;\nvar toLength$2 = toLength$6;\nvar speciesConstructor$1 = speciesConstructor$3;\n\nvar ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;\nvar DataView$2 = ArrayBufferModule$1.DataView;\nvar DataViewPrototype = DataView$2.prototype;\nvar un$ArrayBufferSlice = uncurryThis$6(ArrayBuffer$2.prototype.slice);\nvar getUint8 = uncurryThis$6(DataViewPrototype.getUint8);\nvar setUint8 = uncurryThis$6(DataViewPrototype.setUint8);\n\nvar INCORRECT_SLICE = fails$6(function () {\n  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;\n});\n\n// `ArrayBuffer.prototype.slice` method\n// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice\n$$1({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {\n  slice: function slice(start, end) {\n    if (un$ArrayBufferSlice && end === undefined) {\n      return un$ArrayBufferSlice(anObject$2(this), start); // FF fix\n    }\n    var length = anObject$2(this).byteLength;\n    var first = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = new (speciesConstructor$1(this, ArrayBuffer$2))(toLength$2(fin - first));\n    var viewSource = new DataView$2(this);\n    var viewTarget = new DataView$2(result);\n    var index = 0;\n    while (first < fin) {\n      setUint8(viewTarget, index++, getUint8(viewSource, first++));\n    } return result;\n  }\n});\n\nvar typedArrayConstructor = {exports: {}};\n\nvar isObject$3 = isObject$d;\n\nvar floor$1 = Math.floor;\n\n// `IsIntegralNumber` abstract operation\n// https://tc39.es/ecma262/#sec-isintegralnumber\n// eslint-disable-next-line es-x/no-number-isinteger -- safe\nvar isIntegralNumber$1 = Number.isInteger || function isInteger(it) {\n  return !isObject$3(it) && isFinite(it) && floor$1(it) === it;\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$6;\n\nvar $RangeError$1 = RangeError;\n\nvar toPositiveInteger$1 = function (it) {\n  var result = toIntegerOrInfinity$1(it);\n  if (result < 0) throw $RangeError$1(\"The argument can't be less than 0\");\n  return result;\n};\n\nvar toPositiveInteger = toPositiveInteger$1;\n\nvar $RangeError = RangeError;\n\nvar toOffset$2 = function (it, BYTES) {\n  var offset = toPositiveInteger(it);\n  if (offset % BYTES) throw $RangeError('Wrong offset');\n  return offset;\n};\n\nvar classof$3 = classofRaw$1;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es-x/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$3(argument) == 'Array';\n};\n\nvar isArray = isArray$1;\nvar isConstructor = isConstructor$2;\nvar isObject$2 = isObject$d;\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\n\nvar SPECIES$1 = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject$2(C)) {\n      C = C[SPECIES$1];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar bind = functionBindContext;\nvar uncurryThis$5 = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$7;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$8;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\n\nvar push$1 = uncurryThis$5([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike$1(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$1(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$1(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$1(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$1(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$1(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$1(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$1(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$1(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$1(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$1(7)\n};\n\nvar isCallable$1 = isCallable$n;\nvar isObject$1 = isObject$d;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\n\n// makes subclassing work correct for wrapped built-ins\nvar inheritIfRequired$1 = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf$1 &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable$1(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject$1(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf$1($this, NewTargetPrototype);\n  return $this;\n};\n\nvar $ = _export;\nvar global$4 = global$t;\nvar call$4 = functionCall;\nvar DESCRIPTORS = descriptors;\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;\nvar ArrayBufferViewCore$4 = arrayBufferViewCore;\nvar ArrayBufferModule = arrayBuffer;\nvar anInstance = anInstance$3;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$8;\nvar isIntegralNumber = isIntegralNumber$1;\nvar toLength$1 = toLength$6;\nvar toIndex = toIndex$2;\nvar toOffset$1 = toOffset$2;\nvar toPropertyKey = toPropertyKey$4;\nvar hasOwn = hasOwnProperty_1;\nvar classof$2 = classof$9;\nvar isObject = isObject$d;\nvar isSymbol = isSymbol$3;\nvar create = objectCreate;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar typedArrayFrom = typedArrayFrom$2;\nvar forEach = arrayIteration.forEach;\nvar setSpecies = setSpecies$2;\nvar definePropertyModule = objectDefineProperty;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar InternalStateModule = internalState;\nvar inheritIfRequired = inheritIfRequired$1;\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar enforceInternalState = InternalStateModule.enforce;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError$2 = global$4.RangeError;\nvar ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;\nvar ArrayBufferPrototype = ArrayBuffer$1.prototype;\nvar DataView$1 = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore$4.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore$4.isTypedArray;\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\nvar WRONG_LENGTH = 'Wrong length';\n\nvar fromList = function (C, list) {\n  aTypedArrayConstructor(C);\n  var index = 0;\n  var length = list.length;\n  var result = new C(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\nvar addGetter = function (it, key) {\n  nativeDefineProperty(it, key, { get: function () {\n    return getInternalState(this)[key];\n  } });\n};\n\nvar isArrayBuffer = function (it) {\n  var klass;\n  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$2(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n};\n\nvar isTypedArrayIndex = function (target, key) {\n  return isTypedArray(target)\n    && !isSymbol(key)\n    && key in target\n    && isIntegralNumber(+key)\n    && key >= 0;\n};\n\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n  key = toPropertyKey(key);\n  return isTypedArrayIndex(target, key)\n    ? createPropertyDescriptor(2, target[key])\n    : nativeGetOwnPropertyDescriptor(target, key);\n};\n\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n  key = toPropertyKey(key);\n  if (isTypedArrayIndex(target, key)\n    && isObject(descriptor)\n    && hasOwn(descriptor, 'value')\n    && !hasOwn(descriptor, 'get')\n    && !hasOwn(descriptor, 'set')\n    // TODO: add validation descriptor w/o calling accessors\n    && !descriptor.configurable\n    && (!hasOwn(descriptor, 'writable') || descriptor.writable)\n    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)\n  ) {\n    target[key] = descriptor.value;\n    return target;\n  } return nativeDefineProperty(target, key, descriptor);\n};\n\nif (DESCRIPTORS) {\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n    definePropertyModule.f = wrappedDefineProperty;\n    addGetter(TypedArrayPrototype, 'buffer');\n    addGetter(TypedArrayPrototype, 'byteOffset');\n    addGetter(TypedArrayPrototype, 'byteLength');\n    addGetter(TypedArrayPrototype, 'length');\n  }\n\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n    defineProperty: wrappedDefineProperty\n  });\n\n  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {\n    var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + TYPE;\n    var SETTER = 'set' + TYPE;\n    var NativeTypedArrayConstructor = global$4[CONSTRUCTOR_NAME];\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n    var exported = {};\n\n    var getter = function (that, index) {\n      var data = getInternalState(that);\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n    };\n\n    var setter = function (that, index, value) {\n      var data = getInternalState(that);\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n    };\n\n    var addElement = function (that, index) {\n      nativeDefineProperty(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n        anInstance(that, TypedArrayConstructorPrototype);\n        var index = 0;\n        var byteOffset = 0;\n        var buffer, byteLength, length;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new ArrayBuffer$1(byteLength);\n        } else if (isArrayBuffer(data)) {\n          buffer = data;\n          byteOffset = toOffset$1(offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);\n            byteLength = $len - byteOffset;\n            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);\n          } else {\n            byteLength = toLength$1($length) * BYTES;\n            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (isTypedArray(data)) {\n          return fromList(TypedArrayConstructor, data);\n        } else {\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }\n        setInternalState(that, {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength,\n          length: length,\n          view: new DataView$1(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n        anInstance(dummy, TypedArrayConstructorPrototype);\n        return inheritIfRequired(function () {\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n          if (isArrayBuffer(data)) return $length !== undefined\n            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)\n            : typedArrayOffset !== undefined\n              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))\n              : new NativeTypedArrayConstructor(data);\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }(), dummy, TypedArrayConstructor);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n        if (!(key in TypedArrayConstructor)) {\n          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n        }\n      });\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n    }\n\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n    }\n\n    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;\n\n    if (TYPED_ARRAY_TAG) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n    }\n\n    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;\n\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    setSpecies(CONSTRUCTOR_NAME);\n  };\n} else typedArrayConstructor.exports = function () { /* empty */ };\n\nvar createTypedArrayConstructor = typedArrayConstructor.exports;\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\nvar toPrimitive = toPrimitive$2;\n\nvar $TypeError$1 = TypeError;\n\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nvar toBigInt$1 = function (argument) {\n  var prim = toPrimitive(argument, 'number');\n  if (typeof prim == 'number') throw $TypeError$1(\"Can't convert number to bigint\");\n  // eslint-disable-next-line es-x/no-bigint -- safe\n  return BigInt(prim);\n};\n\nvar ArrayBufferViewCore$3 = arrayBufferViewCore;\nvar $fill = arrayFill$1;\nvar toBigInt = toBigInt$1;\nvar classof$1 = classof$9;\nvar call$3 = functionCall;\nvar uncurryThis$4 = functionUncurryThis;\nvar fails$5 = fails$s;\n\nvar aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;\nvar exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;\nvar slice = uncurryThis$4(''.slice);\n\n// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18\nvar CONVERSION_BUG = fails$5(function () {\n  var count = 0;\n  // eslint-disable-next-line es-x/no-typed-arrays -- safe\n  new Int8Array(2).fill({ valueOf: function () { return count++; } });\n  return count !== 1;\n});\n\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\nexportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {\n  var length = arguments.length;\n  aTypedArray$3(this);\n  var actualValue = slice(classof$1(this), 0, 3) === 'Big' ? toBigInt(value) : +value;\n  return call$3($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);\n}, CONVERSION_BUG);\n\nvar global$3 = global$t;\nvar call$2 = functionCall;\nvar ArrayBufferViewCore$2 = arrayBufferViewCore;\nvar lengthOfArrayLike = lengthOfArrayLike$8;\nvar toOffset = toOffset$2;\nvar toIndexedObject = toObject$7;\nvar fails$4 = fails$s;\n\nvar RangeError$1 = global$3.RangeError;\nvar Int8Array$2 = global$3.Int8Array;\nvar Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;\nvar exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;\n\nvar WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4(function () {\n  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing\n  var array = new Uint8ClampedArray(2);\n  call$2($set, array, { length: 1, 0: 3 }, 1);\n  return array[1] !== 3;\n});\n\n// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS && fails$4(function () {\n  var array = new Int8Array$2(2);\n  array.set(1);\n  array.set('2', 1);\n  return array[0] !== 0 || array[1] !== 2;\n});\n\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod$2('set', function set(arrayLike /* , offset */) {\n  aTypedArray$2(this);\n  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n  var src = toIndexedObject(arrayLike);\n  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call$2($set, this, src, offset);\n  var length = this.length;\n  var len = lengthOfArrayLike(src);\n  var index = 0;\n  if (len + offset > length) throw RangeError$1('Wrong length');\n  while (index < len) this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar global$2 = global$t;\nvar uncurryThis$3 = functionUncurryThis;\nvar fails$3 = fails$s;\nvar aCallable = aCallable$9;\nvar internalSort = arraySort;\nvar ArrayBufferViewCore$1 = arrayBufferViewCore;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;\nvar exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;\nvar Uint16Array = global$2.Uint16Array;\nvar un$Sort = Uint16Array && uncurryThis$3(Uint16Array.prototype.sort);\n\n// WebKit\nvar ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails$3(function () {\n  un$Sort(new Uint16Array(2), null);\n}) && fails$3(function () {\n  un$Sort(new Uint16Array(2), {});\n}));\n\nvar STABLE_SORT = !!un$Sort && !fails$3(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 74;\n  if (FF) return FF < 67;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 602;\n\n  var array = new Uint16Array(516);\n  var expected = Array(516);\n  var index, mod;\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  un$Sort(array, function (a, b) {\n    return (a / 4 | 0) - (b / 4 | 0);\n  });\n\n  for (index = 0; index < 516; index++) {\n    if (array[index] !== expected[index]) return true;\n  }\n});\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (y !== y) return -1;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (x !== x) return 1;\n    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;\n    return x > y;\n  };\n};\n\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod$1('sort', function sort(comparefn) {\n  if (comparefn !== undefined) aCallable(comparefn);\n  if (STABLE_SORT) return un$Sort(this, comparefn);\n\n  return internalSort(aTypedArray$1(this), getSortCompare(comparefn));\n}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);\n\nvar global$1 = global$t;\nvar apply$1 = functionApply;\nvar ArrayBufferViewCore = arrayBufferViewCore;\nvar fails$2 = fails$s;\nvar arraySlice$1 = arraySlice$5;\n\nvar Int8Array$1 = global$1.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\n\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$2(function () {\n  $toLocaleString.call(new Int8Array$1(1));\n});\n\nvar FORCED = fails$2(function () {\n  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();\n}) || !fails$2(function () {\n  Int8Array$1.prototype.toLocaleString.call([1, 2]);\n});\n\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod('toLocaleString', function toLocaleString() {\n  return apply$1(\n    $toLocaleString,\n    TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray(this)) : aTypedArray(this),\n    arraySlice$1(arguments)\n  );\n}, FORCED);\n\nclass Payload {\n  constructor(data) {\n    // The tag's value is a hardcoded value as per\n    // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)\n    this.tag = 2147484061;\n    this.message = data.message;\n    this.nonce = data.nonce;\n    this.recipient = data.recipient;\n    if (data.callbackUrl) {\n      this.callbackUrl = data.callbackUrl;\n    }\n  }\n}\nconst payloadSchema = new Map([[Payload, {\n  kind: \"struct\",\n  fields: [[\"tag\", \"u32\"], [\"message\", \"string\"], [\"nonce\", [32]], [\"recipient\", \"string\"], [\"callbackUrl\", {\n    kind: \"option\",\n    type: \"string\"\n  }]]\n}]]);\nconst serializeNep413 = signMessageParams => {\n  const payload = new Payload(Object.assign({}, signMessageParams));\n  return Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload));\n};\n\nconst verifySignature = ({\n  publicKey,\n  signature,\n  message,\n  nonce,\n  recipient,\n  callbackUrl\n}) => {\n  // Reconstruct the payload that was **actually signed**\n  const payload = new Payload({\n    message,\n    nonce,\n    recipient,\n    callbackUrl\n  });\n  // Serialize payload based on payloadSchema\n  const borshPayload = (0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload);\n  // Hash the payload as in the NEP0413 referenced example\n  // https://github.com/near/NEPs/blob/master/neps/nep-0413.md#references\n  // https://github.com/gagdiez/near-login/blob/main/authenticate/wallet-authenticate.js#L21\n  const hashedPayload = Uint8Array.from(js_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.array(borshPayload));\n  // Convert real signature to buffer base64\n  const realSignature = Buffer.from(signature, \"base64\");\n  const pk = near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(publicKey);\n  // Verify the signature\n  return pk.verify(hashedPayload, realSignature);\n};\nconst fetchAllUserKeys = ({\n  accountId,\n  network,\n  publicKey\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const key = yield provider.query({\n    request_type: \"view_access_key\",\n    account_id: accountId,\n    finality: \"final\",\n    public_key: publicKey\n  });\n  return key;\n});\nconst verifyFullKeyBelongsToUser = ({\n  publicKey,\n  accountId,\n  network\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    permission\n  } = yield fetchAllUserKeys({\n    accountId,\n    network,\n    publicKey\n  });\n  return permission === \"FullAccess\";\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$8;\nvar regexpExec$2 = regexpExec$3;\nvar fails$1 = fails$s;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar createNonEnumerableProperty = createNonEnumerableProperty$8;\n\nvar SPECIES = wellKnownSymbol('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toIntegerOrInfinity = toIntegerOrInfinity$6;\nvar toString$1 = toString$5;\nvar requireObjectCoercible$1 = requireObjectCoercible$6;\n\nvar charAt$1 = uncurryThis$1(''.charAt);\nvar charCodeAt = uncurryThis$1(''.charCodeAt);\nvar stringSlice$1 = uncurryThis$1(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$1(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$1(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$1(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$e;\nvar isCallable = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec$1, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject = anObject$e;\nvar requireObjectCoercible = requireObjectCoercible$6;\nvar speciesConstructor = speciesConstructor$3;\nvar advanceStringIndex = advanceStringIndex$1;\nvar toLength = toLength$6;\nvar toString = toString$5;\nvar getMethod = getMethod$4;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails = fails$s;\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(''.slice);\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = toString(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, '')) push(output, '');\n      } else push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n      return splitter\n        ? call(splitter, separator, O, limit)\n        : call(internalSplit, toString(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var rx = anObject(this);\n      var S = toString(string);\n      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n\n      if (res.done) return res.value;\n\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          push(A, stringSlice(S, p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            push(A, z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      push(A, stringSlice(S, p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n\nvar modal$b = {\n\twallet: {\n\t\tconnectYourWallet: \"Connect Your Wallet\",\n\t\twhatIsAWallet: \"What is a Wallet?\",\n\t\tsecureAndManage: \"Secure & Manage Your Digital Assets\",\n\t\tsafelyStore: \"Safely store and transfer your crypto and NFTs.\",\n\t\tlogInToAny: \"Log In to Any NEAR App\",\n\t\tnoNeedToCreate: \"No need to create new accounts or credentials. Connect your wallet and you are good to go!\",\n\t\tgetAWallet: \"Get a Wallet\",\n\t\tuseAWallet: \"Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.\",\n\t\tconnectionFailed: \"Connection Failed\",\n\t\tconnectionSuccessful: \"Connection Successful\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"Connecting to\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirm the connection in the extension window\",\n\t\t\tbrowser: \"Confirm the connection in the wallet after redirect\",\n\t\t\thardware: \"Confirm the connection in the ledger device\",\n\t\t\tbridge: \"Confirm the connection in the wallet\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Connect with Ledger\",\n\t\tmakeSureYourLedger: \"Make sure your Ledger is connected securely, and that the NEAR app is open on your device\",\n\t\t\"continue\": \"Continue\",\n\t\tspecifyHDPath: \"Specify HD Path\",\n\t\tenterYourPreferredHDPath: \"Enter your preferred HD path, then scan for any active accounts.\",\n\t\tscan: \"Scan\",\n\t\tretry: \"Retry\",\n\t\tledgerIsNotAvailable: \"Ledger is not available\",\n\t\taccessDeniedToUseLedgerDevice: \"Access denied to use Ledger device\",\n\t\tnoAccountsFound: \"No Accounts Found\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tconnecting1Account: \"Connecting 1 Account\",\n\t\tcantFindAnyAccount: \"Can't find any account associated with this Ledger. Please create a new NEAR account on\",\n\t\torConnectAnAnotherLedger: \"or connect an another Ledger.\",\n\t\tconnecting: \"Connecting\",\n\t\tofAccounts: \"of Accounts\",\n\t\tfailedToAutomatically: \"Failed to automatically find account id. Provide it manually:\",\n\t\toverviewTheListOfAuthorized: \"Overview the list of authorized account(s), complete sign in by clicking the button below.\",\n\t\tfinish: \"Finish\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"You'll need to install\",\n\t\ttoContinueAfterInstalling: \"to continue. After installing\",\n\t\trefreshThePage: \"refresh the page.\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copied to clipboard\",\n\t\tfailedToCopy: \"Failed to copy to clipboard\",\n\t\tscanWithYourMobile: \"Scan with Your Mobile Device\",\n\t\tcopyToClipboard: \" Copy to clipboard\",\n\t\tpreferTheOfficial: \"Prefer the official dialogue of\",\n\t\topen: \"Open\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Choose a Wallet\",\n\t\ttransferYourAccounts: \"Transfer Your Accounts\",\n\t\tselectAWallet: \"Select a wallet that fits your needs and supports your connected accounts.\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tafterDecide: \"After you decide on a wallet, you can select which accounts you want to transfer.\",\n\t\tdisclaimer: \"You won’t be able to transfer accounts that have never been funded or used on NEAR.\",\n\t\twarning: \"does not support account export at this time. Please select another wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Select Accounts to Transfer\",\n\t\t\tbutton: \"Continue\",\n\t\t\tdeselectAll: \"Deselect All\",\n\t\t\tselectAll: \"Select All\",\n\t\t\tunavailable: \"Transfer Unavailable\",\n\t\t\terror: \"Account does not exist\",\n\t\t\twarningLedger: \"Ledger support required\",\n\t\t\tnoBalance: \"Account not funded\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Copy Temporary Password\",\n\t\t\tdesc: \"You’ll need to enter this password when you begin exporting your accounts to a different wallet.\",\n\t\t\tbutton: \"Continue\",\n\t\t\ttransferButton: \"Transfer Accounts\",\n\t\t\tlabel: \"Click to Copy\",\n\t\t\tcheckLabel: \"I copied or wrote down the password\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Complete the Transfer\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Once import part of process is completed from selected wallet, press button to complete the transfer process.\",\n\t\t\tstartOverButton: \"Start Over\",\n\t\t\tbutton: \"Complete\"\n\t\t}\n\t}\n};\nvar component$1 = {\n\tclickToCopy: {\n\t\tlabel: \"Copied\",\n\t\ttooltip: \"Click to copy\"\n\t}\n};\nvar en = {\n\tmodal: modal$b,\n\tcomponent: component$1\n};\n\nvar modal$a = {\n\twallet: {\n\t\tconnectYourWallet: \"Conecta Tu Billetera\",\n\t\twhatIsAWallet: \"¿Que es una Billetera?\",\n\t\tsecureAndManage: \"Resguarda y Administrar Tus Activos Digitales\",\n\t\tsafelyStore: \"Almacena de forma segura y transfiere tus cryptos y NFT's\",\n\t\tlogInToAny: \"Inicie sesión en Cualquier Aplicacion NEAR\",\n\t\tnoNeedToCreate: \"No es necesario crear nuevas cuentas o credenciales, ¡Conecta tu billetera y listo!\",\n\t\tgetAWallet: \"Obten una Billetera\",\n\t\tuseAWallet: \"Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesión en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contraseñas\",\n\t\tconnectionFailed: \"Conexión Fallida\",\n\t\tconnectionSuccessful: \"Conexión Existosa\",\n\t\tconnected: \"Conectado\",\n\t\tconnectingTo: \"Conectando a \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirme la conexión en la ventana de extensión\",\n\t\t\tbrowser: \"Confirme la conexión en la billetera después de la redirección\",\n\t\t\thardware: \"Confirme la conexión en el dispositivo de libro mayor\",\n\t\t\tbridge: \"Confirmar la conexión en la billetera\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Conectar con Ledger\",\n\t\tmakeSureYourLedger: \"Asegúrese de que su ledger está conectada de forma segura y que la aplicacion NEAR esté abierta en su dispositivo\",\n\t\t\"continue\": \"Continuar\",\n\t\tspecifyHDPath: \"Especifique la ruta HD\",\n\t\tenterYourPreferredHDPath: \"Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.\",\n\t\tscan: \"Escanear\",\n\t\tretry: \"Reintentar\",\n\t\tledgerIsNotAvailable: \"El Ledger no está disponible\",\n\t\taccessDeniedToUseLedgerDevice: \"Acceso denegado para usar el dispositivo ledger\",\n\t\tnoAccountsFound: \"No se encontraron cuentas\",\n\t\tselectYourAccounts: \"Selecciona tus cuentas\",\n\t\tconnecting1Account: \"Conectando a 1 cuenta\",\n\t\tcantFindAnyAccount: \"No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR\",\n\t\torConnectAnAnotherLedger: \"o conecta otro ledger\",\n\t\tconnecting: \"Conectando\",\n\t\tofAccounts: \"de Cuentas\",\n\t\tfailedToAutomatically: \"No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:\",\n\t\toverviewTheListOfAuthorized: \"Revise la lista de las cuentas autorizadas,Complete el inicio de sesión haciedo click a countinuacion.\",\n\t\tfinish: \"Finalizar\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Tendrás que instalar\",\n\t\ttoContinueAfterInstalling: \"Para continuar, Despues de instalar\",\n\t\trefreshThePage: \"Recarga la pagina\",\n\t\topen: \"Abrir\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copiado al Portapapeles\",\n\t\tfailedToCopy: \"Falló la copia al Portapapeles\",\n\t\tscanWithYourMobile: \"Busca con tu dispositivo movil\",\n\t\tcopyToClipboard: \" Copiar al Portapapeles\",\n\t\tpreferTheOfficial: \"¿Prefires el diálogo oficial de\",\n\t\topen: \"Abrir\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar es = {\n\tmodal: modal$a\n};\n\nvar modal$9 = {\n\twallet: {\n\t\tconnectYourWallet: \"连接你的钱包\",\n\t\twhatIsAWallet: \"什么是钱包？\",\n\t\tsecureAndManage: \"保护和管理你的数字资产\",\n\t\tsafelyStore: \"安全存储和转移你的加密货币和NFT\",\n\t\tlogInToAny: \"登录任何 NEAR 应用\",\n\t\tnoNeedToCreate: \"不需要创建新账户或密码。连接你的钱包，即可开始使用！\",\n\t\tgetAWallet: \"获取新账户\",\n\t\tuseAWallet: \"使用钱包来保护和管理你的 NEAR 资产，无需用户名和密码即可登录任何 NEAR 应用\",\n\t\tconnectionFailed: \"连接失败\",\n\t\tconnectionSuccessful: \"连接成功\",\n\t\tconnected: \"已连接\",\n\t\tconnectingTo: \"正在连接\"\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"连接 Ledger\",\n\t\tmakeSureYourLedger: \"确保你的 Ledger 已经安全连接，并且 NEAR 应用已经在你设备上打开\",\n\t\t\"continue\": \"继续\",\n\t\tspecifyHDPath: \"指定 HD 路径\",\n\t\tenterYourPreferredHDPath: \"输入你偏好的 HD 路径，然后为任意活跃账户扫码\",\n\t\tscan: \"扫码\",\n\t\tretry: \"重试\",\n\t\tledgerIsNotAvailable: \"Ledger 不可用\",\n\t\taccessDeniedToUseLedgerDevice: \"访问 Ledger 设备被拒绝\",\n\t\tnoAccountsFound: \"没有找到账户\",\n\t\tselectYourAccounts: \"选择你的账户\",\n\t\tconnecting1Account: \"正在连接1个账户\",\n\t\tcantFindAnyAccount: \"没有找到任何与这个 Ledger 相关联的账户。请创建新账户于\",\n\t\t\"orConnectAnAnotherLedger.\": \"或连接另一个 Ledger\",\n\t\tconnecting: \"正在连接\",\n\t\tofAccounts: \"个账户\",\n\t\tfailedToAutomatically: \"无法自动找到账户ID，请主动提供：\",\n\t\toverviewTheListOfAuthorized: \"请查看已授权的账户列表，点击以下按钮完成登录\",\n\t\tfinish: \"完成\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"你将需要安装\",\n\t\ttoContinueAfterInstalling: \"以继续。安装完\",\n\t\trefreshThePage: \"请刷新页面\",\n\t\topen: \"打开\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"复制到了剪贴板\",\n\t\tfailedToCopy: \"复制到剪贴板失败\",\n\t\tscanWithYourMobile: \"用你的移动设备扫码\",\n\t\tcopyToClipboard: \" 复制到剪贴板\",\n\t\tpreferTheOfficial: \"希望使用官方对话框于\",\n\t\topen: \"打开\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar zh = {\n\tmodal: modal$9\n};\n\nvar modal$8 = {\n\twallet: {\n\t\tconnectYourWallet: \"Свържете вашия Портфейл\",\n\t\twhatIsAWallet: \"Какво е Портфейл?\",\n\t\tsecureAndManage: \"Защитете и управлявайте дигиталните си активи\",\n\t\tsafelyStore: \"Съхранявайте и прехвърляйте безопасно вашите крипто и NFT.\",\n\t\tlogInToAny: \"Използвайте всяко приложение на NEAR\",\n\t\tnoNeedToCreate: \"Няма нужда да създавате нови профили. Свържете портфейла си и сте готови!\",\n\t\tgetAWallet: \"Създайте Портфейл\",\n\t\tuseAWallet: \"Използвайте портфейла, за да защитите и управлявате активите си на NEAR както и да използвате всяко приложение на NEAR без нужда от потребителски имена и пароли.\",\n\t\tconnectionFailed: \"Свързването неуспешно\",\n\t\tconnectionSuccessful: \"Свързването успешно\",\n\t\tconnected: \"Свързан\",\n\t\tconnectingTo: \"Свързване към\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потвърдете свързването в прозореца на разширението\",\n\t\t\tbrowser: \"Потвърдете свързването в портфейла след пренасочването\",\n\t\t\thardware: \"Потвърдете свързването в хардуерния портфейл\",\n\t\t\tbridge: \"Потвърдете връзката в портфейла\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Свържете се с Ledger\",\n\t\tmakeSureYourLedger: \"Уверете се, че вашият Ledger е свързан и че приложението NEAR е отворено нa него.\",\n\t\t\"continue\": \"Продължете\",\n\t\tspecifyHDPath: \"Посочете HD път\",\n\t\tenterYourPreferredHDPath: \"Въведете предпочитания HD път, след което сканирайте за активни акаунти.\",\n\t\tscan: \"Сканирайте\",\n\t\tretry: \"Опитайте отново\",\n\t\tledgerIsNotAvailable: \"Ledger устройството не е достъпно\",\n\t\taccessDeniedToUseLedgerDevice: \"Достъпът за използване на Ledger е отказан\",\n\t\tnoAccountsFound: \"Няма намерени профили\",\n\t\tselectYourAccounts: \"Изберете вашите профили\",\n\t\tconnecting1Account: \"Свързване на 1 профил\",\n\t\tcantFindAnyAccount: \"Няма намерени профили, съврзани с този Ledger. Моля, създайте нов NEAR профил на\",\n\t\torConnectAnAnotherLedger: \"или свържете друг Ledger.\",\n\t\tconnecting: \"Свързване\",\n\t\tofAccounts: \"от профили\",\n\t\tfailedToAutomatically: \"Автоматичното намиране на профила не бе успешно. Въведете го ръчно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледайте списъка с упълномощени профили, завършете влизането, като щракнете върху бутона по-долу..\",\n\t\tfinish: \"Завършете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ще трябва да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продължите. След инсталиране\",\n\t\trefreshThePage: \"презаредете страницата.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано в клипборда\",\n\t\tfailedToCopy: \"Неуспешно копиране в клипборда\",\n\t\tscanWithYourMobile: \" Сканирайте с мобилното си устройство\",\n\t\tcopyToClipboard: \" Копирайте в клипборда\",\n\t\tpreferTheOfficial: \"Предпочитан език за кореспонденция\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar bg = {\n\tmodal: modal$8\n};\n\nvar modal$7 = {\n\twallet: {\n\t\tconnectYourWallet: \"지갑 연결하기\",\n\t\twhatIsAWallet: \"지갑은 무슨 역할을 하나요?\",\n\t\tsecureAndManage: \"당신의 디지털 자산을 보호하고 관리합니다.\",\n\t\tsafelyStore: \"암호화폐와 NFT를 안전하게 저장하고 전송할 수 있습니다.\",\n\t\tlogInToAny: \"NEAR App에 로그인합니다.\",\n\t\tnoNeedToCreate: \"새로운 계정이나 비밀번호를 만들 필요 없이 지갑을 연결한 후 바로 사용할 수 있습니다.\",\n\t\tgetAWallet: \"지갑 가져오기\",\n\t\tuseAWallet: \"지갑을 사용하여 NEAR 자산을 보호·관리하고, 아이디와 비밀번호 없이 NEAR 앱에 로그인할 수 있습니다.\",\n\t\tconnectionFailed: \"연결 실패\",\n\t\tconnectionSuccessful: \"연결 성공\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"연결 중: \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"익스텐션 창에서 연결을 확인하세요\",\n\t\t\tbrowser: \"리다이렉트 된 지갑에서 연결을 확인하세요\",\n\t\t\thardware: \"Ledger 기기에서 연결을 확인하세요\",\n\t\t\tbridge: \"지갑에서 연결 확인\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ledger 연결하기\",\n\t\tmakeSureYourLedger: \"Ledger가 안전하게 연결되어 있고, NEAR 앱이 열려 있는 지 확인하세요\",\n\t\t\"continue\": \"계속하기\",\n\t\tspecifyHDPath: \"HD Path 지정하기\",\n\t\tenterYourPreferredHDPath: \"원하는 HD Path를 선택하고, 활성화된 계정이 있는 지 검색하세요\",\n\t\tscan: \"검색\",\n\t\tretry: \"다시 시도\",\n\t\tledgerIsNotAvailable: \"Ledger를 사용할 수 없습니다\",\n\t\taccessDeniedToUseLedgerDevice: \"Ledger 기기 접근 권한이 거부되었습니다\",\n\t\tnoAccountsFound: \"계정을 찾을 수 없습니다\",\n\t\tselectYourAccounts: \"계정 선택하기\",\n\t\tconnecting1Account: \"하나의 계정에 연결\",\n\t\tcantFindAnyAccount: \"Ledger와 연결된 계정을 찾을 수 없습니다. 새로운 계정을 생성하거나 \",\n\t\torConnectAnAnotherLedger: \"다른 Ledger를 연결하세요\",\n\t\tconnecting: \"계정 연결하기: \",\n\t\tofAccounts: \"개 계정을 찾았습니다\",\n\t\tfailedToAutomatically: \"계정 ID를 찾지 못했습니다. 수동으로 입력해주세요.\",\n\t\toverviewTheListOfAuthorized: \"인증된 계정 목록을 확인한 후 아래 버튼을 클릭하여 로그인을 완료하세요\",\n\t\tfinish: \"완료\"\n\t},\n\twalletTypes: {\n\t\thardware: \"하드웨어 지갑\",\n\t\tbrowser: \"브라우저 지갑\",\n\t\tinjected: \"지갑 확장\",\n\t\tbridge: \"브리지 지갑\",\n\t\tmobile: \"모바일 지갑\",\n\t\t\"instant-link\": \"인스턴트 지갑\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"다음 확장 프로그램을 설치해주세요:\",\n\t\ttoContinueAfterInstalling: \". 설치 완료 후 페이지 새로 고침이 필요합니다. \",\n\t\trefreshThePage: \"새로 고침\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"클립보드에 복사 완료\",\n\t\tfailedToCopy: \"클립보드에 복사 실패\",\n\t\tscanWithYourMobile: \"모바일 장치를 사용하여 스캔해주세요\",\n\t\tcopyToClipboard: \" 클립보드에 복사하기\",\n\t\tpreferTheOfficial: \"다음 프로그램에서 제공하는 공식 프로세스를 선호하십니까: \",\n\t\topen: \"Open\"\n\t}\n};\nvar ko = {\n\tmodal: modal$7\n};\n\nvar modal$6 = {\n\twallet: {\n\t\tconnectYourWallet: \"Kết nối ví của bạn\",\n\t\twhatIsAWallet: \"Ví là gì?\",\n\t\tsecureAndManage: \"Bảo mật & Quản lý tài sản số của bạn\",\n\t\tsafelyStore: \"Lưu trữ và chuyển tiền điện tử và NFT của bạn một cách an toàn.\",\n\t\tlogInToAny: \"Đăng nhập vào bất kỳ ứng dụng trên NEAR\",\n\t\tnoNeedToCreate: \"Không cần tạo tài khoản hoặc thông tin đăng nhập mới. Kết nối ví của bạn và bắt đầu!\",\n\t\tgetAWallet: \"Tạo Ví\",\n\t\tuseAWallet: \"Sử dụng ví để bảo mật và quản lý tài sản trên NEAR của bạn và đăng nhập vào bất kỳ ứng dụng NEAR nào, không cần tên người dùng và mật khẩu.\",\n\t\tconnectionFailed: \"Kết nối thất bại\",\n\t\tconnectionSuccessful: \"Kết nối thành công\",\n\t\tconnected: \"Đã kết nối\",\n\t\tconnectingTo: \"Đang kết nối tới\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Xác nhận kết nối trong cửa sổ tiện ích mở rộng\",\n\t\t\tbrowser: \"Xác nhận kết nối trong ví sau khi được chuyển hướng\",\n\t\t\thardware: \"Xác nhận kết nối với ví lạnh\",\n\t\t\tbridge: \"Xác nhận kết nối trong ví\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Kết nối ví Ledger\",\n\t\tmakeSureYourLedger: \"Đảm bảo Ledger của bạn được kết nối an toàn và ứng dụng NEAR đang mở sẵn trên thiết bị\",\n\t\t\"continue\": \"Tiếp tục\",\n\t\tspecifyHDPath: \"Chỉ định HD Path\",\n\t\tenterYourPreferredHDPath: \"Nhập HD Path của bạn, sau đó quét tìm các tài khoản hoạt động\",\n\t\tscan: \"Quét\",\n\t\tretry: \"Thử lại\",\n\t\tledgerIsNotAvailable: \"Ledger không khả dụng\",\n\t\taccessDeniedToUseLedgerDevice: \"Truy cập Ledger bị từ chối\",\n\t\tnoAccountsFound: \"Không tìm thấy tài khoản\",\n\t\tselectYourAccounts: \"Chọn tài khoản của bạn\",\n\t\tconnecting1Account: \"Đang kết nối 1 tài khoản\",\n\t\tcantFindAnyAccount: \"Không thể tìm thấy bất kỳ tài khoản nào được liên kết với Ledger này. Vui lòng tạo một tài khoản NEAR mới\",\n\t\torConnectAnAnotherLedger: \"hoặc kết nối với ví Ledger khác.\",\n\t\tconnecting: \"Đang kết nối\",\n\t\tofAccounts: \"của tài khoản\",\n\t\tfailedToAutomatically: \"Không thể tự động tìm id tài khoản. Nhập thủ công:\",\n\t\toverviewTheListOfAuthorized: \"Tổng quan danh sách các tài khoản được ủy quyền, hoàn tất đăng nhập bằng cách bấm vào nút bên dưới.\",\n\t\tfinish: \"Hoàn thành\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Bạn sẽ cần cài đặt\",\n\t\ttoContinueAfterInstalling: \"để bắt đầu. Sau khi cài đặt xong\",\n\t\trefreshThePage: \"Tải lại trang.\",\n\t\topen: \"Mở\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Đã sao chép vào bảng ghi tạm\",\n\t\tfailedToCopy: \"Sao chép vào bảng ghi tạm thất bại\",\n\t\tscanWithYourMobile: \"Quét với điện thoại của bạn\",\n\t\tcopyToClipboard: \" Sao chép vào bảng ghi tạm\",\n\t\tpreferTheOfficial: \"Dialogue chính thức của\",\n\t\topen: \"Mở\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Ví lạnh\",\n\t\tbrowser: \"Ví trình duyệt\",\n\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\tbridge: \"Ví Cầu\",\n\t\tmobile: \"Ví Mobile\",\n\t\t\"instant-link\": \"Ví tức thì\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Chọn ví\",\n\t\ttransferYourAccounts: \"Chuyển tài khoản\",\n\t\tselectAWallet: \"Chọn ví phù hợp với nhu cầu của bạn, ví được chọn cần hỗ trợ các tài khoản đang sử dụng.\",\n\t\tselectYourAccounts: \"Chọn tài khoản\",\n\t\tafterDecide: \"Sau khi chọn được tài khoản bạn có chuyển.\",\n\t\tdisclaimer: \"Bạn không thể chuyển tài khoản nếu tài khoản đó chưa được nhận tiền hoặc chưa phát sinh giao dịch trên NEAR.\",\n\t\twarning: \"không hỗ trợ xuất tài khoản. Vui lòng chọn ví khác.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Ví lạnh\",\n\t\t\tbrowser: \"Ví trình duyệt\",\n\t\t\tinjected: \"Ví tiện ích mở rộng\",\n\t\t\tbridge: \"Ví Cầu\",\n\t\t\tmobile: \"Ví Mobile\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Chọn tài khoản để chuyển\",\n\t\t\tbutton: \"Lấy cụm mật khẩu\",\n\t\t\tdeselectAll: \"Bỏ chọn tất cả\",\n\t\t\tselectAll: \"Chọn tất cả\",\n\t\t\tunavailable: \"Chuyển không khả dụng\",\n\t\t\terror: \"Tài khoản không tồn tại\",\n\t\t\twarningLedger: \"Yêu cầu hỗ trợ Ledger\",\n\t\t\tnoBalance: \"Tài khoản trống\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Sao chép mật khẩu tạm thời\",\n\t\t\tdesc: \"Bạn sẽ cần nhập mật khẩu khi bắt đầu xuất các khoản tới ví khác.\",\n\t\t\tbutton: \"Tiếp tục\",\n\t\t\tlabel: \"Bấm để sao chép\",\n\t\t\tcheckLabel: \"Tôi đã chép hoặc ghi lại mật khẩu\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Hoàn thành chuyển\",\n\t\t\tdescOne: \"Bạn sẽ được chuyển hướng tới tài khoản đã chọn để hoàn tất quá trình.\",\n\t\t\tdescTwo: \"Sau khi nhập, nhấn nút để hoàn tất quy trình chuyển.\",\n\t\t\tbutton: \"Hoàn thành\"\n\t\t}\n\t}\n};\nvar component = {\n\tclickToCopy: {\n\t\tlabel: \"Đã sao chép\",\n\t\ttooltip: \"Bấm để sao chép\"\n\t}\n};\nvar vi = {\n\tmodal: modal$6,\n\tcomponent: component\n};\n\nvar modal$5 = {\n\twallet: {\n\t\tconnectYourWallet: \"अपना वॉलेट (Wallet) कनेक्ट करें।\",\n\t\twhatIsAWallet: \"वॉलेट क्या है?\",\n\t\tsecureAndManage: \"सुरक्षित और प्रबंधित करें।\",\n\t\tsafelyStore: \"अपनी क्रिप्टोकरेंसी और एनएफटी को सुरक्षित रूप से स्टोर और ट्रांसफर करें।\",\n\t\tlogInToAny: \"NEAR पर किसी भी ऐप में साइन इन करें।\",\n\t\tnoNeedToCreate: \"नए खाते या लॉगिन बनाने की आवश्यकता नहीं है। अपना वॉलेट(NEAR Wallet)कनेक्ट करें और आरंभ करें।\",\n\t\tgetAWallet: \"एक वॉलेट बनाएँ।\",\n\t\tuseAWallet: \"अपनी NEAR संपत्तियों को सुरक्षित और प्रबंधित करने के लिए वॉलेट का उपयोग करें और किसी भी NEAR ऐप (app) में लॉग इन करें, किसी उपयोगकर्ता (user) नाम और पासवर्ड की आवश्यकता नहीं है।\",\n\t\tconnectionFailed: \"कनेक्शन विफल|\",\n\t\tconnectionSuccessful: \"कनेक्शन सफल|\",\n\t\tconnected: \"वॉलेट जुड़ गया|\",\n\t\tconnectingTo: \"वॉलेट जुड़ रहा हे|\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"एक्सटेंशन विंडो में कनेक्शन की पुष्टि करें|\",\n\t\t\tbrowser: \"रीडायरेक्ट होने के बाद वॉलेट में कनेक्शन की पुष्टि करें|\",\n\t\t\thardware: \"कोल्ड वॉलेट के साथ कनेक्शन की पुष्टि करें|\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"लेजर(Ledger)वॉलेट कनेक्ट करें|\",\n\t\tmakeSureYourLedger: \"सुनिश्चित करें कि आपका लेजर सुरक्षित रूप से जुड़ा हुआ है और NEAR ऐप आपके डिवाइस (Device)पर पहले से ही खुला है|\",\n\t\t\"continue\": \"जारी रखे|\",\n\t\tspecifyHDPath: \"हार्ड डिस्क(Hard Disk)पथ(Path)निर्धारित करे|\",\n\t\tenterYourPreferredHDPath: \"अपना एचडी पथ दर्ज करें, फिर सक्रिय खातों के लिए स्कैन करें|\",\n\t\tscan: \"स्कैन करे|\",\n\t\tretry: \"दोबारा प्रयास करे|\",\n\t\tledgerIsNotAvailable: \"लेजर उपलब्ध नहीं है|\",\n\t\taccessDeniedToUseLedgerDevice: \"लेजर डिवाइस का उपयोग करने के लिए प्रवेश निषेध|\",\n\t\tnoAccountsFound: \"खाता नहीं मिला|\",\n\t\tselectYourAccounts: \"अपने खाते चुनें|\",\n\t\tconnecting1Account: \"एक खाता कनेक्ट हो रहा है|\",\n\t\tcantFindAnyAccount: \"इस लेजर से जुड़ा कोई खाता नहीं मिला। कृपया एक नया NEAR खाता बनाएँ|\",\n\t\torConnectAnAnotherLedger: \"अथवा दूसरे लेजर वॉलेट से कनेक्ट करें।\",\n\t\tconnecting: \"जुड़ रहा हे|\",\n\t\tofAccounts: \"खाता अब जुड़ा नहीं हे|\",\n\t\tfailedToAutomatically: \"खाता आईडी स्वचालित रूप से खोजने में असमर्थ। मैन्युअल (Manuall) रूप से कोशिश करें|\",\n\t\toverviewTheListOfAuthorized: \"अवलोकन अधिकृत की सूची, नीचे दिए गए बटन पर क्लिक करके लॉगिन पूरा करें।\",\n\t\tfinish: \"समाप्त|\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"आपको इंस्टॉल करना होगा|\",\n\t\ttoContinueAfterInstalling: \"इंस्टॉल करने के बाद जारी रखे|\",\n\t\trefreshThePage: \"पुन: लोड करें।\",\n\t\topen: \"खोले|\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"क्लिपबोर्ड(Clipboard)पर कॉपी किया गया|\",\n\t\tfailedToCopy: \"क्लिपबोर्ड पर कॉपी करना विफल रहा|\",\n\t\tscanWithYourMobile: \"अपने फोन (Mobile)से स्कैन करें|\",\n\t\tcopyToClipboard: \" क्लिपबोर्ड पर कॉपी करें|\",\n\t\tpreferTheOfficial: \"आधिकारिक संवाद को प्राथमिकता दें|\",\n\t\topen: \"खोले|\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar hi = {\n\tmodal: modal$5\n};\n\nvar modal$4 = {\n\twallet: {\n\t\tconnectYourWallet: \"صل محفظتك\",\n\t\twhatIsAWallet: \"ما هي المحفظة؟\",\n\t\tsecureAndManage: \"تأمين وإدارة الممتلكات الرقمية الخاصة بك\",\n\t\tsafelyStore: \"قم بتخزين و ارسال عملاتك و أصولك الرقمية بأمان\",\n\t\tlogInToAny: \"سجل الدخول إلى أي تطبيق يستخدم نير\",\n\t\tnoNeedToCreate: \".لا داعي لإنشاء حساب جديد. فقط قم بتوصيل محفظتك وانطلق\",\n\t\tgetAWallet: \"احصل على محفظة\",\n\t\tuseAWallet: \"استخدم محفظة لتأمين وإدارة أصول نير الخاصة بك، وادخل لأي تطبيق يستخدم نير دون الحاجة إلى اسم المستخدم وكلمةالمرور\",\n\t\tconnectionFailed: \"اتصال فاشل\",\n\t\tconnectionSuccessful: \"اتصال ناجح\",\n\t\tconnected: \"متصل\",\n\t\tconnectingTo: \"جاري الاتصال ب\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"وافق على الاتصال في نافذة الإضافة\",\n\t\t\tbrowser: \"وافق على الاتصال في المحفظة بعد إعادة توجيه\",\n\t\t\thardware: \"وافق على الاتصال في جهاز ليدجر\",\n\t\t\tbridge: \"وافق على الاتصال في المحفظة\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"اتصل مع ليدجر\",\n\t\tmakeSureYourLedger: \"تأكد أن ليدجر متصل بأمان, و أن تطبيق نير مفتوح في جهازك\",\n\t\t\"continue\": \"تابع\",\n\t\tspecifyHDPath: \"حدد مسار الحساب\",\n\t\tenterYourPreferredHDPath: \"أدخل مسار الحساب المفضل، ثم ابحث عن كل الحسابات النشطة\",\n\t\tscan: \"مسح\",\n\t\tretry: \"أعد المحاولة\",\n\t\tledgerIsNotAvailable: \"ليدجر غير متوفر\",\n\t\taccessDeniedToUseLedgerDevice: \"تم رفض الاتصال بليدجر\",\n\t\tnoAccountsFound: \"لم يتم العثور على أي حسابات\",\n\t\tselectYourAccounts: \"حدد حساباتك\",\n\t\tconnecting1Account: \"جاري الاتصال بحساب واحد\",\n\t\tcantFindAnyAccount: \"لا يمكن العثور على أي حساب مرتبط بهذا ليدجر الرجاء إنشاء حساب نير جديد على\",\n\t\torConnectAnAnotherLedger: \"او اربط جهاز ليدجر آخر\",\n\t\tconnecting: \"جاري الاتصال\",\n\t\tofAccounts: \"من الحسابات\",\n\t\tfailedToAutomatically: \"فشل في الاتصال بالحساب تلقائيا. يرجى الاتصال بالحساب يدويا\",\n\t\toverviewTheListOfAuthorized: \"لائحة الحسابات المصرح بها, أكمل تسجيل الدخول بالنقر على الزر أدناه\",\n\t\tfinish: \"إنهاء\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ستحتاج لتثبيت\",\n\t\ttoContinueAfterInstalling: \"للاستكمال. بعد التثبيت\",\n\t\trefreshThePage: \"قم بتحديث الصفحة\",\n\t\topen: \"افتح\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"تم النسخ\",\n\t\tfailedToCopy: \"فشل النسخ\",\n\t\tscanWithYourMobile: \"امسح بجهازك المحمول\",\n\t\tcopyToClipboard: \"نسخ\",\n\t\tpreferTheOfficial: \"تفضل الحوار الرسمي ل\",\n\t\topen: \"فتح\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar ar = {\n\tmodal: modal$4\n};\n\nvar modal$3 = {\n\twallet: {\n\t\tconnectYourWallet: \"Spojite crypto novčanik!\",\n\t\twhatIsAWallet: \"Što je to crypto novčanik?\",\n\t\tsecureAndManage: \"Osigurajte i upravljajte svojom digitalnom imovinom.\",\n\t\tsafelyStore: \"Sigurno pohranite i prebacite svoj crypto i NFT-eve.\",\n\t\tlogInToAny: \" Prijavite se u bilo koju NEAR aplikaciju\",\n\t\tnoNeedToCreate: \"Nema potrebe za stvaranjem novih naloga ili korisničkih podataka. Spojite svoj crypto novčanik i spremni ste!\",\n\t\tgetAWallet: \"Otvorite crypto novčanik\",\n\t\tuseAWallet: \"Koristite crypto novčanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisničkog imena i lozinke.\",\n\t\tconnectionFailed: \"Neuspješno povezivanje.\",\n\t\tconnectionSuccessful: \"Uspješno povezivanje.\",\n\t\tconnected: \"Povezano.\",\n\t\tconnectingTo: \"Povezivanje u tijeku\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potvrdite vezu u eksternom prozoru\",\n\t\t\tbrowser: \"Nakon redirekcije, potvrdite vezu u novčaniku\",\n\t\t\thardware: \"Potvrdite vezu sa novčanikom\",\n\t\t\tbridge: \"Potvrdite vezu u novčaniku\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se hardverskim novčanikom\",\n\t\tmakeSureYourLedger: \"Osigurajte sigurnu vezu s hardverskim novčanikom, te da je NEAR aplikacija otvorena na vašem uređaju\",\n\t\t\"continue\": \"Nastavite\",\n\t\tspecifyHDPath: \"Specificirajte HD putanju\",\n\t\tenterYourPreferredHDPath: \"Upišite preferiranu HD putanju, zatim skenirajte aktivne naloge\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Pokušajte ponovno\",\n\t\tledgerIsNotAvailable: \"Hardverski novčanik nije dostupan.\",\n\t\taccessDeniedToUseLedgerDevice: \"Odbijen pristup za korištenjem hardverskog novčanika\",\n\t\tnoAccountsFound: \"Nalozi nisu pronađeni\",\n\t\tselectYourAccounts: \"Odaberite svoje naloge\",\n\t\tconnecting1Account: \"Povezivanje 1 naloga\",\n\t\tcantFindAnyAccount: \"Nije moguće pronaći niti jedan nalog povezan s ovim hardverskim novčanikom. Molimo vas, kreirajte novi NEAR nalog\",\n\t\torConnectAnAnotherLedger: \"Ili povežite drugi hardverski novčanik.\",\n\t\tconnecting: \"Povezivanje\",\n\t\tofAccounts: \"naloga\",\n\t\tfailedToAutomatically: \"Neuspješno automatsko pronalaženje ID naloga. Unesite ručno:\",\n\t\toverviewTheListOfAuthorized: \"Pregledajte popis odobrenih naloga, završite prijavu pritiskom na niže prikazani gumb.\",\n\t\tfinish: \"Završite\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \" Potrebno je instalirati modal\",\n\t\ttoContinueAfterInstalling: \"za nastavak. Nakon instalacije\",\n\t\trefreshThePage: \"osvježite stranicu.\",\n\t\topen: \"Otvorite QR modal\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano u međuspremnik\",\n\t\tfailedToCopy: \"Neupsješno kopiranje u međuspremnik\",\n\t\tscanWithYourMobile: \"Skenirajte svojim mobilnim uređajem\",\n\t\tcopyToClipboard: \" Kopirajte u međuspremnik\",\n\t\tpreferTheOfficial: \"Odaberite službeni dijalog\",\n\t\topen: \"Otvorite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Odaberi Wallet\",\n\t\ttransferYourAccounts: \"Prenesi svoje naloge\",\n\t\tselectAWallet: \"Odaberite wallet koji odgovara vašim potrebama i podržava vaše povezane naloge.\",\n\t\tselectYourAccounts: \"Odaberi svoje naloge\",\n\t\tafterDecide: \"Nakon što odlučite koji wallet koristite, možete odabrati koje račune želite prebaciti.\",\n\t\tdisclaimer: \"Nećete moći prebaciti naloge koji nisu nikada bili korišteni na NEAR-u.\",\n\t\twarning: \"ne podržava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Odaberi naloge za prijenos\",\n\t\t\tbutton: \"Generiraj lozinku\",\n\t\t\tdeselectAll: \"Makni odabir sa svih\",\n\t\t\tselectAll: \"Odaberi sve\",\n\t\t\tunavailable: \"Prijenos nije dostupan\",\n\t\t\terror: \"Nalog ne postoji\",\n\t\t\twarningLedger: \"Potrebna ledger podrška\",\n\t\t\tnoBalance: \"Nalog nema sredstava\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj privremenu lozinku\",\n\t\t\tdesc: \"Bit će potrebno unijeti ovu lozinku na početku izvoza naloga na drugi wallet.\",\n\t\t\tbutton: \"Nastavi\",\n\t\t\tlabel: \"Klikni za kopiju\",\n\t\t\tcheckLabel: \"Kopirao sam ili zapisao lozinku\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Završi prijenos\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Kada je unos s odabranog walleta završen, pritisnite gumb da biste završili prijenos.\",\n\t\t\tbutton: \"Završi\"\n\t\t}\n\t}\n};\nvar hr = {\n\tmodal: modal$3\n};\n\nvar modal$2 = {\n\twallet: {\n\t\tconnectYourWallet: \"Поврзете го вашиот новчаник!\",\n\t\twhatIsAWallet: \"Што е новчаник?\",\n\t\tsecureAndManage: \"Заштитете ги и управувајте со вашите дигитални средства.\",\n\t\tsafelyStore: \"Безбедно складирајте и извршувајте трансакции со вашите крипто и NFT.\",\n\t\tlogInToAny: \"Најавете се на која било NEAR апликација\",\n\t\tnoNeedToCreate: \"Нема потреба да креирате нови сметки или ингеренции. Поврзете го вашиот паричник и сте подготвени!\",\n\t\tgetAWallet: \"Направете новчаник\",\n\t\tuseAWallet: \"Користете паричник за да ги заштитите и управувате вашите NEAR средства и да се најавите на која било NEAR апликација без потреба од кориснички имиња и лозинки.\",\n\t\tconnectionFailed: \"Поврзувањето не беше успешно.\",\n\t\tconnectionSuccessful: \"Успешно поврзување.\",\n\t\tconnected: \"Поврзано.\",\n\t\tconnectingTo: \"Поврзување со\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдете го поврзувањето во екстерниот прозорец\",\n\t\t\tbrowser: \"По преусмерувањето, потврдете го поврзувањето од новчаниокт\",\n\t\t\thardware: \"Потврдете го поврзувањето со ладен новчаник\",\n\t\t\tbridge: \"Потврдете ја врската во новчаникот\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Поврзете се со Леџер\",\n\t\tmakeSureYourLedger: \"Осигурајте се дека вашиот Леџер е поврзан безбедно, и дека NEAR апликацијата е отворена на вашиот уред\",\n\t\t\"continue\": \"Продолжете\",\n\t\tspecifyHDPath: \"Наведете ХД локација\",\n\t\tenterYourPreferredHDPath: \"Внесете ја вашата преферирана ХД локација, а потоа скенирајте да ги најдете активните сметки.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Обидете се повторно\",\n\t\tledgerIsNotAvailable: \"Леџерот не е достапен.\",\n\t\taccessDeniedToUseLedgerDevice: \"Пристапот за користење на Леџер уред е одбиен\",\n\t\tnoAccountsFound: \"Нема најдени сметки\",\n\t\tselectYourAccounts: \"Изберете ги вашите сметки\",\n\t\tconnecting1Account: \"Поврзување на една сметка\",\n\t\tcantFindAnyAccount: \"Не се најдени сметки поврзани со овој Леџер. Ве молиме креирајте нова NEAR сметка \",\n\t\torConnectAnAnotherLedger: \"или поврзете друг Леџер.\",\n\t\tconnecting: \"Поврзување\",\n\t\tofAccounts: \"на сметки\",\n\t\tfailedToAutomatically: \"Неуспешно автоматско барање на ИД на сметката. Внесете го рачно:\",\n\t\toverviewTheListOfAuthorized: \"Преглед на листата на овластени сметки, завршете се најавата со кликнување на копчето подолу.\",\n\t\tfinish: \"Завршете\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Треба да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за да продолжите. По инсталирањето\",\n\t\trefreshThePage: \"Освежете ја страната.\",\n\t\topen: \"Отворете\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано на клипбордот\",\n\t\tfailedToCopy: \"Неуспешно копирање на клипборд\",\n\t\tscanWithYourMobile: \"Скенирајте со вашиот телефонски уред\",\n\t\tcopyToClipboard: \"Копирајте на клипборд\",\n\t\tpreferTheOfficial: \"Преферирајте официјален диалог на\",\n\t\topen: \"Отворете\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\tinjected: \"Екстензија за новчаник\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилен новчаник\",\n\t\t\"instant-link\": \"Инстант паричник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Одберете паричник\",\n\t\ttransferYourAccounts: \"Префрлете ги вашите кориснички сметки\",\n\t\tselectAWallet: \"Изберетен новчаник кој ги задоволува вашите баранња и ги поддржува вашите поврзани кориснички сметки.\",\n\t\tselectYourAccounts: \"Изберете ги вашите кориснички сметки\",\n\t\tafterDecide: \"Одкако ќе изберете новчаник, можете да изберете кои кориснички сметки сакате да ги префрлите.\",\n\t\tdisclaimer: \"Не можете да прфрлате кориснички сметки кои никогаш не биле надополнати или користени на NEAR.\",\n\t\twarning: \"не поддржува извезување на кориснички сметки во овој момент. Ве молиме изберете друг новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник на интернет прелистувач\",\n\t\t\tinjected: \"Екстензија за новчаник\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилен новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изберете ги корисничките сметки за да ги префрлите.\",\n\t\t\tbutton: \"Добијте лозинка\",\n\t\t\tdeselectAll: \"Отселектирајте се\",\n\t\t\tselectAll: \"Изберете се\",\n\t\t\tunavailable: \"Трансферот е недостапен\",\n\t\t\terror: \"Корисничката сметка не постои\",\n\t\t\twarningLedger: \"Потребна е поддршка од Леџер\",\n\t\t\tnoBalance: \"Сметката не е финансирана\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирајте ја привремената лозинка\",\n\t\t\tdesc: \"Ќе треба да ја внесете оваа лозинка кога ќе започнете да ги извезувате вашите сметки на друг новчаник.\",\n\t\t\tbutton: \"Продолжете\",\n\t\t\tlabel: \"Кликнете за да копирате\",\n\t\t\tcheckLabel: \"Ја копирав или запишав лозинката\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Завршете го преносот\",\n\t\t\tdescOne: \"Сега ќе бидете пренасочени на избраниот новчаник за завршување на преносот.\",\n\t\t\tdescTwo: \"Откако ќе заврши увозот од избраниот новчаник, притиснете го копчето за да го завршите преносот.\",\n\t\t\tbutton: \"Завршете\"\n\t\t}\n\t}\n};\nvar mk = {\n\tmodal: modal$2\n};\n\nvar modal$1 = {\n\twallet: {\n\t\tconnectYourWallet: \"Povežite svojo denarnico!\",\n\t\twhatIsAWallet: \"Kaj je denarnica?\",\n\t\tsecureAndManage: \"Zavarujte in upravljajte svoja digitalna sredstva.\",\n\t\tsafelyStore: \"Varno shranjujte in prenašajte svoje kriptovalute in NFTje.\",\n\t\tlogInToAny: \"Prijavite se v katero koli aplikacijo na NEAR\",\n\t\tnoNeedToCreate: \"Ni vam treba ustvarjati novih računov. Povežite svojo denarnico in začnite!\",\n\t\tgetAWallet: \"Ustvarite denarnico\",\n\t\tuseAWallet: \"Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR\",\n\t\tconnectionFailed: \"Povezava ni bila uspešna.\",\n\t\tconnectionSuccessful: \"Povezava je bila uspešna.\",\n\t\tconnected: \"Vaša denarnica je povezana.\",\n\t\tconnectingTo: \"Povezovanje z\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potrdite povezavo v oknu razširitve\",\n\t\t\tbrowser: \"Po preusmeritvi potrdite povezavo v denarnici\",\n\t\t\thardware: \"Potrdite povezavo s hladno denarnico\",\n\t\t\tbridge: \"Potrdite povezavo v denarnici\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Povežite se z Ledger\",\n\t\tmakeSureYourLedger: \"Prepričajte se, da je vaš Ledger varno povezan in da je aplikacija NEAR odprta v vaši napravi\",\n\t\t\"continue\": \"Nadaljuj\",\n\t\tspecifyHDPath: \"Določite HD pot\",\n\t\tenterYourPreferredHDPath: \"Vnesite želeno HD pot, nato poiščite vse aktivne račune.\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Poskusite znova\",\n\t\tledgerIsNotAvailable: \"Ledger ni na voljo\",\n\t\taccessDeniedToUseLedgerDevice: \"Dostop za uporabo naprave Ledger zavrnjen\",\n\t\tnoAccountsFound: \"Ni najdenih računov\",\n\t\tselectYourAccounts: \"Izberite Vaši računi\",\n\t\tconnecting1Account: \"Povezovanje enega računa\",\n\t\tcantFindAnyAccount: \"Ni mogoče najti nobenega računa, povezanega s tem Ledgerjem. Ustvarite nov NEAR račun \",\n\t\torConnectAnAnotherLedger: \"ali povežite drug Ledger..\",\n\t\tconnecting: \"Povezovanje\",\n\t\tofAccounts: \"računov\",\n\t\tfailedToAutomatically: \"ID-ja računa ni bilo mogoče samodejno najti. Zagotovite ga ročno:\",\n\t\toverviewTheListOfAuthorized: \"Oglejte si seznam pooblaščenih računov, dokončajte prijavo s klikom na spodnji gumb.\",\n\t\tfinish: \"Končajte\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Morali ga boste namestiti\",\n\t\ttoContinueAfterInstalling: \"nadaljevati. Po namestitvi\",\n\t\trefreshThePage: \"Osvežite stran.\",\n\t\topen: \"Odprite\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano v podložni mapi\",\n\t\tfailedToCopy: \"Kopiranje v podložni mapi ni uspelo\",\n\t\tscanWithYourMobile: \"Skenirajte s svojo mobilno napravo\",\n\t\tcopyToClipboard: \" Kopirajte v podložni mapi\",\n\t\tpreferTheOfficial: \"Preferirajte uradno pogovorno okno\",\n\t\topen: \"Odprite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hladna denarnica\",\n\t\tbrowser: \"Denarnica brskalnika\",\n\t\tinjected: \"Razširitev za denarnico\",\n\t\tbridge: \"Bridge denarnica\",\n\t\tmobile: \"Mobilna denarnica\",\n\t\t\"instant-link\": \"Takojšnja denarnica\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Izberite denarnico\",\n\t\ttransferYourAccounts: \"Prenesite svoje račune\",\n\t\tselectAWallet: \"Izberite denarnico, ki ustreza vašim potrebam in podpira vaše povezane račune.\",\n\t\tselectYourAccounts: \"Izberite vaši računi\",\n\t\tafterDecide: \"Ko se odločite za denarnico, lahko izberete, katere račune želite prenesti.\",\n\t\tdisclaimer: \"Ne boste mogli prenesti Računov, ki nikoli niso bili financirani ali uporabljeni na NEAR.\",\n\t\twarning: \"trenutno ne podpira izvoza računa. Izberite drugo denarnico\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hladna denarnica\",\n\t\t\tbrowser: \"Denarnica brskalnika\",\n\t\t\tinjected: \"Razširitev za denarnico\",\n\t\t\tbridge: \"Bridge denarnica\",\n\t\t\tmobile: \"Mobilna denarnica\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Izberite računi za prenos.\",\n\t\t\tbutton: \"Pridobite geslo\",\n\t\t\tdeselectAll: \"Prekliči izbiro vseh\",\n\t\t\tselectAll: \"Izberi vse\",\n\t\t\tunavailable: \"Prenos ni na voljo\",\n\t\t\terror: \"Račun ne obstaja\",\n\t\t\twarningLedger: \"Potrebna je podpora za Ledger\",\n\t\t\tnoBalance: \"Račun ni financiran\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj začasno geslo\",\n\t\t\tdesc: \"To geslo boste morali vnesti, ko boste začeli izvažati svoje račune v drugo denarnico.\",\n\t\t\tbutton: \"Nadaljujte\",\n\t\t\tlabel: \"Kliknite za kopiranje\",\n\t\t\tcheckLabel: \"Geslo sem kopiral ali zapisal\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Dokončajte prenos\",\n\t\t\tdescOne: \"Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokončanje prenosa.\",\n\t\t\tdescTwo: \"Ko je uvozni del postopka končan iz izbrane denarnice, pritisnite gumb za dokončanje postopka prenosa.\",\n\t\t\tbutton: \"Končajte\"\n\t\t}\n\t}\n};\nvar sl = {\n\tmodal: modal$1\n};\n\nvar modal = {\n\twallet: {\n\t\tconnectYourWallet: \"Повежите свој новчаник!\",\n\t\twhatIsAWallet: \"Шта је новчаник?\",\n\t\tsecureAndManage: \"Обезбедите и управљајте својом дигиталном имовином.\",\n\t\tsafelyStore: \"Безбедно чувајте и преносите своје криптовалуте и NFT.\",\n\t\tlogInToAny: \"Пријавите се на било коју апликацију NEAR\",\n\t\tnoNeedToCreate: \"Нема потребе да креирате нове налоге или акредитиве. Повежите новчаник и спремни стe!\",\n\t\tgetAWallet: \"Набавите новчаник\",\n\t\tuseAWallet: \"Користите новчаник да обезбедите и управљате својим NEAR средствима и да се пријавите у било коју апликацију NEAR без потребе за корисничким именима и лозинкама.\",\n\t\tconnectionFailed: \"Веза није успостављена.\",\n\t\tconnectionSuccessful: \"Веза је успела.\",\n\t\tconnected: \"Повезан.\",\n\t\tconnectingTo: \"Повезивање на\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Потврдите везу у спољном прозору\",\n\t\t\tbrowser: \"Након преусмеравања, потврдите везу у новчанику\",\n\t\t\thardware: \"Потврдите везу са хладним новчаником\",\n\t\t\tbridge: \"Потврдите везу са новчаником\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Повежите се са Ledger\",\n\t\tmakeSureYourLedger: \"Уверите се да је ваш Ledger безбедно повезан и да је апликација NEAR отворена на вашем уређају\",\n\t\t\"continue\": \"Настави\",\n\t\tspecifyHDPath: \"Наведите ХД путању\",\n\t\tenterYourPreferredHDPath: \"Унесите жељену жељену ХД путању, а затим скенирајте све активне налоге.\",\n\t\tscan: \"Скенирајте\",\n\t\tretry: \"Покушај поново\",\n\t\tledgerIsNotAvailable: \"Ledger није доступан.\",\n\t\taccessDeniedToUseLedgerDevice: \"Приступ је одбијен за коришћење Ledger уређаја\",\n\t\tnoAccountsFound: \"Наlози нису пронађени\",\n\t\tselectYourAccounts: \"Изаберите Ваш наlог\",\n\t\tconnecting1Account: \"Повезати 1 наlог\",\n\t\tcantFindAnyAccount: \"Није могуће пронаћи ниједан наlог повезан са овим Ledger-ом. Направите нови NEAR наlог\",\n\t\torConnectAnAnotherLedger: \"или повежите други Ledger.\",\n\t\tconnecting: \"Повезивање\",\n\t\tofAccounts: \"наlога\",\n\t\tfailedToAutomatically: \"Аутоматско проналажење ID-a наlога није успело. Наведите га ручно:\",\n\t\toverviewTheListOfAuthorized: \"Прегледајте листу овлашћених рачуна, завршите пријаву кликом на дугме испод.\",\n\t\tfinish: \"Заврши\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Мораћете да инсталирате\",\n\t\ttoContinueAfterInstalling: \"за наставак. Након инсталирања\",\n\t\trefreshThePage: \"поново учитати страницу.\",\n\t\topen: \"Отвори\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Копирано у међуспремник\",\n\t\tfailedToCopy: \"Копирање у међуспремник није успело\",\n\t\tscanWithYourMobile: \"Скенирајте помоћу мобилног уређаја\",\n\t\tcopyToClipboard: \" Копирај у међуспремник\",\n\t\tpreferTheOfficial: \"Преферирате званични дијалог од\",\n\t\topen: \"Отвори\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Хардверски новчаник\",\n\t\tbrowser: \"Новчаник претраживача,\",\n\t\tinjected: \"Додатак за новчаник,\",\n\t\tbridge: \"Bridge новчаник\",\n\t\tmobile: \"Мобилни новчаник\",\n\t\t\"instant-link\": \"Инстант новчаник\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Изаберите новчаник\",\n\t\ttransferYourAccounts: \"Пренесите своје налоге\",\n\t\tselectAWallet: \"Изаберите новчаник који одговара вашим потребама и који подржава ваше повезане налоге.\",\n\t\tselectYourAccounts: \"Изаберите ваше налоге\",\n\t\tafterDecide: \"Након што се одлучите за новчаник, можете изабрати које налоге желите да пренесете.\",\n\t\tdisclaimer: \"Нећете моћи да пренесете налоге који никада нису били финансирани или коришћени на  NEAR.\",\n\t\twarning: \"тренутно не подржава извоз налога. Изаберите други новчаник.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Хардверски новчаник\",\n\t\t\tbrowser: \"Новчаник претраживача,\",\n\t\t\tinjected: \"Додатак за новчаник,\",\n\t\t\tbridge: \"Bridge новчаник\",\n\t\t\tmobile: \"Мобилни новчаник\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Изаберите налоге за пренос.\",\n\t\t\tbutton: \"Добијте приступну фразу\",\n\t\t\tdeselectAll: \"Поништите избор\",\n\t\t\tselectAll: \"Изаберите све\",\n\t\t\tunavailable: \"Трансфер није доступан\",\n\t\t\terror: \"Налог не постоји\",\n\t\t\twarningLedger: \"Потребна подршка за Ledger\",\n\t\t\tnoBalance: \"Налог није финансиран\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Копирај привремену лозинку\",\n\t\t\tdesc: \"Мораћете да унесете ову лозинку када почнете да извозите своје налоге у други новчаник.\",\n\t\t\tbutton: \"Наставите\",\n\t\t\tlabel: \"Кликните да бисте копирали\",\n\t\t\tcheckLabel: \"Копирао сам или записао лозинку\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Довршите трансфер\",\n\t\t\tdescOne: \"Сада ћете бити преусмерени на новчаник који сте изабрали да завршите трансфер.\",\n\t\t\tdescTwo: \"Када се део процеса увоза заврши из изабраног новчаника, притисните дугме да завршите процес преноса.\",\n\t\t\tbutton: \"Завршите\"\n\t\t}\n\t}\n};\nvar sr = {\n\tmodal: modal\n};\n\nconst getLanguage = languageCode => {\n  switch (languageCode) {\n    case \"en\":\n      return en;\n    case \"es\":\n      return es;\n    case \"zh\":\n      return zh;\n    case \"bg\":\n      return bg;\n    case \"ko\":\n      return ko;\n    case \"vi\":\n      return vi;\n    case \"hi\":\n      return hi;\n    case \"ar\":\n      return ar;\n    case \"hr\":\n      return hr;\n    case \"mk\":\n      return mk;\n    case \"sl\":\n      return sl;\n    case \"sr\":\n      return sr;\n    default:\n      return en;\n  }\n};\nlet chosenLang;\nconst allowOnlyLanguage = langCode => {\n  chosenLang = langCode;\n};\n// (i.e en-CA returns just en)\nconst shortenLanguageCode = lang => {\n  return lang.indexOf(\"-\") !== -1 ? lang.split(\"-\")[0] : lang.split(\"_\")[0];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst findObjectPropByStringPath = (obj, prop) => {\n  if (!obj) {\n    return \"\";\n  }\n  const _index = prop.indexOf(\".\");\n  if (_index > -1) {\n    const currentProp = prop.substring(0, _index);\n    const nextProp = prop.substring(_index + 1);\n    return findObjectPropByStringPath(obj[currentProp], nextProp);\n  }\n  return obj[prop];\n};\nconst translate = path => {\n  let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n  browserLang = browserLang || window.navigator.language;\n  const languageCode = shortenLanguageCode(chosenLang || browserLang);\n  const selectedLanguage = getLanguage(languageCode);\n  const text = findObjectPropByStringPath(selectedLanguage, path);\n  return text && typeof text === \"string\" ? text : path;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDUTtBQUNTO0FBQ0Y7QUFDcEI7QUFDQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrREFBaUI7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYzs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsTUFBTTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBLHVCQUF1QixhQUFhLGdCQUFnQixhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sa0ZBQWtGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDRFQUE0RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHFFQUFxRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSxrRUFBa0UsMkRBQTJEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQsTUFBTSxxQkFBcUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxvRkFBb0Y7QUFDckc7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxlQUFlO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3RELEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sdUVBQXVFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTSw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsS0FBSyxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RCxtQkFBbUIsMENBQTBDO0FBQzdELENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwRUFBMEU7QUFDaEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtFQUFrRSxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IsS0FBSyxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLCtDQUErQztBQUMvQztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULDZDQUE2QztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBZTtBQUNwQyx1QkFBdUIseUNBQU87QUFDOUIsZ0JBQWdCLDBDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG9FQUFvRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDREQUE0RDtBQUNsRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbzdCQUFvN0IsNENBQTRDLHlKQUF5Siw2REFBNkQ7QUFDdHJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELG1CQUFtQix5Q0FBeUM7QUFDNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJLGNBQWM7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSwyRUFBMkU7QUFDakY7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUM7O0FBRUQsNkJBQTZCOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0VBQWtFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUMsVUFBVTtBQUNWLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGtFQUFrRTtBQUN4RTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsbUZBQW1GOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLG1EQUFtRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3BFO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSw4Q0FBOEM7QUFDOUMscUJBQXFCLGdEQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixnREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQU07QUFDOUM7QUFDQTtBQUNBLGFBQWEsOENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLGtEQUFTO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRiYXNlbWludC8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3IvY29yZS9pbmRleC5qcz9kY2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG5lYXJBUEkgZnJvbSAnbmVhci1hcGktanMnO1xuaW1wb3J0IHsgdXRpbHMsIHByb3ZpZGVycyB9IGZyb20gJ25lYXItYXBpLWpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXIkMSB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YmplY3QsIHNjYW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHNlcmlhbGl6ZSB9IGZyb20gJ2JvcnNoJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ2pzLXNoYTI1Nic7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmNsYXNzIFByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBuZWFyQVBJLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIoe1xuICAgICAgdXJsXG4gICAgfSk7XG4gIH1cbiAgcXVlcnkocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucXVlcnkocGFyYW1zKTtcbiAgfVxuICB2aWV3QWNjZXNzS2V5KHtcbiAgICBhY2NvdW50SWQsXG4gICAgcHVibGljS2V5XG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeSh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwidmlld19hY2Nlc3Nfa2V5XCIsXG4gICAgICBmaW5hbGl0eTogXCJmaW5hbFwiLFxuICAgICAgYWNjb3VudF9pZDogYWNjb3VudElkLFxuICAgICAgcHVibGljX2tleTogcHVibGljS2V5XG4gICAgfSk7XG4gIH1cbiAgYmxvY2socmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuYmxvY2socmVmZXJlbmNlKTtcbiAgfVxuICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbmNvbnN0IEtFWV9ERUxJTUlURVIgPSBcIjpcIjtcbmNsYXNzIEpzb25TdG9yYWdlIHtcbiAgY29uc3RydWN0b3Ioc3RvcmFnZSwgbmFtZXNwYWNlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IEFycmF5LmlzQXJyYXkobmFtZXNwYWNlKSA/IG5hbWVzcGFjZS5qb2luKEtFWV9ERUxJTUlURVIpIDogbmFtZXNwYWNlO1xuICB9XG4gIHJlc29sdmVLZXkoa2V5KSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWVzcGFjZSwga2V5XS5qb2luKEtFWV9ERUxJTUlURVIpO1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMucmVzb2x2ZUtleShrZXkpKS50aGVuKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShpdGVtKSA6IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMucmVzb2x2ZUtleShrZXkpLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMucmVzb2x2ZUtleShrZXkpKTtcbiAgfVxufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCR0ID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIGZhaWxzJHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJHIgPSBmYWlscyRzO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJHIoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgZmFpbHMkcSA9IGZhaWxzJHM7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkcShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGNhbGwkbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG52YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMyA/IGNhbGwkbC5iaW5kKGNhbGwkbCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGwuYXBwbHkoY2FsbCRsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQkNyA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZDtcbnZhciBjYWxsJGsgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkcCA9IE5BVElWRV9CSU5EJDIgJiYgYmluZCQ3LmJpbmQoY2FsbCRrLCBjYWxsJGspO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDIgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJHAoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGsuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQ3ID0gdW5jdXJyeVRoaXMkbyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UkMyA9IHVuY3VycnlUaGlzJG8oJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSQzKHRvU3RyaW5nJDcoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkcCA9IGZhaWxzJHM7XG52YXIgY2xhc3NvZiRiID0gY2xhc3NvZlJhdyQxO1xuXG52YXIgJE9iamVjdCQ0ID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkbignJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJHAoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkYihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQ0KGl0KTtcbn0gOiAkT2JqZWN0JDQ7XG5cbnZhciAkVHlwZUVycm9yJGYgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyAkVHlwZUVycm9yJGYoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0JDMgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0JDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1KGl0KSk7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJG4gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzQ2FsbGFibGUkbSA9IGlzQ2FsbGFibGUkbjtcblxudmFyIGlzT2JqZWN0JGQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRtKGl0KTtcbn07XG5cbnZhciBnbG9iYWwkcyA9IGdsb2JhbCR0O1xudmFyIGlzQ2FsbGFibGUkbCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRsKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4kOCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsJHNbbmFtZXNwYWNlXSkgOiBnbG9iYWwkc1tuYW1lc3BhY2VdICYmIGdsb2JhbCRzW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRtID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyRtKHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ3KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkciA9IGdsb2JhbCR0O1xudmFyIHVzZXJBZ2VudCQ1ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyQzID0gZ2xvYmFsJHIucHJvY2VzcztcbnZhciBEZW5vJDEgPSBnbG9iYWwkci5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucyB8fCBEZW5vJDEgJiYgRGVubyQxLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQ1KSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRvID0gZmFpbHMkcztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQxICYmIFY4X1ZFUlNJT04kMSA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJGsgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNQcm90b3R5cGVPZiQ0ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQzID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kNignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJGsoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiQ0KCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDMoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDMgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQ1ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckMyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRuO1xudmFyIHRyeVRvU3RyaW5nJDQgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciRlID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDYWxsYWJsZSQ5ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJGooYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkZSh0cnlUb1N0cmluZyQ0KGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUkOCA9IGFDYWxsYWJsZSQ5O1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDQgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUkOChmdW5jKTtcbn07XG5cbnZhciBjYWxsJGogPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNDYWxsYWJsZSRpID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JGMgPSBpc09iamVjdCRkO1xuXG52YXIgJFR5cGVFcnJvciRkID0gVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGModmFsID0gY2FsbCRqKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0JGModmFsID0gY2FsbCRqKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvciRkKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIHNoYXJlZCQ0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCRxID0gZ2xvYmFsJHQ7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JDcoZ2xvYmFsJHEsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJHFba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkcCA9IGdsb2JhbCR0O1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDIgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUkMyA9IGdsb2JhbCRwW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkkMihTSEFSRUQsIHt9KTtcblxudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcblxuKHNoYXJlZCQ0LmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjIzLjMnLFxuICBtb2RlOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjMuMy9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNCA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcblxudmFyICRPYmplY3QkMiA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3RcbnZhciB0b09iamVjdCQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0JDIocmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0KGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkNiA9IHRvT2JqZWN0JDc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJGwoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDYoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGsgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDYgPSB1bmN1cnJ5VGhpcyRrKDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQ2KCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJG8gPSBnbG9iYWwkdDtcbnZhciBzaGFyZWQkMyA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgaGFzT3duJGIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQyID0gdWlkJDM7XG52YXIgTkFUSVZFX1NZTUJPTCA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDMoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJG8uU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMjtcblxudmFyIHdlbGxLbm93blN5bWJvbCRqID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kYihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJGIoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cbnZhciBjYWxsJGkgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkYiA9IGlzT2JqZWN0JGQ7XG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sJDM7XG52YXIgZ2V0TWV0aG9kJDMgPSBnZXRNZXRob2QkNDtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRpID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciAkVHlwZUVycm9yJGMgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGkoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMiA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JGIoaW5wdXQpIHx8IGlzU3ltYm9sJDIoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMyhpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRpKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkYihyZXN1bHQpIHx8IGlzU3ltYm9sJDIocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJGMoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUkMSA9IHRvUHJpbWl0aXZlJDI7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDM7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUkMShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2wkMShrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJG4gPSBnbG9iYWwkdDtcbnZhciBpc09iamVjdCRhID0gaXNPYmplY3QkZDtcblxudmFyIGRvY3VtZW50JDMgPSBnbG9iYWwkbi5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkYShkb2N1bWVudCQzKSAmJiBpc09iamVjdCRhKGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkZCA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJG4gPSBmYWlscyRzO1xudmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkZCAmJiAhZmFpbHMkbihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQkMSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIERFU0NSSVBUT1JTJGMgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJGggPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0ID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciB0b1Byb3BlcnR5S2V5JDMgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgaGFzT3duJGEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FJDEgPSBpZThEb21EZWZpbmU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyRjID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQ1KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQzKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24kYShPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0KCFjYWxsJGgocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJGIgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRtID0gZmFpbHMkcztcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyRiICYmIGZhaWxzJG0oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcblxudmFyIGlzT2JqZWN0JDkgPSBpc09iamVjdCRkO1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDkoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkYigkU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRkID0gYW5PYmplY3QkZTtcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDQ7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyRhID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkZChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkZChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkZChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkZChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciRhKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDYgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDggPSBERVNDUklQVE9SUyQ5ID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkNi5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDggJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ5KEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDggfHwgKERFU0NSSVBUT1JTJDggJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSRoID0gaXNDYWxsYWJsZSRuO1xudmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyRqKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJGgoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbnZhciBpbnNwZWN0U291cmNlJDQgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbnZhciBnbG9iYWwkbSA9IGdsb2JhbCR0O1xudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkbjtcbnZhciBpbnNwZWN0U291cmNlJDMgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkbS5XZWFrTWFwO1xuXG52YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkZyhXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlJDMoV2Vha01hcCQxKSk7XG5cbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgdWlkJDEgPSB1aWQkMztcblxudmFyIGtleXMkMSA9IHNoYXJlZCQyKCdrZXlzJyk7XG5cbnZhciBzaGFyZWRLZXkkMyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXMkMVtrZXldIHx8IChrZXlzJDFba2V5XSA9IHVpZCQxKGtleSkpO1xufTtcblxudmFyIGhpZGRlbktleXMkNCA9IHt9O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkbCA9IGdsb2JhbCR0O1xudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JDggPSBpc09iamVjdCRkO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ3ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCQxID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkMztcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJDMgPSBnbG9iYWwkbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCRsLldlYWtNYXA7XG52YXIgc2V0JDIsIGdldCQxLCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0JDEoaXQpIDogc2V0JDIoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkOChpdCkgfHwgKHN0YXRlID0gZ2V0JDEoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkMygnSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkJDEuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkJDEuc3RhdGUgfHwgKHNoYXJlZCQxLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzJGkoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMkaShzdG9yZS5oYXMpO1xuICB2YXIgd21zZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLnNldCk7XG4gIHNldCQyID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDMoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0KHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMignc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQzW1NUQVRFXSA9IHRydWU7XG4gIHNldCQyID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kOChpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDMoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ3KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDIsXG4gIGdldDogZ2V0JDEsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxudmFyIGZhaWxzJGwgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDIgPSBmdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGluc3BlY3RTb3VyY2UkMiA9IGluc3BlY3RTb3VyY2UkNDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDUgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkNSA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkNyAmJiAhZmFpbHMkbChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQ2KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ3KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQyICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDcpIGRlZmluZVByb3BlcnR5JDYodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kNyhvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ2KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ3KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQ3KSBkZWZpbmVQcm9wZXJ0eSQ2KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUkMih2YWx1ZSk7XG4gIGlmICghaGFzT3duJDcoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGYodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQ1KHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDggPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkZSh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDUuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yJDMgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IkMyA6IGNlaWwpKG4pO1xufTtcblxudmFyIHRydW5jID0gbWF0aFRydW5jO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDYgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyIG1heCQxID0gTWF0aC5tYXg7XG52YXIgbWluJDIgPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxudmFyIHRvQWJzb2x1dGVJbmRleCQ0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDUoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgkMShpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQyKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xuXG52YXIgbWluJDEgPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQ2ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4kMSh0b0ludGVnZXJPckluZmluaXR5JDQoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCQ1ID0gdG9MZW5ndGgkNjtcblxuLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ4ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgkNShvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIHRvQWJzb2x1dGVJbmRleCQzID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNyA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDQgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDQoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ3KE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQzKGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QkNCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QkNChmYWxzZSlcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciBpbmRleE9mJDEgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyQyID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgcHVzaCQyID0gdW5jdXJyeVRoaXMkaChbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDMob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kNihoaWRkZW5LZXlzJDIsIGtleSkgJiYgaGFzT3duJDYoTywga2V5KSAmJiBwdXNoJDIocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJDYoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZiQxKHJlc3VsdCwga2V5KSB8fCBwdXNoJDIocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xuXG52YXIgaGlkZGVuS2V5cyQxID0gZW51bUJ1Z0tleXMkMi5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgaGlkZGVuS2V5cyQxKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBnZXRCdWlsdEluJDUgPSBnZXRCdWlsdEluJDg7XG52YXIgdW5jdXJyeVRoaXMkZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkYyA9IGFuT2JqZWN0JGU7XG5cbnZhciBjb25jYXQkMSA9IHVuY3VycnlUaGlzJGcoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIG93bktleXMkMSA9IGdldEJ1aWx0SW4kNSgnUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdCRjKGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0JDEoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBvd25LZXlzID0gb3duS2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDQgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkNC5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kNSh0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQ1KGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkayA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSRkID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMiA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSRkKGRldGVjdGlvbikgPyBmYWlscyRrKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDIubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQyLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQyLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDIuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMjtcblxudmFyIGdsb2JhbCRrID0gZ2xvYmFsJHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGRlZmluZUJ1aWx0SW4kNyA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMTtcbnZhciBpc0ZvcmNlZCQxID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCRrO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCRrW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCRrW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQkMShHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4kNyh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgY2xhc3NvZiRhID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCRqID0gZ2xvYmFsJHQ7XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJGEoZ2xvYmFsJGoucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkOSA9IFR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSRjKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDkoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nJDEoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuXG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGU7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJGYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JGIoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyIGRlZmluZVByb3BlcnR5JDUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQ0ID0gd2VsbEtub3duU3ltYm9sJGgoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyQ0ID0gZnVuY3Rpb24gKHRhcmdldCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xuICBpZiAodGFyZ2V0ICYmICFoYXNPd24kNCh0YXJnZXQsIFRPX1NUUklOR19UQUckNCkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ1KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQ0LCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kODtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgd2VsbEtub3duU3ltYm9sJGcgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG5cbnZhciBTUEVDSUVTJDQgPSB3ZWxsS25vd25TeW1ib2wkZygnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQyID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQ0KENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTJDYgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVMkNF0pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUyQ0LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGlzUHJvdG90eXBlT2YkMyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG5cbnZhciAkVHlwZUVycm9yJDggPSBUeXBlRXJyb3I7XG5cbnZhciBhbkluc3RhbmNlJDMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZiQzKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93ICRUeXBlRXJyb3IkOCgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZiA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGYoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUckM10gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJG47XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGUoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkOSA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0JDEoaXQpLCBUT19TVFJJTkdfVEFHJDIpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkYihPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRqID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJG47XG52YXIgY2xhc3NvZiQ4ID0gY2xhc3NvZiQ5O1xudmFyIGdldEJ1aWx0SW4kMyA9IGdldEJ1aWx0SW4kODtcbnZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbiQzKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjJDIgPSB1bmN1cnJ5VGhpcyRlKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSRhKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSRhKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YkOChhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMkMihjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMiA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkaihmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yJDEgPSBpc0NvbnN0cnVjdG9yJDI7XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDU7XG5cbnZhciAkVHlwZUVycm9yJDcgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNvbnN0cnVjdG9yJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3IkMShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ3KHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRlO1xudmFyIGFDb25zdHJ1Y3RvciQxID0gYUNvbnN0cnVjdG9yJDI7XG52YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCRkKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCRhKE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JGEoQylbU1BFQ0lFUyQzXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yJDEoUyk7XG59O1xuXG52YXIgTkFUSVZFX0JJTkQkMSA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5JDMgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBjYWxsJGcgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1yZWZsZWN0IC0tIHNhZmVcbnZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkMSA/IGNhbGwkZy5iaW5kKGFwcGx5JDMpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRnLmFwcGx5KGFwcGx5JDMsIGFyZ3VtZW50cyk7XG59KTtcblxudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ3ID0gYUNhbGxhYmxlJDk7XG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBiaW5kJDYgPSB1bmN1cnJ5VGhpcyRkKHVuY3VycnlUaGlzJGQuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlJDcoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQkNihmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kODtcblxudmFyIGh0bWwkMiA9IGdldEJ1aWx0SW4kMignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGFycmF5U2xpY2UkNSA9IHVuY3VycnlUaGlzJGMoW10uc2xpY2UpO1xuXG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMSA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgJFR5cGVFcnJvciQ2KCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxudmFyIHVzZXJBZ2VudCQ0ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJb3MgPSAvKD86aXBhZHxpcGhvbmV8aXBvZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQkNCk7XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCR0O1xudmFyIGFwcGx5JDIgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkNSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRuO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyRpID0gZmFpbHMkcztcbnZhciBodG1sJDEgPSBodG1sJDI7XG52YXIgYXJyYXlTbGljZSQ0ID0gYXJyYXlTbGljZSQ1O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDE7XG52YXIgSVNfSU9TJDEgPSBlbmdpbmVJc0lvcztcbnZhciBJU19OT0RFJDMgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBzZXQkMSA9IGdsb2JhbCRpLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbCRpLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbCRpLnByb2Nlc3M7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwkaS5EaXNwYXRjaDtcbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJGkuRnVuY3Rpb247XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwkaS5NZXNzYWdlQ2hhbm5lbDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCRpLlN0cmluZztcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSQxID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG50cnkge1xuICAvLyBEZW5vIHRocm93cyBhIFJlZmVyZW5jZUVycm9yIG9uIGBsb2NhdGlvbmAgYWNjZXNzIHdpdGhvdXQgYC0tbG9jYXRpb25gIGZsYWdcbiAgbG9jYXRpb24gPSBnbG9iYWwkaS5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duJDMocXVldWUkMSwgaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWUkMVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwkaS5wb3N0TWVzc2FnZShTdHJpbmckMShpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQkMSB8fCAhY2xlYXIpIHtcbiAgc2V0JDEgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoaGFuZGxlcikge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkOShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgIHZhciBhcmdzID0gYXJyYXlTbGljZSQ0KGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkkMihmbiwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKElTX05PREUkMykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzJDIubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUyQxKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBiaW5kJDUocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbCRpLmFkZEV2ZW50TGlzdGVuZXIgJiZcbiAgICBpc0NhbGxhYmxlJDkoZ2xvYmFsJGkucG9zdE1lc3NhZ2UpICYmXG4gICAgIWdsb2JhbCRpLmltcG9ydFNjcmlwdHMgJiZcbiAgICBsb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgICFmYWlscyRpKHBvc3QpXG4gICkge1xuICAgIGRlZmVyID0gcG9zdDtcbiAgICBnbG9iYWwkaS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sJDEuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwkMS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciB0YXNrJDEgPSB7XG4gIHNldDogc2V0JDEsXG4gIGNsZWFyOiBjbGVhclxufTtcblxudmFyIHVzZXJBZ2VudCQzID0gZW5naW5lVXNlckFnZW50O1xudmFyIGdsb2JhbCRoID0gZ2xvYmFsJHQ7XG5cbnZhciBlbmdpbmVJc0lvc1BlYmJsZSA9IC9pcGFkfGlwaG9uZXxpcG9kL2kudGVzdCh1c2VyQWdlbnQkMykgJiYgZ2xvYmFsJGguUGViYmxlICE9PSB1bmRlZmluZWQ7XG5cbnZhciB1c2VyQWdlbnQkMiA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzV2Vib3NXZWJraXQgPSAvd2ViMHMoPyEuKmNocm9tZSkvaS50ZXN0KHVzZXJBZ2VudCQyKTtcblxudmFyIGdsb2JhbCRnID0gZ2xvYmFsJHQ7XG52YXIgYmluZCQ0ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMiA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkZy5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCRnLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCRnLmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCRnLnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJGcuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJGcsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQyICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQyICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQ0KHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDIpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQ0KG1hY3JvdGFzaywgZ2xvYmFsJGcpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJGYgPSBnbG9iYWwkdDtcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJGYuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCRlID0gZ2xvYmFsJHQ7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkZS5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCRkID0gZ2xvYmFsJHQ7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sJGMoJ3NwZWNpZXMnKTtcbnZhciBTVUJDTEFTU0lORyA9IGZhbHNlO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxID0gaXNDYWxsYWJsZSQ4KGdsb2JhbCRkLlByb21pc2VSZWplY3Rpb25FdmVudCk7XG5cbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1ID0gaXNGb3JjZWQoJ1Byb21pc2UnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSA9IGluc3BlY3RTb3VyY2UoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICB2YXIgR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSA9IFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFICE9PSBTdHJpbmcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAvLyBXZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAvLyBXZSBjYW4ndCB1c2UgQEBzcGVjaWVzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxuICBpZiAoVjhfVkVSU0lPTiA+PSA1MSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gbmV3IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUoMSk7IH0pO1xuICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICB9O1xuICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gIGNvbnN0cnVjdG9yW1NQRUNJRVMkMl0gPSBGYWtlUHJvbWlzZTtcbiAgU1VCQ0xBU1NJTkcgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICBpZiAoIVNVQkNMQVNTSU5HKSByZXR1cm4gdHJ1ZTtcbiAgLy8gVW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICByZXR1cm4gIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgSVNfQlJPV1NFUiAmJiAhTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDE7XG59KTtcblxudmFyIHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHtcbiAgQ09OU1RSVUNUT1I6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUsXG4gIFJFSkVDVElPTl9FVkVOVDogTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEsXG4gIFNVQkNMQVNTSU5HOiBTVUJDTEFTU0lOR1xufTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDIgPSB7fTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDk7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUkNihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhQ2FsbGFibGUkNihyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm5ld1Byb21pc2VDYXBhYmlsaXR5JDIuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgJCRlID0gX2V4cG9ydDtcbnZhciBJU19OT0RFJDEgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkdDtcbnZhciBjYWxsJGYgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQ2ID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHNldFByb3RvdHlwZU9mJDUgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQzID0gc2V0VG9TdHJpbmdUYWckNDtcbnZhciBzZXRTcGVjaWVzJDEgPSBzZXRTcGVjaWVzJDI7XG52YXIgYUNhbGxhYmxlJDUgPSBhQ2FsbGFibGUkOTtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkNyA9IGlzT2JqZWN0JGQ7XG52YXIgYW5JbnN0YW5jZSQyID0gYW5JbnN0YW5jZSQzO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciQyID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG52YXIgdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgbWljcm90YXNrID0gbWljcm90YXNrJDE7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IGhvc3RSZXBvcnRFcnJvcnMkMTtcbnZhciBwZXJmb3JtJDIgPSBwZXJmb3JtJDM7XG52YXIgUXVldWUgPSBxdWV1ZTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDQgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGMuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkYy5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJGMucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkYy5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkNyhpdCkgJiYgaXNDYWxsYWJsZSQ3KHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQyKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkZih0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkY1snb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJGYodGFzaywgZ2xvYmFsJGMsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUkMSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFJDEgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJGYodGFzaywgZ2xvYmFsJGMsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICBpZiAoSVNfTk9ERSQxKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDMgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDIoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJGYodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDMoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDMoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSQyKHRoaXMsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIGFDYWxsYWJsZSQ1KGV4ZWN1dG9yKTtcbiAgICBjYWxsJGYoSW50ZXJuYWwsIHRoaXMpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kJDMoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSksIGJpbmQkMyhpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMsIHtcbiAgICAgIHR5cGU6IFBST01JU0UsXG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgICAgIHBhcmVudDogZmFsc2UsXG4gICAgICByZWFjdGlvbnM6IG5ldyBRdWV1ZSgpLFxuICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgICAgIHN0YXRlOiBQRU5ESU5HLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gIEludGVybmFsLnByb3RvdHlwZSA9IGRlZmluZUJ1aWx0SW4kNihQcm9taXNlUHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKHNwZWNpZXNDb25zdHJ1Y3RvciQyKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlJDcob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgIHJlYWN0aW9uLmZhaWwgPSBpc0NhbGxhYmxlJDcob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFJDEgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuc3RhdGUgPT0gUEVORElORykgc3RhdGUucmVhY3Rpb25zLmFkZChyZWFjdGlvbik7XG4gICAgZWxzZSBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gIH0pO1xuXG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kJDMoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7XG4gICAgdGhpcy5yZWplY3QgPSBiaW5kJDMoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTtcbiAgfTtcblxuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgaWYgKGlzQ2FsbGFibGUkNyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMikgJiYgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgbmF0aXZlVGhlbiA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS50aGVuO1xuXG4gICAgaWYgKCFOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORykge1xuICAgICAgLy8gbWFrZSBgUHJvbWlzZSN0aGVuYCByZXR1cm4gYSBwb2x5ZmlsbGVkIGBQcm9taXNlYCBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgICAgZGVmaW5lQnVpbHRJbiQ2KE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNhbGwkZihuYXRpdmVUaGVuLCB0aGF0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICAgIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8vIG1ha2UgYC5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLmNvbnN0cnVjdG9yO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuICAgIC8vIG1ha2UgYGluc3RhbmNlb2YgUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIGlmIChzZXRQcm90b3R5cGVPZiQ1KSB7XG4gICAgICBzZXRQcm90b3R5cGVPZiQ1KE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbiQkZSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnJDMoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSk7XG5zZXRTcGVjaWVzJDEoUFJPTUlTRSk7XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRiID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sJGIoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMkNC5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGUkMVtJVEVSQVRPUiQ1XSA9PT0gaXQpO1xufTtcblxudmFyIGNsYXNzb2YkNyA9IGNsYXNzb2YkOTtcbnZhciBnZXRNZXRob2QkMiA9IGdldE1ldGhvZCQ0O1xudmFyIEl0ZXJhdG9ycyQzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJGEoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QkMihpdCwgSVRFUkFUT1IkNClcbiAgICB8fCBnZXRNZXRob2QkMihpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9ycyQzW2NsYXNzb2YkNyhpdCldO1xufTtcblxudmFyIGNhbGwkZSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkNCA9IGFDYWxsYWJsZSQ5O1xudmFyIGFuT2JqZWN0JDkgPSBhbk9iamVjdCRlO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xuXG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG52YXIgZ2V0SXRlcmF0b3IkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDIoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZSQ0KGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDkoY2FsbCRlKGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyAkVHlwZUVycm9yJDUodHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGNhbGwkZCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ4ID0gYW5PYmplY3QkZTtcbnZhciBnZXRNZXRob2QkMSA9IGdldE1ldGhvZCQ0O1xuXG52YXIgaXRlcmF0b3JDbG9zZSQxID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0JDgoaXRlcmF0b3IpO1xuICB0cnkge1xuICAgIGlubmVyUmVzdWx0ID0gZ2V0TWV0aG9kJDEoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCRkKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkOChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBiaW5kJDIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkYyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkZTtcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDYgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGlzUHJvdG90eXBlT2YkMiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IkMSA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG52YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMTtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kJDIodW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCQ3KHZhbHVlKTtcbiAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgIH0gcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICB9O1xuXG4gIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QkMShpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IkNCh0cnlUb1N0cmluZyQxKGl0ZXJhYmxlKSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDYoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDIoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMShpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbCRjKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkMihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJDkoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDNdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDIgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMjtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQzID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xuXG52YXIgcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb24gPSBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQzIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMShmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEuYWxsKGl0ZXJhYmxlKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgJCRkID0gX2V4cG9ydDtcbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkOTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtJDEgPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UuYWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiQkZCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0kMShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDMoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZSQxKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBjYWxsJGIoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCRjID0gX2V4cG9ydDtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRuO1xudmFyIGRlZmluZUJ1aWx0SW4kNSA9IGRlZmluZUJ1aWx0SW4kODtcblxudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiQkYyh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoaXNDYWxsYWJsZSQ2KE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvcikpIHtcbiAgdmFyIG1ldGhvZCA9IGdldEJ1aWx0SW4kMSgnUHJvbWlzZScpLnByb3RvdHlwZVsnY2F0Y2gnXTtcbiAgaWYgKE5hdGl2ZVByb21pc2VQcm90b3R5cGVbJ2NhdGNoJ10gIT09IG1ldGhvZCkge1xuICAgIGRlZmluZUJ1aWx0SW4kNShOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAnY2F0Y2gnLCBtZXRob2QsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICB9XG59XG5cbnZhciAkJGIgPSBfZXhwb3J0O1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ5O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJGIoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMihDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgY2FsbCRhKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkYSA9IF9leHBvcnQ7XG52YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuJCRhKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSB9LCB7XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYodGhpcyk7XG4gICAgY2FsbCQ5KGNhcGFiaWxpdHkucmVqZWN0LCB1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGU7XG52YXIgaXNPYmplY3QkNiA9IGlzT2JqZWN0JGQ7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xuXG52YXIgcHJvbWlzZVJlc29sdmUkMSA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0JDYoQyk7XG4gIGlmIChpc09iamVjdCQ2KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyICQkOSA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kODtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZXNvbHZlJDE7XG5cbmdldEJ1aWx0SW4oJ1Byb21pc2UnKTtcblxuLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuJCQ5KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgfSwge1xuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUodGhpcywgeCk7XG4gIH1cbn0pO1xuXG5jbGFzcyBXZWJTdG9yYWdlU2VydmljZSB7XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQyID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMkMSk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRlO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQyO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxub2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkNSAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCQ1KE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkMihQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDEoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cblxudmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRlO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ0O1xudmFyIGh0bWwgPSBodG1sJDI7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQzO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFJDEgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFJDFdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPJDFdID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBhbk9iamVjdCQ0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIGNyZWF0ZSQzID0gb2JqZWN0Q3JlYXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDQgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2wkOCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eSQ0KEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlJDMobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBhZGRUb1Vuc2NvcGFibGVzJDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbnZhciBmYWlscyRoID0gZmFpbHMkcztcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkaChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJG47XG52YXIgdG9PYmplY3QkNSA9IHRvT2JqZWN0JDc7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDM7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlJDIgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkNShPKTtcbiAgaWYgKGhhc093biQyKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSQ1KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUkMiA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkZyA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRuO1xudmFyIGdldFByb3RvdHlwZU9mJDMgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SJDIgPSB3ZWxsS25vd25TeW1ib2wkNygnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQzKGdldFByb3RvdHlwZU9mJDMoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyRnKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDJdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDQoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQyXSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlJDIgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBzZXRUb1N0cmluZ1RhZyQyID0gc2V0VG9TdHJpbmdUYWckNDtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcblxudmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQyKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyQyKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcbiAgSXRlcmF0b3JzJDJbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxudmFyICQkOCA9IF9leHBvcnQ7XG52YXIgY2FsbCQ4ID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSQxID0gZnVuY3Rpb25OYW1lO1xudmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkbjtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxO1xudmFyIGdldFByb3RvdHlwZU9mJDIgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQ0ID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDMgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgd2VsbEtub3duU3ltYm9sJDYgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJdGVyYXRvcnMkMSA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDIgPSBGdW5jdGlvbk5hbWUkMS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IEZ1bmN0aW9uTmFtZSQxLkNPTkZJR1VSQUJMRTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiQxID0gd2VsbEtub3duU3ltYm9sJDYoJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBkZWZpbmVJdGVyYXRvciQxID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDFdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkMihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKGdldFByb3RvdHlwZU9mJDIoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mJDQpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZiQ0KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SJDFdKSkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4kMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDEsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMiAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUoSXRlcmFibGVQcm90b3R5cGUsICduYW1lJywgVkFMVUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIGNhbGwkOChuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkJDgoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmIChJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQxLCBkZWZhdWx0SXRlcmF0b3IsIHsgbmFtZTogREVGQVVMVCB9KTtcbiAgfVxuICBJdGVyYXRvcnMkMVtOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGFkZFRvVW5zY29wYWJsZXMkMjtcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQzID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDE7XG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQ0ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxudmFyIGVzX2FycmF5X2l0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDIodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0JDEoaXRlcmF0ZWQpLCAvLyB0YXJnZXRcbiAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgfSk7XG4vLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDQodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcbnZhciB2YWx1ZXMgPSBJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMkMSgndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKERFU0NSSVBUT1JTJDQgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSQzKHZhbHVlcywgJ25hbWUnLCB7IHZhbHVlOiAndmFsdWVzJyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuLy8gaW4gb2xkIFdlYktpdCB2ZXJzaW9ucywgYGVsZW1lbnQuY2xhc3NMaXN0YCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgZ2xvYmFsIGBET01Ub2tlbkxpc3RgXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbnZhciBjbGFzc0xpc3QgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NwYW4nKS5jbGFzc0xpc3Q7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBkb21Ub2tlbkxpc3RQcm90b3R5cGUgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IERPTVRva2VuTGlzdFByb3RvdHlwZSQxO1xuXG52YXIgZ2xvYmFsJGIgPSBnbG9iYWwkdDtcbnZhciBET01JdGVyYWJsZXMgPSBkb21JdGVyYWJsZXM7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gZG9tVG9rZW5MaXN0UHJvdG90eXBlO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gZXNfYXJyYXlfaXRlcmF0b3I7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2wkNSgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkNSgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUckMV0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUckMSwgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbCRiW0NPTExFQ1RJT05fTkFNRV0gJiYgZ2xvYmFsJGJbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSk7XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcblxuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IobmFtZXNwYWNlKSB7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIH1cbiAgZW1pdChtZXRob2QsIC4uLnBhcmFtcykge1xuICAgIGlmICghTG9nZ2VyLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5hbWVzcGFjZSAmJiBtZXRob2QgIT09IFwiZXJyb3JcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGVbbWV0aG9kXSh0aGlzLm5hbWVzcGFjZSwgLi4ucGFyYW1zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlW21ldGhvZF0oLi4ucGFyYW1zKTtcbiAgfVxuICBsb2coLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwibG9nXCIsIC4uLnBhcmFtcyk7XG4gIH1cbiAgaW5mbyguLi5wYXJhbXMpIHtcbiAgICB0aGlzLmVtaXQoXCJpbmZvXCIsIC4uLnBhcmFtcyk7XG4gIH1cbiAgd2FybiguLi5wYXJhbXMpIHtcbiAgICB0aGlzLmVtaXQoXCJ3YXJuXCIsIC4uLnBhcmFtcyk7XG4gIH1cbiAgZXJyb3IoLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgLi4ucGFyYW1zKTtcbiAgfVxufVxuTG9nZ2VyLmRlYnVnID0gZmFsc2U7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyICRpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMuaW5jbHVkZXM7XG52YXIgZmFpbHMkZiA9IGZhaWxzJHM7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMjtcblxuLy8gRkY5OSsgYnVnXG52YXIgQlJPS0VOX09OX1NQQVJTRSA9IGZhaWxzJGYoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIUFycmF5KDEpLmluY2x1ZGVzKCk7XG59KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCQ3KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCUk9LRU5fT05fU1BBUlNFIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG5cbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkZDtcbnZhciBjbGFzc29mJDYgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIE1BVENIJDEgPSB3ZWxsS25vd25TeW1ib2wkNCgnbWF0Y2gnKTtcblxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNyZWdleHBcbnZhciBpc1JlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdCQ1KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0gkMV0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZiQ2KGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG52YXIgaXNSZWdFeHAkMSA9IGlzUmVnZXhwO1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG52YXIgbm90QVJlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAkMShpdCkpIHtcbiAgICB0aHJvdyAkVHlwZUVycm9yJDMoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxudmFyIGNsYXNzb2YkNSA9IGNsYXNzb2YkOTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbnZhciB0b1N0cmluZyQ1ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mJDUoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sJDMoJ21hdGNoJyk7XG5cbnZhciBjb3JyZWN0SXNSZWdleHBMb2dpYyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB2YXIgcmVnZXhwID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICB0cnkge1xuICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIGZhbHNlO1xufTtcblxudmFyICQkNiA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgbm90QVJlZ0V4cCA9IG5vdEFSZWdleHA7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xudmFyIHRvU3RyaW5nJDQgPSB0b1N0cmluZyQ1O1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gY29ycmVjdElzUmVnZXhwTG9naWM7XG5cbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMkYignJy5pbmRleE9mKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG4kJDYoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfnN0cmluZ0luZGV4T2YoXG4gICAgICB0b1N0cmluZyQ0KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyh0aGlzKSksXG4gICAgICB0b1N0cmluZyQ0KG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSksXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xudmFyIHdoaXRlc3BhY2VzJDIgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcbiAgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcbnZhciB0b1N0cmluZyQzID0gdG9TdHJpbmckNTtcbnZhciB3aGl0ZXNwYWNlcyQxID0gd2hpdGVzcGFjZXMkMjtcblxudmFyIHJlcGxhY2UkMSA9IHVuY3VycnlUaGlzJGEoJycucmVwbGFjZSk7XG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzJDEgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMyA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nVHJpbSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kJDMoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QkMygyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCQzKDMpXG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgZmFpbHMkZSA9IGZhaWxzJHM7XG52YXIgd2hpdGVzcGFjZXMgPSB3aGl0ZXNwYWNlcyQyO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG52YXIgc3RyaW5nVHJpbUZvcmNlZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdKClcbiAgICAgIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPT0gbm9uXG4gICAgICB8fCAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiB3aGl0ZXNwYWNlc1tNRVRIT0RfTkFNRV0ubmFtZSAhPT0gTUVUSE9EX05BTUUpO1xuICB9KTtcbn07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyICR0cmltID0gc3RyaW5nVHJpbS50cmltO1xudmFyIGZvcmNlZFN0cmluZ1RyaW1NZXRob2QgPSBzdHJpbmdUcmltRm9yY2VkO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4kJDUoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG5cbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQ3ID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJGQgPSBmYWlscyRzO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDI7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QkNCA9IHRvT2JqZWN0JDc7XG52YXIgSW5kZXhlZE9iamVjdCQyID0gaW5kZXhlZE9iamVjdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzJDkoW10uY29uY2F0KTtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG52YXIgb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyQzICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkkMih7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5JDIodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXN5bWJvbCAtLSBzYWZlXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkNCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QkMihhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyQzIHx8IGNhbGwkNyhwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBhc3NpZ24gPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCQ0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyJDEoKTtcbiAgfVxuICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6ICgpID0+IHRoaXMuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjaylcbiAgICB9O1xuICB9XG4gIG9mZihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfVxuICBlbWl0KGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChldmVudE5hbWUsIGV2ZW50KTtcbiAgfVxufVxuXG5jb25zdCBQQUNLQUdFX05BTUUgPSBcIm5lYXItd2FsbGV0LXNlbGVjdG9yXCI7XG5jb25zdCBSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyA9IFwicmVjZW50bHlTaWduZWRJbldhbGxldHNcIjtcbmNvbnN0IENPTlRSQUNUID0gXCJjb250cmFjdFwiO1xuY29uc3QgUEVORElOR19DT05UUkFDVCA9IFwiY29udHJhY3Q6cGVuZGluZ1wiO1xuY29uc3QgU0VMRUNURURfV0FMTEVUX0lEID0gYHNlbGVjdGVkV2FsbGV0SWRgO1xuY29uc3QgUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQgPSBgc2VsZWN0ZWRXYWxsZXRJZDpwZW5kaW5nYDtcblxuY2xhc3MgV2FsbGV0TW9kdWxlcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBmYWN0b3JpZXMsXG4gICAgc3RvcmFnZSxcbiAgICBvcHRpb25zLFxuICAgIHN0b3JlLFxuICAgIGVtaXR0ZXIsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZXMgPSB7fTtcbiAgfVxuICB2YWxpZGF0ZVdhbGxldChpZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgYWNjb3VudHMgPSBbXTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0KGlkKTtcbiAgICAgIGlmICh3YWxsZXQpIHtcbiAgICAgICAgLy8gRW5zdXJlIG91ciBwZXJzaXN0ZW50IHN0YXRlIGFsaWducyB3aXRoIHRoZSBzZWxlY3RlZCB3YWxsZXQuXG4gICAgICAgIC8vIEZvciBleGFtcGxlIGEgd2FsbGV0IGlzIHNlbGVjdGVkLCBidXQgaXQgcmV0dXJucyBubyBhY2NvdW50cyAobm90IHNpZ25lZCBpbikuXG4gICAgICAgIGFjY291bnRzID0geWllbGQgd2FsbGV0LmdldEFjY291bnRzKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gdmFsaWRhdGUgJHt3YWxsZXQuaWR9IGR1cmluZyBzZXR1cGApO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZVN0b3JhZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgY29uc3QgcGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdDb250cmFjdCA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUEVORElOR19DT05UUkFDVCk7XG4gICAgICBpZiAocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQgJiYgcGVuZGluZ0NvbnRyYWN0KSB7XG4gICAgICAgIGNvbnN0IF9hY2NvdW50cyA9IHlpZWxkIHRoaXMudmFsaWRhdGVXYWxsZXQocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5yZW1vdmVJdGVtKFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEKTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShQRU5ESU5HX0NPTlRSQUNUKTtcbiAgICAgICAgaWYgKF9hY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBfc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRXYWxsZXQgPSB5aWVsZCB0aGlzLmdldFdhbGxldChfc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0ICYmIHBlbmRpbmdTZWxlY3RlZFdhbGxldElkICE9PSBfc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgICAgeWllbGQgc2VsZWN0ZWRXYWxsZXQuc2lnbk91dCgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gc2lnbiBvdXQgZXhpc3Rpbmcgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWNlbnRseVNpZ25lZEluV2FsbGV0c0Zyb21QZW5kaW5nID0geWllbGQgdGhpcy5zZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4ocGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50czogX2FjY291bnRzLFxuICAgICAgICAgICAgY29udHJhY3Q6IHBlbmRpbmdDb250cmFjdCxcbiAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHBlbmRpbmdTZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzRnJvbVBlbmRpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCB0aGlzLnZhbGlkYXRlV2FsbGV0KHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTKTtcbiAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWNjb3VudHM6IFtdLFxuICAgICAgICAgIGNvbnRyYWN0OiBudWxsLFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IG51bGwsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzIHx8IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3QsXG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0cyB8fCBbXVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4od2FsbGV0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgbGV0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyk7XG4gICAgICBpZiAoIXJlY2VudGx5U2lnbmVkSW5XYWxsZXRzKSB7XG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLmluY2x1ZGVzKHdhbGxldElkKSkge1xuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0cy51bnNoaWZ0KHdhbGxldElkKTtcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSByZWNlbnRseVNpZ25lZEluV2FsbGV0cy5zbGljZSgwLCA1KTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUywgcmVjZW50bHlTaWduZWRJbldhbGxldHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzO1xuICAgIH0pO1xuICB9XG4gIHNpZ25PdXRXYWxsZXQod2FsbGV0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy5nZXRXYWxsZXQod2FsbGV0SWQpO1xuICAgICAgeWllbGQgd2FsbGV0LnNpZ25PdXQoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gc2lnbiBvdXQgJHt3YWxsZXQuaWR9YCk7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAvLyBBdCBsZWFzdCBjbGVhbiB1cCBzdGF0ZSBvbiBvdXIgc2lkZS5cbiAgICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dCh3YWxsZXQuaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25XYWxsZXRTaWduZWRJbih3YWxsZXRJZCwge1xuICAgIGFjY291bnRzLFxuICAgIGNvbnRyYWN0SWQsXG4gICAgbWV0aG9kTmFtZXNcbiAgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBqc29uU3RvcmFnZSA9IG5ldyBKc29uU3RvcmFnZSh0aGlzLnN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gICAgICBjb25zdCBjb250cmFjdCA9IHtcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXNcbiAgICAgIH07XG4gICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdldE1vZHVsZSh3YWxsZXRJZCk7XG4gICAgICAgIC8vIFdlIGNhbid0IGd1YXJhbnRlZSB0aGUgdXNlciB3aWxsIGFjdHVhbGx5IHNpZ24gaW4gd2l0aCBicm93c2VyIHdhbGxldHMuXG4gICAgICAgIC8vIEJlc3Qgd2UgY2FuIGRvIGlzIHNldCBpbiBzdG9yYWdlIGFuZCB2YWxpZGF0ZSBvbiBpbml0LlxuICAgICAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCwgd2FsbGV0SWQpO1xuICAgICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUEVORElOR19DT05UUkFDVCwgY29udHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZFdhbGxldElkICYmIHNlbGVjdGVkV2FsbGV0SWQgIT09IHdhbGxldElkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2lnbk91dFdhbGxldChzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQgdGhpcy5zZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4od2FsbGV0SWQpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiV0FMTEVUX0NPTk5FQ1RFRFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNpZ25lZEluXCIsIHtcbiAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzLFxuICAgICAgICBhY2NvdW50c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25XYWxsZXRTaWduZWRPdXQod2FsbGV0SWQpIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFwiV0FMTEVUX0RJU0NPTk5FQ1RFRFwiLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB3YWxsZXRJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2lnbmVkT3V0XCIsIHtcbiAgICAgIHdhbGxldElkXG4gICAgfSk7XG4gIH1cbiAgc2V0dXBXYWxsZXRFbWl0dGVyKG1vZHVsZSkge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgZW1pdHRlci5vbihcInNpZ25lZE91dFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KG1vZHVsZS5pZCk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcInNpZ25lZEluXCIsIGV2ZW50ID0+IHtcbiAgICAgIHRoaXMub25XYWxsZXRTaWduZWRJbihtb2R1bGUuaWQsIGV2ZW50KTtcbiAgICB9KTtcbiAgICBlbWl0dGVyLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsICh7XG4gICAgICBhY2NvdW50c1xuICAgIH0pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk91dFdhbGxldChtb2R1bGUuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiQUNDT1VOVFNfQ0hBTkdFRFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICBhY2NvdW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gICAgZW1pdHRlci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsICh7XG4gICAgICBuZXR3b3JrSWRcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcIm5ldHdvcmtDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgbmV0d29ya0lkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbWl0dGVyLm9uKFwidXJpQ2hhbmdlZFwiLCAoe1xuICAgICAgdXJpXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJ1cmlDaGFuZ2VkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgdXJpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbiAgfVxuICB2YWxpZGF0ZVNpZ25NZXNzYWdlUGFyYW1zKHtcbiAgICBtZXNzYWdlLFxuICAgIG5vbmNlLFxuICAgIHJlY2lwaWVudFxuICB9KSB7XG4gICAgaWYgKCFtZXNzYWdlIHx8IG1lc3NhZ2UudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2UuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobm9uY2UpIHx8IG5vbmNlLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9uY2UuIEl0IG11c3QgYmUgYSBCdWZmZXIgd2l0aCBhIGxlbmd0aCBvZiAzMiBieXRlcy5cIik7XG4gICAgfVxuICAgIGlmICghcmVjaXBpZW50IHx8IHJlY2lwaWVudC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVjaXBpZW50LiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG4gICAgfVxuICB9XG4gIGRlY29yYXRlV2FsbGV0KHdhbGxldCkge1xuICAgIGNvbnN0IF9zaWduSW4gPSB3YWxsZXQuc2lnbkluO1xuICAgIGNvbnN0IF9zaWduT3V0ID0gd2FsbGV0LnNpZ25PdXQ7XG4gICAgY29uc3QgX3NpZ25NZXNzYWdlID0gd2FsbGV0LnNpZ25NZXNzYWdlO1xuICAgIHdhbGxldC5zaWduSW4gPSBwYXJhbXMgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBfc2lnbkluKHBhcmFtcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzID0gW11cbiAgICAgIH0gPSBwYXJhbXM7XG4gICAgICB5aWVsZCB0aGlzLm9uV2FsbGV0U2lnbmVkSW4od2FsbGV0LmlkLCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSk7XG4gICAgd2FsbGV0LnNpZ25PdXQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc2lnbk91dCgpO1xuICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dCh3YWxsZXQuaWQpO1xuICAgIH0pO1xuICAgIHdhbGxldC5zaWduTWVzc2FnZSA9IHBhcmFtcyA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoX3NpZ25NZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBzaWduTWVzc2FnZSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSAke3dhbGxldC5tZXRhZGF0YS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVNpZ25NZXNzYWdlUGFyYW1zKHBhcmFtcyk7XG4gICAgICByZXR1cm4geWllbGQgX3NpZ25NZXNzYWdlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdhbGxldDtcbiAgfVxuICBzZXR1cEluc3RhbmNlKG1vZHVsZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIW1vZHVsZS5tZXRhZGF0YS5hdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1vZHVsZS50eXBlID09PSBcImluamVjdGVkXCIgPyBcIm5vdCBpbnN0YWxsZWRcIiA6IFwibm90IGF2YWlsYWJsZVwiO1xuICAgICAgICB0aHJvdyBFcnJvcihgJHttb2R1bGUubWV0YWRhdGEubmFtZX0gaXMgJHttZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FsbGV0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGlkOiBtb2R1bGUuaWQsXG4gICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhXG4gICAgICB9LCB5aWVsZCBtb2R1bGUuaW5pdCh7XG4gICAgICAgIGlkOiBtb2R1bGUuaWQsXG4gICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLnRvUmVhZE9ubHkoKSxcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICAgIGVtaXR0ZXI6IHRoaXMuc2V0dXBXYWxsZXRFbWl0dGVyKG1vZHVsZSksXG4gICAgICAgIGxvZ2dlcjogbmV3IExvZ2dlcihtb2R1bGUuaWQpLFxuICAgICAgICBzdG9yYWdlOiBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBbUEFDS0FHRV9OQU1FLCBtb2R1bGUuaWRdKVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGVXYWxsZXQod2FsbGV0KTtcbiAgICB9KTtcbiAgfVxuICBnZXRNb2R1bGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVzLmZpbmQoeCA9PiB4LmlkID09PSBpZCk7XG4gIH1cbiAgZ2V0V2FsbGV0KGlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKGlkKTtcbiAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgLy8gSWYgdXNlciB1bmluc3RhbGxlZC9yZW1vdmVkIGEgd2FsbGV0IHdoaWNoIHdhcyBwcmV2aW91c2x5IHNpZ25lZCBpbiB3aXRoXG4gICAgICAvLyBiZXN0IHdlIGNhbiBkbyBpcyBjbGVhbiB1cCBzdGF0ZSBvbiBvdXIgc2lkZS5cbiAgICAgIGlmICghbW9kdWxlLm1ldGFkYXRhLmF2YWlsYWJsZSAmJiBzZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkIG1vZHVsZS53YWxsZXQoKTtcbiAgICB9KTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbW9kdWxlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY3Rvcmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB5aWVsZCB0aGlzLmZhY3Rvcmllc1tpXSh7XG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBzZXR1cCBtb2R1bGVcIik7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IHdhbGxldHMgdGhhdCBhcmVuJ3QgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgZHVwbGljYXRlZCBtb2R1bGUuXG4gICAgICAgIGlmIChtb2R1bGVzLnNvbWUoeCA9PiB4LmlkID09PSBtb2R1bGUuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICAgIHR5cGU6IG1vZHVsZS50eXBlLFxuICAgICAgICAgIG1ldGFkYXRhOiBtb2R1bGUubWV0YWRhdGEsXG4gICAgICAgICAgd2FsbGV0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlc1ttb2R1bGUuaWRdO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlID0geWllbGQgdGhpcy5zZXR1cEluc3RhbmNlKG1vZHVsZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc1ttb2R1bGUuaWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3QsXG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICB9ID0geWllbGQgdGhpcy5yZXNvbHZlU3RvcmFnZVN0YXRlKCk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJTRVRVUF9XQUxMRVRfTU9EVUxFU1wiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1tpXS50eXBlICE9PSBcImluc3RhbnQtbGlua1wiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy5tb2R1bGVzW2ldLndhbGxldCgpO1xuICAgICAgICBpZiAoIXdhbGxldC5tZXRhZGF0YS5ydW5PblN0YXJ0dXApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICAgICAgY29udHJhY3RJZDogd2FsbGV0LmdldENvbnRyYWN0SWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gc2lnbiBpbiB0byB3YWxsZXQuIFwiICsgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGdldE5ldHdvcmtQcmVzZXQgPSBuZXR3b3JrSWQgPT4ge1xuICBzd2l0Y2ggKG5ldHdvcmtJZCkge1xuICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXR3b3JrSWQsXG4gICAgICAgIG5vZGVVcmw6IFwiaHR0cHM6Ly9ycGMubWFpbm5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBoZWxwZXJVcmw6IFwiaHR0cHM6Ly9oZWxwZXIubWFpbm5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBleHBsb3JlclVybDogXCJodHRwczovL25lYXJibG9ja3MuaW9cIixcbiAgICAgICAgaW5kZXhlclVybDogXCJodHRwczovL2FwaS5raXR3YWxsZXQuYXBwXCJcbiAgICAgIH07XG4gICAgY2FzZSBcInRlc3RuZXRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgbm9kZVVybDogXCJodHRwczovL3JwYy50ZXN0bmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGhlbHBlclVybDogXCJodHRwczovL2hlbHBlci50ZXN0bmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGV4cGxvcmVyVXJsOiBcImh0dHBzOi8vdGVzdG5ldC5uZWFyYmxvY2tzLmlvXCIsXG4gICAgICAgIGluZGV4ZXJVcmw6IFwiaHR0cHM6Ly90ZXN0bmV0LWFwaS5raXR3YWxsZXQuYXBwXCJcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gZmluZCBjb25maWcgZm9yOiAnJHtuZXR3b3JrSWR9J2ApO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZU5ldHdvcmsgPSBuZXR3b3JrID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBuZXR3b3JrID09PSBcInN0cmluZ1wiID8gZ2V0TmV0d29ya1ByZXNldChuZXR3b3JrKSA6IG5ldHdvcms7XG59O1xuY29uc3QgcmVzb2x2ZU9wdGlvbnMgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGxhbmd1YWdlQ29kZTogcGFyYW1zLmxhbmd1YWdlQ29kZSB8fCB1bmRlZmluZWQsXG4gICAgbmV0d29yazogcmVzb2x2ZU5ldHdvcmsocGFyYW1zLm5ldHdvcmspLFxuICAgIGRlYnVnOiBwYXJhbXMuZGVidWcgfHwgZmFsc2UsXG4gICAgb3B0aW1pemVXYWxsZXRPcmRlcjogcGFyYW1zLm9wdGltaXplV2FsbGV0T3JkZXIgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlLFxuICAgIHJhbmRvbWl6ZVdhbGxldE9yZGVyOiBwYXJhbXMucmFuZG9taXplV2FsbGV0T3JkZXIgfHwgZmFsc2UsXG4gICAgcmVsYXllclVybDogcGFyYW1zLnJlbGF5ZXJVcmwgfHwgdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBzdG9yYWdlOiBwYXJhbXMuc3RvcmFnZSB8fCBuZXcgV2ViU3RvcmFnZVNlcnZpY2UoKVxuICB9O1xufTtcblxuY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGxvZ2dlci5sb2coXCJTdG9yZSBBY3Rpb25cIiwgYWN0aW9uKTtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJTRVRVUF9XQUxMRVRfTU9EVUxFU1wiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgYWNjb3VudFN0YXRlcyA9IGFjY291bnRzLm1hcCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGkgPT09IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiV0FMTEVUX0NPTk5FQ1RFRFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVBY2NvdW50SW5kZXggPSBzdGF0ZS5hY2NvdW50cy5maW5kSW5kZXgoYWNjb3VudCA9PiBhY2NvdW50LmFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpID09PSAoYWN0aXZlQWNjb3VudEluZGV4ID4gLTEgPyBhY3RpdmVBY2NvdW50SW5kZXggOiAwKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXMsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogd2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIldBTExFVF9ESVNDT05ORUNURURcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdhbGxldElkXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgaWYgKHdhbGxldElkICE9PSBzdGF0ZS5zZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGNvbnRyYWN0OiBudWxsLFxuICAgICAgICAgIGFjY291bnRzOiBbXSxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJBQ0NPVU5UU19DSEFOR0VEXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgICBhY2NvdW50c1xuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGlmICh3YWxsZXRJZCAhPT0gc3RhdGUuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVBY2NvdW50ID0gc3RhdGUuYWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQuYWN0aXZlKTtcbiAgICAgICAgY29uc3QgaXNBY3RpdmVBY2NvdW50UmVtb3ZlZCA9ICFhY2NvdW50cy5zb21lKGFjY291bnQgPT4gYWNjb3VudC5hY2NvdW50SWQgPT09IChhY3RpdmVBY2NvdW50ID09PSBudWxsIHx8IGFjdGl2ZUFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUFjY291bnQuYWNjb3VudElkKSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZUFjY291bnRSZW1vdmVkID8gaSA9PT0gMCA6IGFjY291bnQuYWNjb3VudElkID09PSAoYWN0aXZlQWNjb3VudCA9PT0gbnVsbCB8fCBhY3RpdmVBY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVBY2NvdW50LmFjY291bnRJZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJTRVRfQUNUSVZFX0FDQ09VTlRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFjY291bnRJZFxuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBzdGF0ZS5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogYWNjb3VudC5hY2NvdW50SWQgPT09IGFjY291bnRJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gc3RvcmFnZSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2Uoc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIG1vZHVsZXM6IFtdLFxuICAgIGFjY291bnRzOiBbXSxcbiAgICBjb250cmFjdDogeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShDT05UUkFDVCksXG4gICAgc2VsZWN0ZWRXYWxsZXRJZDogeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShTRUxFQ1RFRF9XQUxMRVRfSUQpLFxuICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiAoeWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUykpIHx8IFtdXG4gIH07XG4gIGNvbnN0IHN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgYWN0aW9ucyQgPSBuZXcgU3ViamVjdCgpO1xuICBhY3Rpb25zJC5waXBlKHNjYW4ocmVkdWNlciwgaW5pdGlhbFN0YXRlKSkuc3Vic2NyaWJlKHN0YXRlJCk7XG4gIGNvbnN0IHN5bmNTdG9yYWdlID0gKHByZXZTdGF0ZSwgc3RhdGUsIHN0b3JhZ2VLZXksIHByb3BlcnR5KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoc3RhdGVbcHJvcGVydHldID09PSBwcmV2U3RhdGVbcHJvcGVydHldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZVtwcm9wZXJ0eV0pIHtcbiAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgc3RhdGVbcHJvcGVydHldKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgfSk7XG4gIGxldCBwcmV2U3RhdGUgPSBzdGF0ZSQuZ2V0VmFsdWUoKTtcbiAgc3RhdGUkLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgU0VMRUNURURfV0FMTEVUX0lELCBcInNlbGVjdGVkV2FsbGV0SWRcIik7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgQ09OVFJBQ1QsIFwiY29udHJhY3RcIik7XG4gICAgc3luY1N0b3JhZ2UocHJldlN0YXRlLCBzdGF0ZSwgUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMsIFwicmVjZW50bHlTaWduZWRJbldhbGxldHNcIik7XG4gICAgcHJldlN0YXRlID0gc3RhdGU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG9ic2VydmFibGU6IHN0YXRlJCxcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUkLmdldFZhbHVlKCksXG4gICAgZGlzcGF0Y2g6IGFjdGlvbiA9PiBhY3Rpb25zJC5uZXh0KGFjdGlvbiksXG4gICAgdG9SZWFkT25seTogKCkgPT4gKHtcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSQuZ2V0VmFsdWUoKSxcbiAgICAgIG9ic2VydmFibGU6IHN0YXRlJC5hc09ic2VydmFibGUoKVxuICAgIH0pXG4gIH07XG59KTtcblxubGV0IHdhbGxldFNlbGVjdG9ySW5zdGFuY2UgPSBudWxsO1xuY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAob3B0aW9ucywgc3RvcmUsIHdhbGxldE1vZHVsZXMsIGVtaXR0ZXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIHN0b3JlOiBzdG9yZS50b1JlYWRPbmx5KCksXG4gICAgd2FsbGV0OiBpZCA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB3YWxsZXRNb2R1bGVzLmdldFdhbGxldChpZCB8fCBzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBzZWxlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfSksXG4gICAgc2V0QWN0aXZlQWNjb3VudDogYWNjb3VudElkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKCFhY2NvdW50cy5zb21lKGFjY291bnQgPT4gYWNjb3VudC5hY2NvdW50SWQgPT09IGFjY291bnRJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2NvdW50IGlkXCIpO1xuICAgICAgfVxuICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIlNFVF9BQ1RJVkVfQUNDT1VOVFwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYWNjb3VudElkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNTaWduZWRJbigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oYWNjb3VudHMubGVuZ3RoKTtcbiAgICB9LFxuICAgIG9uOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmY6IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBlbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59O1xuLyoqXHJcbiAqIEluaXRpYXRlcyBhIHdhbGxldCBzZWxlY3RvciBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge1dhbGxldFNlbGVjdG9yUGFyYW1zfSBwYXJhbXMgU2VsZWN0b3IgcGFyYW1ldGVycyAobmV0d29yaywgbW9kdWxlcy4uLilcclxuICogQHJldHVybnMge1Byb21pc2U8V2FsbGV0U2VsZWN0b3I+fSBSZXR1cm5zIGEgV2FsbGV0U2VsZWN0b3Igb2JqZWN0XHJcbiAqL1xuY29uc3Qgc2V0dXBXYWxsZXRTZWxlY3RvciA9IHBhcmFtcyA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnMsXG4gICAgc3RvcmFnZVxuICB9ID0gcmVzb2x2ZU9wdGlvbnMocGFyYW1zKTtcbiAgTG9nZ2VyLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgY29uc3Qgc3RvcmUgPSB5aWVsZCBjcmVhdGVTdG9yZShzdG9yYWdlKTtcbiAgY29uc3Qgd2FsbGV0TW9kdWxlcyA9IG5ldyBXYWxsZXRNb2R1bGVzKHtcbiAgICBmYWN0b3JpZXM6IHBhcmFtcy5tb2R1bGVzLFxuICAgIHN0b3JhZ2UsXG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZSxcbiAgICBlbWl0dGVyLFxuICAgIHByb3ZpZGVyOiBuZXcgUHJvdmlkZXIob3B0aW9ucy5uZXR3b3JrLm5vZGVVcmwpXG4gIH0pO1xuICB5aWVsZCB3YWxsZXRNb2R1bGVzLnNldHVwKCk7XG4gIGlmIChwYXJhbXMuYWxsb3dNdWx0aXBsZVNlbGVjdG9ycykge1xuICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihvcHRpb25zLCBzdG9yZSwgd2FsbGV0TW9kdWxlcywgZW1pdHRlcik7XG4gIH1cbiAgaWYgKCF3YWxsZXRTZWxlY3Rvckluc3RhbmNlKSB7XG4gICAgd2FsbGV0U2VsZWN0b3JJbnN0YW5jZSA9IGNyZWF0ZVNlbGVjdG9yKG9wdGlvbnMsIHN0b3JlLCB3YWxsZXRNb2R1bGVzLCBlbWl0dGVyKTtcbiAgfVxuICByZXR1cm4gd2FsbGV0U2VsZWN0b3JJbnN0YW5jZTtcbn0pO1xuXG5jb25zdCB3YWl0ID0gbXMgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59O1xuY29uc3QgcG9sbCA9IChjYiwgaW50ZXJ2YWwsIHJlbWFpbmluZykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNiKCk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghcmVtYWluaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZWVkZWQgdGltZW91dFwiKTtcbiAgfVxuICByZXR1cm4gd2FpdChpbnRlcnZhbCkudGhlbigoKSA9PiBwb2xsKGNiLCBpbnRlcnZhbCwgcmVtYWluaW5nIC0gMSkpO1xufSk7XG5jb25zdCB3YWl0Rm9yID0gKGNiLCBvcHRzID0ge30pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgdGltZW91dCA9IDEwMCxcbiAgICBpbnRlcnZhbCA9IDUwXG4gIH0gPSBvcHRzO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFt3YWl0KHRpbWVvdXQpLnRoZW4oKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VlZGVkIHRpbWVvdXRcIik7XG4gIH0pLCBwb2xsKGNiLCBpbnRlcnZhbCwgTWF0aC5mbG9vcih0aW1lb3V0IC8gaW50ZXJ2YWwpKV0pO1xufSk7XG5cbmNvbnN0IGdldEFjdGl2ZUFjY291bnQgPSBzdGF0ZSA9PiB7XG4gIHJldHVybiBzdGF0ZS5hY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5hY3RpdmUpIHx8IG51bGw7XG59O1xuXG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkOTtcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkNztcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDUgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUkMShjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDModGhhdCk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0JDEoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDUoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgJFR5cGVFcnJvciQyKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZWR1Y2UgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QkMih0cnVlKVxufTtcblxudmFyIGZhaWxzJGMgPSBmYWlscyRzO1xuXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQxID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0sIDEpO1xuICB9KTtcbn07XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDE7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbi8vIENocm9tZSA4MC04MiBoYXMgYSBjcml0aWNhbCBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcbnZhciBDSFJPTUVfQlVHID0gIUlTX05PREUgJiYgQ0hST01FX1ZFUlNJT04gPiA3OSAmJiBDSFJPTUVfVkVSU0lPTiA8IDgzO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQkMyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfHwgQ0hST01FX0JVRyB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRlO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCQzKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZmFpbHMkYiA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDIgPSBnbG9iYWwkYS5SZWdFeHA7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDIgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZJDIgfHwgZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhJFJlZ0V4cCQyKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kkMiB8fCBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XG4gIHZhciByZSA9ICRSZWdFeHAkMignXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZJDJcbn07XG5cbnZhciBmYWlscyRhID0gZmFpbHMkcztcbnZhciBnbG9iYWwkOSA9IGdsb2JhbCR0O1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMSA9IGdsb2JhbCQ5LlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsID0gZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMSgnLicsICdzJyk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsJDguUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWROY2cgPSBmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnKD88YT5iKScsICdnJyk7XG4gIHJldHVybiByZS5leGVjKCdiJykuZ3JvdXBzLmEgIT09ICdiJyB8fFxuICAgICdiJy5yZXBsYWNlKHJlLCAnJDxhPmMnKSAhPT0gJ2JjJztcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ1O1xudmFyIHJlZ2V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcbnZhciBzdGlja3lIZWxwZXJzJDEgPSByZWdleHBTdGlja3lIZWxwZXJzO1xudmFyIHNoYXJlZCA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgY3JlYXRlJDEgPSBvYmplY3RDcmVhdGU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQzID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG52YXIgVU5TVVBQT1JURURfRE9UX0FMTCA9IHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsO1xudmFyIFVOU1VQUE9SVEVEX05DRyA9IHJlZ2V4cFVuc3VwcG9ydGVkTmNnO1xuXG52YXIgbmF0aXZlUmVwbGFjZSA9IHNoYXJlZCgnbmF0aXZlLXN0cmluZy1yZXBsYWNlJywgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBjaGFyQXQkMiA9IHVuY3VycnlUaGlzJDgoJycuY2hhckF0KTtcbnZhciBpbmRleE9mID0gdW5jdXJyeVRoaXMkOCgnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkOCgnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSQyID0gdW5jdXJyeVRoaXMkOCgnJy5zbGljZSk7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIGNhbGwkNihuYXRpdmVFeGVjLCByZTEsICdhJyk7XG4gIGNhbGwkNihuYXRpdmVFeGVjLCByZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSQxID0gc3RpY2t5SGVscGVycyQxLkJST0tFTl9DQVJFVDtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQgfHwgVU5TVVBQT1JURURfWSQxIHx8IFVOU1VQUE9SVEVEX0RPVF9BTEwgfHwgVU5TVVBQT1JURURfTkNHO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cmluZykge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQzKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmckMihzdHJpbmcpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IGNhbGwkNihwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSQxICYmIHJlLnN0aWNreTtcbiAgICB2YXIgZmxhZ3MgPSBjYWxsJDYocmVnZXhwRmxhZ3MsIHJlKTtcbiAgICB2YXIgc291cmNlID0gcmUuc291cmNlO1xuICAgIHZhciBjaGFyc0FkZGVkID0gMDtcbiAgICB2YXIgc3RyQ29weSA9IHN0cjtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGZsYWdzID0gcmVwbGFjZShmbGFncywgJ3knLCAnJyk7XG4gICAgICBpZiAoaW5kZXhPZihmbGFncywgJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyaW5nU2xpY2UkMihzdHIsIHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBjaGFyQXQkMihzdHIsIHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBjYWxsJDYobmF0aXZlRXhlYywgc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gc3RyaW5nU2xpY2UkMihtYXRjaC5pbnB1dCwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UkMihtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBjYWxsJDYobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZSQxKG51bGwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgb2JqZWN0W2dyb3VwWzBdXSA9IG1hdGNoW2dyb3VwWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbnZhciByZWdleHBFeGVjJDMgPSBwYXRjaGVkRXhlYztcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgZXhlYyQxID0gcmVnZXhwRXhlYyQzO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS5leGVjXG4kJDIoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyQxIH0sIHtcbiAgZXhlYzogZXhlYyQxXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW1vbk9laGxtYW4vZGV0ZWN0LWJyb3dzZXIvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzXG5jb25zdCBTRUFSQ0hCT1hfVUFfUkVHRVggPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC87XG5jb25zdCB1c2VyQWdlbnRSdWxlcyA9IFtbXCJhb2xcIiwgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLCBbXCJlZGdlXCIsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sIFtcImVkZ2UtaW9zXCIsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSwgW1wieWFuZGV4YnJvd3NlclwiLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sIFtcImtha2FvdGFsa1wiLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSwgW1wic2Ftc3VuZ1wiLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLCBbXCJzaWxrXCIsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSwgW1wibWl1aVwiLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSwgW1wiYmVha2VyXCIsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSwgW1wiZWRnZS1jaHJvbWl1bVwiLCAvRWRnQT9cXC8oWzAtOVxcLl0rKS9dLCBbXCJjaHJvbWl1bS13ZWJ2aWV3XCIsIC8oPyFDaHJvbS4qT1BSKXd2XFwpLipDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImNocm9tZVwiLCAvKD8hQ2hyb20uKk9QUilDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcInBoYW50b21qc1wiLCAvUGhhbnRvbUpTXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wiY3Jpb3NcIiwgL0NyaU9TXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wiZmlyZWZveFwiLCAvRmlyZWZveFxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sIFtcImZ4aW9zXCIsIC9GeGlPU1xcLyhbMC05XFwuXSspL10sIFtcIm9wZXJhLW1pbmlcIiwgL09wZXJhIE1pbmkuKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLCBbXCJvcGVyYVwiLCAvT3BlcmFcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLCBbXCJvcGVyYVwiLCAvT1BSXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wicGllXCIsIC9eTWljcm9zb2Z0IFBvY2tldCBJbnRlcm5ldCBFeHBsb3JlclxcLyhcXGQrXFwuXFxkKykkL10sIFtcInBpZVwiLCAvXk1vemlsbGFcXC9cXGRcXC5cXGQrXFxzXFwoY29tcGF0aWJsZTtcXHMoPzpNU1A/SUV8TVNJbnRlcm5ldCBFeHBsb3JlcikgKFxcZCtcXC5cXGQrKTsuKldpbmRvd3MgQ0UuKlxcKSQvXSwgW1wibmV0ZnJvbnRcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkKy4qTmV0RnJvbnRcXC8oXFxkLlxcZCkvXSwgW1wiaWVcIiwgL1RyaWRlbnRcXC83XFwuMC4qcnZcXDooWzAtOVxcLl0rKS4qXFwpLipHZWNrbyQvXSwgW1wiaWVcIiwgL01TSUVcXHMoWzAtOVxcLl0rKTsuKlRyaWRlbnRcXC9bNC03XS4wL10sIFtcImllXCIsIC9NU0lFXFxzKDdcXC4wKS9dLCBbXCJiYjEwXCIsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSwgW1wiYW5kcm9pZFwiLCAvQW5kcm9pZFxccyhbMC05XFwuXSspL10sIFtcImlvc1wiLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLCBbXCJzYWZhcmlcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKlNhZmFyaS9dLCBbXCJmYWNlYm9va1wiLCAvRkJbQVNdVlxcLyhbMC05XFwuXSspL10sIFtcImluc3RhZ3JhbVwiLCAvSW5zdGFncmFtXFxzKFswLTlcXC5dKykvXSwgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKk1vYmlsZS9dLCBbXCJpb3Mtd2Vidmlld1wiLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qR2Vja29cXCkkL10sIFtcImN1cmxcIiwgL15jdXJsXFwvKFswLTlcXC5dKykkL10sIFtcInNlYXJjaGJvdFwiLCBTRUFSQ0hCT1hfVUFfUkVHRVhdXTtcbmNvbnN0IG1hdGNoVXNlckFnZW50ID0gdWEgPT4ge1xuICByZXR1cm4gdWEgIT09IFwiXCIgJiYgdXNlckFnZW50UnVsZXMucmVkdWNlKChtYXRjaGVkLCBbYnJvd3NlciwgcmVnZXhdKSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgICBjb25zdCB1YU1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gIH0sIGZhbHNlKTtcbn07XG5jb25zdCBpc0N1cnJlbnRCcm93c2VyU3VwcG9ydGVkID0gc3VwcG9ydGVkQnJvd3NlciA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoZWRSdWxlID0gbWF0Y2hVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW25hbWVdID0gbWF0Y2hlZFJ1bGU7XG4gIGlmIChuYW1lID09PSBcInNlYXJjaGJvdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhIXN1cHBvcnRlZEJyb3dzZXIuZmluZChpdGVtID0+IGl0ZW0gPT09IG5hbWUpO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tdHlwZWQtYXJyYXlzIC0tIHNhZmVcbnZhciBhcnJheUJ1ZmZlck5hdGl2ZSA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSJDEgPSBhcnJheUJ1ZmZlck5hdGl2ZTtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JGQ7XG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGNsYXNzb2YkNCA9IGNsYXNzb2YkOTtcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDIgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgdWlkID0gdWlkJDM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0O1xudmFyIEludDhBcnJheSQ0ID0gZ2xvYmFsJDcuSW50OEFycmF5O1xudmFyIEludDhBcnJheVByb3RvdHlwZSQxID0gSW50OEFycmF5JDQgJiYgSW50OEFycmF5JDQucHJvdG90eXBlO1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5JDEgPSBnbG9iYWwkNy5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5JDEgJiYgVWludDhDbGFtcGVkQXJyYXkkMS5wcm90b3R5cGU7XG52YXIgVHlwZWRBcnJheSQxID0gSW50OEFycmF5JDQgJiYgZ2V0UHJvdG90eXBlT2YkMShJbnQ4QXJyYXkkNCk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gSW50OEFycmF5UHJvdG90eXBlJDEgJiYgZ2V0UHJvdG90eXBlT2YkMShJbnQ4QXJyYXlQcm90b3R5cGUkMSk7XG52YXIgT2JqZWN0UHJvdG90eXBlJDEgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDcuVHlwZUVycm9yO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQyKCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyQxID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9ICdUeXBlZEFycmF5Q29uc3RydWN0b3InO1xuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyID0gTkFUSVZFX0FSUkFZX0JVRkZFUiQxICYmICEhc2V0UHJvdG90eXBlT2YkMyAmJiBjbGFzc29mJDQoZ2xvYmFsJDcub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mJDQoaXQpO1xuICByZXR1cm4ga2xhc3MgPT09ICdEYXRhVmlldydcbiAgICB8fCBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duJDEoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mJDEoaXQpO1xuICBpZiAoIWlzT2JqZWN0JDQocHJvdG8pKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMihwcm90byk7XG4gIHJldHVybiAoc3RhdGUgJiYgaGFzT3duJDEoc3RhdGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SKSkgPyBzdGF0ZVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IocHJvdG8pO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QkNChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZiQ0KGl0KTtcbiAgcmV0dXJuIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24kMShCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1R5cGVkQXJyYXkkMShpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgVHlwZUVycm9yJDEoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheScpO1xufTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMiA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChpc0NhbGxhYmxlJDIoQykgJiYgKCFzZXRQcm90b3R5cGVPZiQzIHx8IGlzUHJvdG90eXBlT2YkMShUeXBlZEFycmF5JDEsIEMpKSkgcmV0dXJuIEM7XG4gIHRocm93IFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkNCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQsIG9wdGlvbnMpIHtcbiAgaWYgKCFERVNDUklQVE9SUyQyKSByZXR1cm47XG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIEtFWSkpIHRyeSB7XG4gICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBvbGQgV2ViS2l0IGJ1ZyAtIHNvbWUgbWV0aG9kcyBhcmUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldID0gcHJvcGVydHk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgfVxuICBpZiAoIVR5cGVkQXJyYXlQcm90b3R5cGUkMVtLRVldIHx8IGZvcmNlZCkge1xuICAgIGRlZmluZUJ1aWx0SW4kMihUeXBlZEFycmF5UHJvdG90eXBlJDEsIEtFWSwgZm9yY2VkID8gcHJvcGVydHlcbiAgICAgIDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIEludDhBcnJheVByb3RvdHlwZSQxW0tFWV0gfHwgcHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCQxID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICB2YXIgQVJSQVksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgaWYgKCFERVNDUklQVE9SUyQyKSByZXR1cm47XG4gIGlmIChzZXRQcm90b3R5cGVPZiQzKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDdbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSkpIHRyeSB7XG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gICAgaWYgKCFUeXBlZEFycmF5JDFbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21lIDQ5LTUwIGAlVHlwZWRBcnJheSVgIG1ldGhvZHMgYXJlIG5vbi13cml0YWJsZSBub24tY29uZmlndXJhYmxlXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQnVpbHRJbiQyKFR5cGVkQXJyYXkkMSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eSA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBUeXBlZEFycmF5JDFbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDdbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXSB8fCBmb3JjZWQpKSB7XG4gICAgICBkZWZpbmVCdWlsdEluJDIoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3RvcjtcbiAgZWxzZSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgPSBmYWxzZTtcbn1cblxuZm9yIChOQU1FIGluIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3Rvcjtcbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIHR5cGVkIGFycmF5cyBjb25zdHJ1Y3RvcnMgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGVcbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyIHx8ICFpc0NhbGxhYmxlJDIoVHlwZWRBcnJheSQxKSB8fCBUeXBlZEFycmF5JDEgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93IC0tIHNhZmVcbiAgVHlwZWRBcnJheSQxID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IkMSgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbiAgfTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMikgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbCQ3W05BTUVdKSBzZXRQcm90b3R5cGVPZiQzKGdsb2JhbCQ3W05BTUVdLCBUeXBlZEFycmF5JDEpO1xuICB9XG59XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyIHx8ICFUeXBlZEFycmF5UHJvdG90eXBlJDEgfHwgVHlwZWRBcnJheVByb3RvdHlwZSQxID09PSBPYmplY3RQcm90b3R5cGUkMSkge1xuICBUeXBlZEFycmF5UHJvdG90eXBlJDEgPSBUeXBlZEFycmF5JDEucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsJDdbTkFNRV0pIHNldFByb3RvdHlwZU9mJDMoZ2xvYmFsJDdbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlJDEpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIGdldFByb3RvdHlwZU9mJDEoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUpICE9PSBUeXBlZEFycmF5UHJvdG90eXBlJDEpIHtcbiAgc2V0UHJvdG90eXBlT2YkMyhVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSQxKTtcbn1cblxuaWYgKERFU0NSSVBUT1JTJDIgJiYgIWhhc093biQxKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lUHJvcGVydHkkMShUeXBlZEFycmF5UHJvdG90eXBlJDEsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0JDQodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBRyQxXSA6IHVuZGVmaW5lZDtcbiAgfSB9KTtcbiAgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoZ2xvYmFsJDdbTkFNRV0pIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyhnbG9iYWwkN1tOQU1FXSwgVFlQRURfQVJSQVlfVEFHJDEsIE5BTUUpO1xuICB9XG59XG5cbnZhciBhcnJheUJ1ZmZlclZpZXdDb3JlID0ge1xuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIsXG4gIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyQxLFxuICBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXkkNCxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyLFxuICBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDQsXG4gIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSxcbiAgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gIGlzVmlldzogaXNWaWV3LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSQxLFxuICBUeXBlZEFycmF5OiBUeXBlZEFycmF5JDEsXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGUkMVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBnbG9iYWwkNiA9IGdsb2JhbCR0O1xudmFyIGZhaWxzJDggPSBmYWlscyRzO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcblxudmFyIEFycmF5QnVmZmVyJDMgPSBnbG9iYWwkNi5BcnJheUJ1ZmZlcjtcbnZhciBJbnQ4QXJyYXkkMyA9IGdsb2JhbCQ2LkludDhBcnJheTtcblxudmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnMgPSAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQxIHx8ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5JDMoMSk7XG59KSB8fCAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIG5ldyBJbnQ4QXJyYXkkMygtMSk7XG59KSB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBuZXcgSW50OEFycmF5JDMoKTtcbiAgbmV3IEludDhBcnJheSQzKG51bGwpO1xuICBuZXcgSW50OEFycmF5JDMoMS41KTtcbiAgbmV3IEludDhBcnJheSQzKGl0ZXJhYmxlKTtcbn0sIHRydWUpIHx8IGZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgKDExKykgYnVnIC0gYSByZWFzb24gd2h5IGV2ZW4gU2FmYXJpIDEzIHNob3VsZCBsb2FkIGEgdHlwZWQgYXJyYXkgcG9seWZpbGxcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkkMyhuZXcgQXJyYXlCdWZmZXIkMygyKSwgMSwgdW5kZWZpbmVkKS5sZW5ndGggIT09IDE7XG59KTtcblxudmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQ1ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHRvT2JqZWN0JDIgPSB0b09iamVjdCQ3O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMjtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG52YXIgdHlwZWRBcnJheUZyb20kMiA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIEMgPSBhQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBPID0gdG9PYmplY3QkMihzb3VyY2UpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGksIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dDtcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICFpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSB7XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgTyA9IFtdO1xuICAgIHdoaWxlICghKHN0ZXAgPSBjYWxsJDUobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgICBPLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXBwaW5nICYmIGFyZ3VtZW50c0xlbmd0aCA+IDIpIHtcbiAgICBtYXBmbiA9IGJpbmQkMShtYXBmbiwgYXJndW1lbnRzWzJdKTtcbiAgfVxuICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ0KE8pO1xuICByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMShDKSkobGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMkMSA9IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnM7XG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDtcbnZhciB0eXBlZEFycmF5RnJvbSQxID0gdHlwZWRBcnJheUZyb20kMjtcblxuLy8gYCVUeXBlZEFycmF5JS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLmZyb21cbmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QoJ2Zyb20nLCB0eXBlZEFycmF5RnJvbSQxLCBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDEpO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiQ4O1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluJDEodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG52YXIgdG9MZW5ndGgkNCA9IHRvTGVuZ3RoJDY7XG5cbnZhciAkUmFuZ2VFcnJvciQyID0gUmFuZ2VFcnJvcjtcblxuLy8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbmRleCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMyhpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aCQ0KG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgJFJhbmdlRXJyb3IkMignV3JvbmcgbGVuZ3RoIG9yIGluZGV4Jyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyICRBcnJheSQyID0gQXJyYXk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbnZhciBwYWNrID0gZnVuY3Rpb24gKG51bWJlciwgbWFudGlzc2FMZW5ndGgsIGJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSAkQXJyYXkkMihieXRlcyk7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1hbnRpc3NhTGVuZ3RoID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgfHwgbnVtYmVyID09PSAwICYmIDEgLyBudW1iZXIgPCAwID8gMSA6IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBleHBvbmVudCwgbWFudGlzc2EsIGM7XG4gIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICBpZiAobnVtYmVyICE9IG51bWJlciB8fCBudW1iZXIgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBtYW50aXNzYSA9IG51bWJlciAhPSBudW1iZXIgPyAxIDogMDtcbiAgICBleHBvbmVudCA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZXhwb25lbnQgPSBmbG9vciQyKGxvZyhudW1iZXIpIC8gTE4yKTtcbiAgICBjID0gcG93KDIsIC1leHBvbmVudCk7XG4gICAgaWYgKG51bWJlciAqIGMgPCAxKSB7XG4gICAgICBleHBvbmVudC0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBudW1iZXIgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciAqIGMgPj0gMikge1xuICAgICAgZXhwb25lbnQrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbWFudGlzc2EgPSAwO1xuICAgICAgZXhwb25lbnQgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtYW50aXNzYSA9IChudW1iZXIgKiBjIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW50aXNzYSA9IG51bWJlciAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG1hbnRpc3NhTGVuZ3RoID49IDgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NTtcbiAgICBtYW50aXNzYSAvPSAyNTY7XG4gICAgbWFudGlzc2FMZW5ndGggLT0gODtcbiAgfVxuICBleHBvbmVudCA9IGV4cG9uZW50IDw8IG1hbnRpc3NhTGVuZ3RoIHwgbWFudGlzc2E7XG4gIGV4cG9uZW50TGVuZ3RoICs9IG1hbnRpc3NhTGVuZ3RoO1xuICB3aGlsZSAoZXhwb25lbnRMZW5ndGggPiAwKSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTU7XG4gICAgZXhwb25lbnQgLz0gMjU2O1xuICAgIGV4cG9uZW50TGVuZ3RoIC09IDg7XG4gIH1cbiAgYnVmZmVyWy0taW5kZXhdIHw9IHNpZ24gKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG52YXIgdW5wYWNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFudGlzc2FMZW5ndGgpIHtcbiAgdmFyIGJ5dGVzID0gYnVmZmVyLmxlbmd0aDtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZXhwb25lbnRMZW5ndGggLSA3O1xuICB2YXIgaW5kZXggPSBieXRlcyAtIDE7XG4gIHZhciBzaWduID0gYnVmZmVyW2luZGV4LS1dO1xuICB2YXIgZXhwb25lbnQgPSBzaWduICYgMTI3O1xuICB2YXIgbWFudGlzc2E7XG4gIHNpZ24gPj49IDc7XG4gIHdoaWxlIChuQml0cyA+IDApIHtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50ICogMjU2ICsgYnVmZmVyW2luZGV4LS1dO1xuICAgIG5CaXRzIC09IDg7XG4gIH1cbiAgbWFudGlzc2EgPSBleHBvbmVudCAmICgxIDw8IC1uQml0cykgLSAxO1xuICBleHBvbmVudCA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtYW50aXNzYUxlbmd0aDtcbiAgd2hpbGUgKG5CaXRzID4gMCkge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKiAyNTYgKyBidWZmZXJbaW5kZXgtLV07XG4gICAgbkJpdHMgLT0gODtcbiAgfVxuICBpZiAoZXhwb25lbnQgPT09IDApIHtcbiAgICBleHBvbmVudCA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gZU1heCkge1xuICAgIHJldHVybiBtYW50aXNzYSA/IE5hTiA6IHNpZ24gPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtYW50aXNzYSA9IG1hbnRpc3NhICsgcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzaWduID8gLTEgOiAxKSAqIG1hbnRpc3NhICogcG93KDIsIGV4cG9uZW50IC0gbWFudGlzc2FMZW5ndGgpO1xufTtcblxudmFyIGllZWU3NTQgPSB7XG4gIHBhY2s6IHBhY2ssXG4gIHVucGFjazogdW5wYWNrXG59O1xuXG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDc7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDIgPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbnZhciBhcnJheUZpbGwkMSA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCQxKHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQyKGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgkMihlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDEoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCQxID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBjcmVhdGVQcm9wZXJ0eSQxO1xuXG52YXIgJEFycmF5JDEgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgkMShzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQxKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gJEFycmF5JDEobWF4KGZpbiAtIGssIDApKTtcbiAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICByZXN1bHQubGVuZ3RoID0gbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnbG9iYWwkNSA9IGdsb2JhbCR0O1xudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gYXJyYXlCdWZmZXJOYXRpdmU7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSBkZWZpbmVCdWlsdElucyQxO1xudmFyIGZhaWxzJDcgPSBmYWlscyRzO1xudmFyIGFuSW5zdGFuY2UkMSA9IGFuSW5zdGFuY2UkMztcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG52YXIgdG9MZW5ndGgkMyA9IHRvTGVuZ3RoJDY7XG52YXIgdG9JbmRleCQxID0gdG9JbmRleCQyO1xudmFyIElFRUU3NTQgPSBpZWVlNzU0O1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgYXJyYXlGaWxsID0gYXJyYXlGaWxsJDE7XG52YXIgYXJyYXlTbGljZSQzID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuc2V0O1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEgkMSA9ICdXcm9uZyBsZW5ndGgnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbCQ1W0FSUkFZX0JVRkZFUl07XG52YXIgJEFycmF5QnVmZmVyID0gTmF0aXZlQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSA9ICRBcnJheUJ1ZmZlciAmJiAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWwkNVtEQVRBX1ZJRVddO1xudmFyIERhdGFWaWV3UHJvdG90eXBlJDEgPSAkRGF0YVZpZXcgJiYgJERhdGFWaWV3W1BST1RPVFlQRV07XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBBcnJheSQxID0gZ2xvYmFsJDUuQXJyYXk7XG52YXIgUmFuZ2VFcnJvciQzID0gZ2xvYmFsJDUuUmFuZ2VFcnJvcjtcbnZhciBmaWxsID0gdW5jdXJyeVRoaXMkNyhhcnJheUZpbGwpO1xudmFyIHJldmVyc2UgPSB1bmN1cnJ5VGhpcyQ3KFtdLnJldmVyc2UpO1xuXG52YXIgcGFja0lFRUU3NTQgPSBJRUVFNzU0LnBhY2s7XG52YXIgdW5wYWNrSUVFRTc1NCA9IElFRUU3NTQudW5wYWNrO1xuXG52YXIgcGFja0ludDggPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDE2ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRiwgbnVtYmVyID4+IDE2ICYgMHhGRiwgbnVtYmVyID4+IDI0ICYgMHhGRl07XG59O1xuXG52YXIgdW5wYWNrSW50MzIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXJbM10gPDwgMjQgfCBidWZmZXJbMl0gPDwgMTYgfCBidWZmZXJbMV0gPDwgOCB8IGJ1ZmZlclswXTtcbn07XG5cbnZhciBwYWNrRmxvYXQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgMjMsIDQpO1xufTtcblxudmFyIHBhY2tGbG9hdDY0ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XG59O1xuXG52YXIgYWRkR2V0dGVyJDEgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGtleSkge1xuICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvcltQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcylba2V5XTsgfSB9KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4JDEoaW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBhcnJheVNsaWNlJDMoYnl0ZXMsIHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHJldmVyc2UocGFjayk7XG59O1xuXG52YXIgc2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgkMShpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUkMSh2aWV3KTtcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlJDEoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSBieXRlc1tzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBjb3VudCAtIGkgLSAxXTtcbn07XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlJDEodGhpcywgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4JDEobGVuZ3RoKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgICAgYnl0ZXM6IGZpbGwoQXJyYXkkMShieXRlTGVuZ3RoKSwgMCksXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUyQxKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIEFycmF5QnVmZmVyUHJvdG90eXBlJDEgPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlJDEodGhpcywgRGF0YVZpZXdQcm90b3R5cGUkMSk7XG4gICAgYW5JbnN0YW5jZSQxKGJ1ZmZlciwgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUkMShidWZmZXIpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlck9ySW5maW5pdHkkMihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMygnV3Jvbmcgb2Zmc2V0Jyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoJDMoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMyhXUk9OR19MRU5HVEgkMSk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkMSkge1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICBEYXRhVmlld1Byb3RvdHlwZSQxID0gJERhdGFWaWV3W1BST1RPVFlQRV07XG5cbiAgaWYgKERFU0NSSVBUT1JTJDEpIHtcbiAgICBhZGRHZXR0ZXIkMSgkQXJyYXlCdWZmZXIsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyJDEoJERhdGFWaWV3LCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyJDEoJERhdGFWaWV3LCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J5dGVPZmZzZXQnKTtcbiAgfVxuXG4gIGRlZmluZUJ1aWx0SW5zKERhdGFWaWV3UHJvdG90eXBlJDEsIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCAyMyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDUyKTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0NjQsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHZhciBJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBOYXRpdmVBcnJheUJ1ZmZlci5uYW1lICE9PSBBUlJBWV9CVUZGRVI7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICBpZiAoIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKC0xKTtcbiAgfSkgfHwgZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKCk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDEuNSk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKE5hTik7XG4gICAgcmV0dXJuIElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiAhQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUU7XG4gIH0pKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlJDEodGhpcywgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKHRvSW5kZXgkMShsZW5ndGgpKTtcbiAgICB9O1xuXG4gICAgJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBBcnJheUJ1ZmZlclByb3RvdHlwZSQxO1xuXG4gICAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMkMShOYXRpdmVBcnJheUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIoJEFycmF5QnVmZmVyLCBrZXksIE5hdGl2ZUFycmF5QnVmZmVyW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFycmF5QnVmZmVyUHJvdG90eXBlJDEuY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH0gZWxzZSBpZiAoSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FICYmIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIoTmF0aXZlQXJyYXlCdWZmZXIsICduYW1lJywgQVJSQVlfQlVGRkVSKTtcbiAgfVxuXG4gIC8vIFdlYktpdCBidWcgLSB0aGUgc2FtZSBwYXJlbnQgcHJvdG90eXBlIGZvciB0eXBlZCBhcnJheXMgYW5kIGRhdGEgdmlld1xuICBpZiAoc2V0UHJvdG90eXBlT2YkMiAmJiBnZXRQcm90b3R5cGVPZihEYXRhVmlld1Byb3RvdHlwZSQxKSAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgc2V0UHJvdG90eXBlT2YkMihEYXRhVmlld1Byb3RvdHlwZSQxLCBPYmplY3RQcm90b3R5cGUpO1xuICB9XG5cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9IHVuY3VycnlUaGlzJDcoRGF0YVZpZXdQcm90b3R5cGUkMS5zZXRJbnQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIGRlZmluZUJ1aWx0SW5zKERhdGFWaWV3UHJvdG90eXBlJDEsIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4KHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5cbnZhciBhcnJheUJ1ZmZlciA9IHtcbiAgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcixcbiAgRGF0YVZpZXc6ICREYXRhVmlld1xufTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNiA9IGZhaWxzJHM7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUkMSA9IGFycmF5QnVmZmVyO1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRlO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIHRvTGVuZ3RoJDIgPSB0b0xlbmd0aCQ2O1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciQxID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG5cbnZhciBBcnJheUJ1ZmZlciQyID0gQXJyYXlCdWZmZXJNb2R1bGUkMS5BcnJheUJ1ZmZlcjtcbnZhciBEYXRhVmlldyQyID0gQXJyYXlCdWZmZXJNb2R1bGUkMS5EYXRhVmlldztcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3JDIucHJvdG90eXBlO1xudmFyIHVuJEFycmF5QnVmZmVyU2xpY2UgPSB1bmN1cnJ5VGhpcyQ2KEFycmF5QnVmZmVyJDIucHJvdG90eXBlLnNsaWNlKTtcbnZhciBnZXRVaW50OCA9IHVuY3VycnlUaGlzJDYoRGF0YVZpZXdQcm90b3R5cGUuZ2V0VWludDgpO1xudmFyIHNldFVpbnQ4ID0gdW5jdXJyeVRoaXMkNihEYXRhVmlld1Byb3RvdHlwZS5zZXRVaW50OCk7XG5cbnZhciBJTkNPUlJFQ1RfU0xJQ0UgPSBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgQXJyYXlCdWZmZXIkMigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS5zbGljZVxuJCQxKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSwgdW5zYWZlOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9TTElDRSB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHVuJEFycmF5QnVmZmVyU2xpY2UgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1biRBcnJheUJ1ZmZlclNsaWNlKGFuT2JqZWN0JDIodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhbk9iamVjdCQyKHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yJDEodGhpcywgQXJyYXlCdWZmZXIkMikpKHRvTGVuZ3RoJDIoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1NvdXJjZSA9IG5ldyBEYXRhVmlldyQyKHRoaXMpO1xuICAgIHZhciB2aWV3VGFyZ2V0ID0gbmV3IERhdGFWaWV3JDIocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgc2V0VWludDgodmlld1RhcmdldCwgaW5kZXgrKywgZ2V0VWludDgodmlld1NvdXJjZSwgZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JGQ7XG5cbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblxuLy8gYElzSW50ZWdyYWxOdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2ludGVncmFsbnVtYmVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1udW1iZXItaXNpbnRlZ2VyIC0tIHNhZmVcbnZhciBpc0ludGVncmFsTnVtYmVyJDEgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0JDMoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vciQxKGl0KSA9PT0gaXQ7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xuXG52YXIgJFJhbmdlRXJyb3IkMSA9IFJhbmdlRXJyb3I7XG5cbnZhciB0b1Bvc2l0aXZlSW50ZWdlciQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSB0b0ludGVnZXJPckluZmluaXR5JDEoaXQpO1xuICBpZiAocmVzdWx0IDwgMCkgdGhyb3cgJFJhbmdlRXJyb3IkMShcIlRoZSBhcmd1bWVudCBjYW4ndCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IHRvUG9zaXRpdmVJbnRlZ2VyJDE7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbnZhciB0b09mZnNldCQyID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICB2YXIgb2Zmc2V0ID0gdG9Qb3NpdGl2ZUludGVnZXIoaXQpO1xuICBpZiAob2Zmc2V0ICUgQllURVMpIHRocm93ICRSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbnZhciBjbGFzc29mJDMgPSBjbGFzc29mUmF3JDE7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mJDMoYXJndW1lbnQpID09ICdBcnJheSc7XG59O1xuXG52YXIgaXNBcnJheSA9IGlzQXJyYXkkMTtcbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRkO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0JDIoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVMkMV07XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDc7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDE7XG5cbnZhciBwdXNoJDEgPSB1bmN1cnJ5VGhpcyQ1KFtdLnB1c2gpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoc2VsZik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2gkMSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaCQxKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kJDEoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kJDEoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDEoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kJDEoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kJDEoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDEoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kJDEoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kJDEoNylcbn07XG5cbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JGQ7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG52YXIgaW5oZXJpdElmUmVxdWlyZWQkMSA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YkMSAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICBpc0NhbGxhYmxlJDEoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QkMShOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZiQxKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkdDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDQgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlID0gYXJyYXlCdWZmZXI7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMztcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGlzSW50ZWdyYWxOdW1iZXIgPSBpc0ludGVncmFsTnVtYmVyJDE7XG52YXIgdG9MZW5ndGgkMSA9IHRvTGVuZ3RoJDY7XG52YXIgdG9JbmRleCA9IHRvSW5kZXgkMjtcbnZhciB0b09mZnNldCQxID0gdG9PZmZzZXQkMjtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiQ5O1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkZDtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDM7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciB0eXBlZEFycmF5RnJvbSA9IHR5cGVkQXJyYXlGcm9tJDI7XG52YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IGluaGVyaXRJZlJlcXVpcmVkJDE7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgUmFuZ2VFcnJvciQyID0gZ2xvYmFsJDQuUmFuZ2VFcnJvcjtcbnZhciBBcnJheUJ1ZmZlciQxID0gQXJyYXlCdWZmZXJNb2R1bGUuQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSBBcnJheUJ1ZmZlciQxLnByb3RvdHlwZTtcbnZhciBEYXRhVmlldyQxID0gQXJyYXlCdWZmZXJNb2R1bGUuRGF0YVZpZXc7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5UWVBFRF9BUlJBWV9UQUc7XG52YXIgVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5UeXBlZEFycmF5O1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVHlwZWRBcnJheVByb3RvdHlwZTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgaXNUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LmlzVHlwZWRBcnJheTtcbnZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG5cbnZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuICB9IH0pO1xufTtcblxudmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGtsYXNzO1xuICByZXR1cm4gaXNQcm90b3R5cGVPZihBcnJheUJ1ZmZlclByb3RvdHlwZSwgaXQpIHx8IChrbGFzcyA9IGNsYXNzb2YkMihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcbn07XG5cbnZhciBpc1R5cGVkQXJyYXlJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5KHRhcmdldClcbiAgICAmJiAhaXNTeW1ib2woa2V5KVxuICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAmJiBpc0ludGVncmFsTnVtYmVyKCtrZXkpXG4gICAgJiYga2V5ID49IDA7XG59O1xuXG52YXIgd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSlcbiAgICA/IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigyLCB0YXJnZXRba2V5XSlcbiAgICA6IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG59O1xuXG52YXIgd3JhcHBlZERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkpXG4gICAgJiYgaXNPYmplY3QoZGVzY3JpcHRvcilcbiAgICAmJiBoYXNPd24oZGVzY3JpcHRvciwgJ3ZhbHVlJylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdnZXQnKVxuICAgICYmICFoYXNPd24oZGVzY3JpcHRvciwgJ3NldCcpXG4gICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGVcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKVxuICAgICYmICghaGFzT3duKGRlc2NyaXB0b3IsICdlbnVtZXJhYmxlJykgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlKVxuICApIHtcbiAgICB0YXJnZXRba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xufTtcblxuaWYgKERFU0NSSVBUT1JTKSB7XG4gIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gd3JhcHBlZERlZmluZVByb3BlcnR5O1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlT2Zmc2V0Jyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdsZW5ndGgnKTtcbiAgfVxuXG4gICQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxuICB9KTtcblxuICB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIEJZVEVTID0gVFlQRS5tYXRjaCgvXFxkKyQvKVswXSAvIDg7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDRbQ09OU1RSVUNUT1JfTkFNRV07XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICByZXR1cm4gZGF0YS52aWV3W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSByb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aDtcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlciQxKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIGJ5dGVPZmZzZXQgPSB0b09mZnNldCQxKG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoJDEoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwkNCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3JDEoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoVHlwZWRBcnJheVByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5oZXJpdElmUmVxdWlyZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICAgIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQkMSh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6IHR5cGVkQXJyYXlPZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQkMSh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhKTtcbiAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgICByZXR1cm4gY2FsbCQ0KHR5cGVkQXJyYXlGcm9tLCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9KCksIGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIGZvckVhY2goZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBrZXksIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUuY29uc3RydWN0b3IgIT09IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGVuZm9yY2VJbnRlcm5hbFN0YXRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkuVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKFRZUEVEX0FSUkFZX1RBRykge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBUWVBFRF9BUlJBWV9UQUcsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgIH1cblxuICAgIHZhciBGT1JDRUQgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgIT0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIGV4cG9ydGVkKTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfTtcbn0gZWxzZSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIGNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgVWludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG4vLyBgVG9CaWdJbnRgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2JpZ2ludFxudmFyIHRvQmlnSW50JDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICBpZiAodHlwZW9mIHByaW0gPT0gJ251bWJlcicpIHRocm93ICRUeXBlRXJyb3IkMShcIkNhbid0IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYmlnaW50IC0tIHNhZmVcbiAgcmV0dXJuIEJpZ0ludChwcmltKTtcbn07XG5cbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDMgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyICRmaWxsID0gYXJyYXlGaWxsJDE7XG52YXIgdG9CaWdJbnQgPSB0b0JpZ0ludCQxO1xudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2YkOTtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNSA9IGZhaWxzJHM7XG5cbnZhciBhVHlwZWRBcnJheSQzID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQzLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMyA9IEFycmF5QnVmZmVyVmlld0NvcmUkMy5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMkNCgnJy5zbGljZSk7XG5cbi8vIFY4IH4gQ2hyb21lIDwgNTksIFNhZmFyaSA8IDE0LjEsIEZGIDwgNTUsIEVkZ2UgPD0xOFxudmFyIENPTlZFUlNJT05fQlVHID0gZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG4gIG5ldyBJbnQ4QXJyYXkoMikuZmlsbCh7IHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50Kys7IH0gfSk7XG4gIHJldHVybiBjb3VudCAhPT0gMTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kJDMoJ2ZpbGwnLCBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgYVR5cGVkQXJyYXkkMyh0aGlzKTtcbiAgdmFyIGFjdHVhbFZhbHVlID0gc2xpY2UoY2xhc3NvZiQxKHRoaXMpLCAwLCAzKSA9PT0gJ0JpZycgPyB0b0JpZ0ludCh2YWx1ZSkgOiArdmFsdWU7XG4gIHJldHVybiBjYWxsJDMoJGZpbGwsIHRoaXMsIGFjdHVhbFZhbHVlLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbn0sIENPTlZFUlNJT05fQlVHKTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkMiA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIHRvT2Zmc2V0ID0gdG9PZmZzZXQkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b09iamVjdCQ3O1xudmFyIGZhaWxzJDQgPSBmYWlscyRzO1xuXG52YXIgUmFuZ2VFcnJvciQxID0gZ2xvYmFsJDMuUmFuZ2VFcnJvcjtcbnZhciBJbnQ4QXJyYXkkMiA9IGdsb2JhbCQzLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkkMiAmJiBJbnQ4QXJyYXkkMi5wcm90b3R5cGU7XG52YXIgJHNldCA9IEludDhBcnJheVByb3RvdHlwZSAmJiBJbnQ4QXJyYXlQcm90b3R5cGUuc2V0O1xudmFyIGFUeXBlZEFycmF5JDIgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDIuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQyID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQyLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbnZhciBXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMgPSAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoMik7XG4gIGNhbGwkMigkc2V0LCBhcnJheSwgeyBsZW5ndGg6IDEsIDA6IDMgfSwgMSk7XG4gIHJldHVybiBhcnJheVsxXSAhPT0gMztcbn0pO1xuXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMTI5NCBhbmQgb3RoZXJcbnZhciBUT19PQkpFQ1RfQlVHID0gV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTICYmIEFycmF5QnVmZmVyVmlld0NvcmUkMi5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBuZXcgSW50OEFycmF5JDIoMik7XG4gIGFycmF5LnNldCgxKTtcbiAgYXJyYXkuc2V0KCcyJywgMSk7XG4gIHJldHVybiBhcnJheVswXSAhPT0gMCB8fCBhcnJheVsxXSAhPT0gMjtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNldFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQyKCdzZXQnLCBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gIGFUeXBlZEFycmF5JDIodGhpcyk7XG4gIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMSk7XG4gIHZhciBzcmMgPSB0b0luZGV4ZWRPYmplY3QoYXJyYXlMaWtlKTtcbiAgaWYgKFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUykgcmV0dXJuIGNhbGwkMigkc2V0LCB0aGlzLCBzcmMsIG9mZnNldCk7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKHNyYyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMSgnV3JvbmcgbGVuZ3RoJyk7XG4gIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG59LCAhV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTIHx8IFRPX09CSkVDVF9CVUcpO1xuXG52YXIgYXJyYXlTbGljZSQyID0gYXJyYXlTbGljZVNpbXBsZTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQyKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gIHZhciBsbGVuZ3RoID0gbGVmdC5sZW5ndGg7XG4gIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICB2YXIgbGluZGV4ID0gMDtcbiAgdmFyIHJpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK11cbiAgICAgIDogbGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdO1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheVNvcnQgPSBtZXJnZVNvcnQ7XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQkMS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxudmFyIGVuZ2luZUZmVmVyc2lvbiA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcblxudmFyIFVBID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJZU9yRWRnZSA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG52YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbnZhciBnbG9iYWwkMiA9IGdsb2JhbCR0O1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDMgPSBmYWlscyRzO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ5O1xudmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIEZGID0gZW5naW5lRmZWZXJzaW9uO1xudmFyIElFX09SX0VER0UgPSBlbmdpbmVJc0llT3JFZGdlO1xudmFyIFY4ID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIFdFQktJVCA9IGVuZ2luZVdlYmtpdFZlcnNpb247XG5cbnZhciBhVHlwZWRBcnJheSQxID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQxLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMSA9IEFycmF5QnVmZmVyVmlld0NvcmUkMS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIFVpbnQxNkFycmF5ID0gZ2xvYmFsJDIuVWludDE2QXJyYXk7XG52YXIgdW4kU29ydCA9IFVpbnQxNkFycmF5ICYmIHVuY3VycnlUaGlzJDMoVWludDE2QXJyYXkucHJvdG90eXBlLnNvcnQpO1xuXG4vLyBXZWJLaXRcbnZhciBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyA9ICEhdW4kU29ydCAmJiAhKGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICB1biRTb3J0KG5ldyBVaW50MTZBcnJheSgyKSwgbnVsbCk7XG59KSAmJiBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdW4kU29ydChuZXcgVWludDE2QXJyYXkoMiksIHt9KTtcbn0pKTtcblxudmFyIFNUQUJMRV9TT1JUID0gISF1biRTb3J0ICYmICFmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzQ7XG4gIGlmIChGRikgcmV0dXJuIEZGIDwgNjc7XG4gIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFdFQktJVCkgcmV0dXJuIFdFQktJVCA8IDYwMjtcblxuICB2YXIgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoNTE2KTtcbiAgdmFyIGV4cGVjdGVkID0gQXJyYXkoNTE2KTtcbiAgdmFyIGluZGV4LCBtb2Q7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNTE2OyBpbmRleCsrKSB7XG4gICAgbW9kID0gaW5kZXggJSA0O1xuICAgIGFycmF5W2luZGV4XSA9IDUxNSAtIGluZGV4O1xuICAgIGV4cGVjdGVkW2luZGV4XSA9IGluZGV4IC0gMiAqIG1vZCArIDM7XG4gIH1cblxuICB1biRTb3J0KGFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYSAvIDQgfCAwKSAtIChiIC8gNCB8IDApO1xuICB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA1MTY7IGluZGV4KyspIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdICE9PSBleHBlY3RlZFtpbmRleF0pIHJldHVybiB0cnVlO1xuICB9XG59KTtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoeSAhPT0geSkgcmV0dXJuIC0xO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKHggIT09IHgpIHJldHVybiAxO1xuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHJldHVybiAxIC8geCA+IDAgJiYgMSAvIHkgPCAwID8gMSA6IC0xO1xuICAgIHJldHVybiB4ID4geTtcbiAgfTtcbn07XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMSgnc29ydCcsIGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlKGNvbXBhcmVmbik7XG4gIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIHVuJFNvcnQodGhpcywgY29tcGFyZWZuKTtcblxuICByZXR1cm4gaW50ZXJuYWxTb3J0KGFUeXBlZEFycmF5JDEodGhpcyksIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xufSwgIVNUQUJMRV9TT1JUIHx8IEFDQ0VQVF9JTkNPUlJFQ1RfQVJHVU1FTlRTKTtcblxudmFyIGdsb2JhbCQxID0gZ2xvYmFsJHQ7XG52YXIgYXBwbHkkMSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgZmFpbHMkMiA9IGZhaWxzJHM7XG52YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZSQ1O1xuXG52YXIgSW50OEFycmF5JDEgPSBnbG9iYWwkMS5JbnQ4QXJyYXk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgJHRvTG9jYWxlU3RyaW5nID0gW10udG9Mb2NhbGVTdHJpbmc7XG5cbi8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbnZhciBUT19MT0NBTEVfU1RSSU5HX0JVRyA9ICEhSW50OEFycmF5JDEgJiYgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gICR0b0xvY2FsZVN0cmluZy5jYWxsKG5ldyBJbnQ4QXJyYXkkMSgxKSk7XG59KTtcblxudmFyIEZPUkNFRCA9IGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IEludDhBcnJheSQxKFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbn0pIHx8ICFmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5JDEucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUudG9sb2NhbGVzdHJpbmdcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3RvTG9jYWxlU3RyaW5nJywgZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gIHJldHVybiBhcHBseSQxKFxuICAgICR0b0xvY2FsZVN0cmluZyxcbiAgICBUT19MT0NBTEVfU1RSSU5HX0JVRyA/IGFycmF5U2xpY2UkMShhVHlwZWRBcnJheSh0aGlzKSkgOiBhVHlwZWRBcnJheSh0aGlzKSxcbiAgICBhcnJheVNsaWNlJDEoYXJndW1lbnRzKVxuICApO1xufSwgRk9SQ0VEKTtcblxuY2xhc3MgUGF5bG9hZCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAvLyBUaGUgdGFnJ3MgdmFsdWUgaXMgYSBoYXJkY29kZWQgdmFsdWUgYXMgcGVyXG4gICAgLy8gZGVmaW5lZCBpbiB0aGUgTkVQIFtORVA0MTNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL05FUHMvYmxvYi9tYXN0ZXIvbmVwcy9uZXAtMDQxMy5tZClcbiAgICB0aGlzLnRhZyA9IDIxNDc0ODQwNjE7XG4gICAgdGhpcy5tZXNzYWdlID0gZGF0YS5tZXNzYWdlO1xuICAgIHRoaXMubm9uY2UgPSBkYXRhLm5vbmNlO1xuICAgIHRoaXMucmVjaXBpZW50ID0gZGF0YS5yZWNpcGllbnQ7XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tVcmwpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tVcmwgPSBkYXRhLmNhbGxiYWNrVXJsO1xuICAgIH1cbiAgfVxufVxuY29uc3QgcGF5bG9hZFNjaGVtYSA9IG5ldyBNYXAoW1tQYXlsb2FkLCB7XG4gIGtpbmQ6IFwic3RydWN0XCIsXG4gIGZpZWxkczogW1tcInRhZ1wiLCBcInUzMlwiXSwgW1wibWVzc2FnZVwiLCBcInN0cmluZ1wiXSwgW1wibm9uY2VcIiwgWzMyXV0sIFtcInJlY2lwaWVudFwiLCBcInN0cmluZ1wiXSwgW1wiY2FsbGJhY2tVcmxcIiwge1xuICAgIGtpbmQ6IFwib3B0aW9uXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9XV1cbn1dXSk7XG5jb25zdCBzZXJpYWxpemVOZXA0MTMgPSBzaWduTWVzc2FnZVBhcmFtcyA9PiB7XG4gIGNvbnN0IHBheWxvYWQgPSBuZXcgUGF5bG9hZChPYmplY3QuYXNzaWduKHt9LCBzaWduTWVzc2FnZVBhcmFtcykpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplKHBheWxvYWRTY2hlbWEsIHBheWxvYWQpKTtcbn07XG5cbmNvbnN0IHZlcmlmeVNpZ25hdHVyZSA9ICh7XG4gIHB1YmxpY0tleSxcbiAgc2lnbmF0dXJlLFxuICBtZXNzYWdlLFxuICBub25jZSxcbiAgcmVjaXBpZW50LFxuICBjYWxsYmFja1VybFxufSkgPT4ge1xuICAvLyBSZWNvbnN0cnVjdCB0aGUgcGF5bG9hZCB0aGF0IHdhcyAqKmFjdHVhbGx5IHNpZ25lZCoqXG4gIGNvbnN0IHBheWxvYWQgPSBuZXcgUGF5bG9hZCh7XG4gICAgbWVzc2FnZSxcbiAgICBub25jZSxcbiAgICByZWNpcGllbnQsXG4gICAgY2FsbGJhY2tVcmxcbiAgfSk7XG4gIC8vIFNlcmlhbGl6ZSBwYXlsb2FkIGJhc2VkIG9uIHBheWxvYWRTY2hlbWFcbiAgY29uc3QgYm9yc2hQYXlsb2FkID0gc2VyaWFsaXplKHBheWxvYWRTY2hlbWEsIHBheWxvYWQpO1xuICAvLyBIYXNoIHRoZSBwYXlsb2FkIGFzIGluIHRoZSBORVAwNDEzIHJlZmVyZW5jZWQgZXhhbXBsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmVhci9ORVBzL2Jsb2IvbWFzdGVyL25lcHMvbmVwLTA0MTMubWQjcmVmZXJlbmNlc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2FnZGllei9uZWFyLWxvZ2luL2Jsb2IvbWFpbi9hdXRoZW50aWNhdGUvd2FsbGV0LWF1dGhlbnRpY2F0ZS5qcyNMMjFcbiAgY29uc3QgaGFzaGVkUGF5bG9hZCA9IFVpbnQ4QXJyYXkuZnJvbShzaGEyNTYuYXJyYXkoYm9yc2hQYXlsb2FkKSk7XG4gIC8vIENvbnZlcnQgcmVhbCBzaWduYXR1cmUgdG8gYnVmZmVyIGJhc2U2NFxuICBjb25zdCByZWFsU2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLCBcImJhc2U2NFwiKTtcbiAgY29uc3QgcGsgPSB1dGlscy5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpO1xuICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZVxuICByZXR1cm4gcGsudmVyaWZ5KGhhc2hlZFBheWxvYWQsIHJlYWxTaWduYXR1cmUpO1xufTtcbmNvbnN0IGZldGNoQWxsVXNlcktleXMgPSAoe1xuICBhY2NvdW50SWQsXG4gIG5ldHdvcmssXG4gIHB1YmxpY0tleVxufSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIoe1xuICAgIHVybDogbmV0d29yay5ub2RlVXJsXG4gIH0pO1xuICBjb25zdCBrZXkgPSB5aWVsZCBwcm92aWRlci5xdWVyeSh7XG4gICAgcmVxdWVzdF90eXBlOiBcInZpZXdfYWNjZXNzX2tleVwiLFxuICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICBmaW5hbGl0eTogXCJmaW5hbFwiLFxuICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleVxuICB9KTtcbiAgcmV0dXJuIGtleTtcbn0pO1xuY29uc3QgdmVyaWZ5RnVsbEtleUJlbG9uZ3NUb1VzZXIgPSAoe1xuICBwdWJsaWNLZXksXG4gIGFjY291bnRJZCxcbiAgbmV0d29ya1xufSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBwZXJtaXNzaW9uXG4gIH0gPSB5aWVsZCBmZXRjaEFsbFVzZXJLZXlzKHtcbiAgICBhY2NvdW50SWQsXG4gICAgbmV0d29yayxcbiAgICBwdWJsaWNLZXlcbiAgfSk7XG4gIHJldHVybiBwZXJtaXNzaW9uID09PSBcIkZ1bGxBY2Nlc3NcIjtcbn0pO1xuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIG1vdmVkIHRvIGVudHJ5IHBvaW50c1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciByZWdleHBFeGVjJDIgPSByZWdleHBFeGVjJDM7XG52YXIgZmFpbHMkMSA9IGZhaWxzJHM7XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIGZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgRk9SQ0VELCBTSEFNKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgRk9SQ0VEXG4gICkge1xuICAgIHZhciB1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QgPSB1bmN1cnJ5VGhpcyQyKC8uL1tTWU1CT0xdKTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIHZhciB1bmN1cnJpZWROYXRpdmVNZXRob2QgPSB1bmN1cnJ5VGhpcyQyKG5hdGl2ZU1ldGhvZCk7XG4gICAgICB2YXIgJGV4ZWMgPSByZWdleHAuZXhlYztcbiAgICAgIGlmICgkZXhlYyA9PT0gcmVnZXhwRXhlYyQyIHx8ICRleGVjID09PSBSZWdFeHBQcm90b3R5cGUuZXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmN1cnJpZWROYXRpdmVNZXRob2Qoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuXG4gICAgZGVmaW5lQnVpbHRJbihTdHJpbmcucHJvdG90eXBlLCBLRVksIG1ldGhvZHNbMF0pO1xuICAgIGRlZmluZUJ1aWx0SW4oUmVnRXhwUHJvdG90eXBlLCBTWU1CT0wsIG1ldGhvZHNbMV0pO1xuICB9XG5cbiAgaWYgKFNIQU0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHBQcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xudmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQ1O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcblxudmFyIGNoYXJBdCQxID0gdW5jdXJyeVRoaXMkMSgnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyQxKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlJDEgPSB1bmN1cnJ5VGhpcyQxKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nJDEocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eShwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBjaGFyQXQkMShTLCBwb3NpdGlvbilcbiAgICAgICAgICA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IHN0cmluZ1NsaWNlJDEoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxudmFyIGNoYXJBdCA9IHN0cmluZ011bHRpYnl0ZS5jaGFyQXQ7XG5cbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXgkMSA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGNoYXJBdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuXG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRlO1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJG47XG52YXIgY2xhc3NvZiA9IGNsYXNzb2ZSYXckMTtcbnZhciByZWdleHBFeGVjJDEgPSByZWdleHBFeGVjJDM7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbnZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKGlzQ2FsbGFibGUoZXhlYykpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbCQxKGV4ZWMsIFIsIFMpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIGFuT2JqZWN0JDEocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjbGFzc29mKFIpID09PSAnUmVnRXhwJykgcmV0dXJuIGNhbGwkMShyZWdleHBFeGVjJDEsIFIsIFMpO1xuICB0aHJvdyAkVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG59O1xuXG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWM7XG52YXIgaXNSZWdFeHAgPSBpc1JlZ2V4cDtcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGU7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMztcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgkMTtcbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDY7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyQ1O1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQ0O1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlU2ltcGxlO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVnZXhwRXhlY0Fic3RyYWN0O1xudmFyIHJlZ2V4cEV4ZWMgPSByZWdleHBFeGVjJDM7XG52YXIgc3RpY2t5SGVscGVycyA9IHJlZ2V4cFN0aWNreUhlbHBlcnM7XG52YXIgZmFpbHMgPSBmYWlscyRzO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWTtcbnZhciBNQVhfVUlOVDMyID0gMHhGRkZGRkZGRjtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoJHB1c2gpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzcGxpdCcsIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9IDQgfHxcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9IDQgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aFxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW3N0cmluZ107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBjYWxsKG5hdGl2ZVNwbGl0LCBzdHJpbmcsIHNlcGFyYXRvciwgbGltKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gY2FsbChyZWdleHBFeGVjLCBzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJpbmdTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSBhcHBseSgkcHVzaCwgb3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIWV4ZWMoc2VwYXJhdG9yQ29weSwgJycpKSBwdXNoKG91dHB1dCwgJycpO1xuICAgICAgfSBlbHNlIHB1c2gob3V0cHV0LCBzdHJpbmdTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIGxpbSkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJy5zcGxpdCh1bmRlZmluZWQsIDApLmxlbmd0aCkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBjYWxsKG5hdGl2ZVNwbGl0LCB0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2UgaW50ZXJuYWxTcGxpdCA9IG5hdGl2ZVNwbGl0O1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBnZXRNZXRob2Qoc2VwYXJhdG9yLCBTUExJVCk7XG4gICAgICByZXR1cm4gc3BsaXR0ZXJcbiAgICAgICAgPyBjYWxsKHNwbGl0dGVyLCBzZXBhcmF0b3IsIE8sIGxpbWl0KVxuICAgICAgICA6IGNhbGwoaW50ZXJuYWxTcGxpdCwgdG9TdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIGxpbWl0KSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcngsIFMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSBuYXRpdmVTcGxpdCk7XG5cbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoVU5TVVBQT1JURURfWSA/ICdnJyA6ICd5Jyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhVTlNVUFBPUlRFRF9ZID8gJ14oPzonICsgcnguc291cmNlICsgJyknIDogcngsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBVTlNVUFBPUlRFRF9ZID8gMCA6IHE7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFVOU1VQUE9SVEVEX1kgPyBzdHJpbmdTbGljZShTLCBxKSA6IFMpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9IG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoVU5TVVBQT1JURURfWSA/IHEgOiAwKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2goQSwgc3RyaW5nU2xpY2UoUywgcCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcHVzaChBLCB6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdXNoKEEsIHN0cmluZ1NsaWNlKFMsIHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0sICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMsIFVOU1VQUE9SVEVEX1kpO1xuXG52YXIgbW9kYWwkYiA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiQ29ubmVjdCBZb3VyIFdhbGxldFwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwiV2hhdCBpcyBhIFdhbGxldD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiU2VjdXJlICYgTWFuYWdlIFlvdXIgRGlnaXRhbCBBc3NldHNcIixcblx0XHRzYWZlbHlTdG9yZTogXCJTYWZlbHkgc3RvcmUgYW5kIHRyYW5zZmVyIHlvdXIgY3J5cHRvIGFuZCBORlRzLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiTG9nIEluIHRvIEFueSBORUFSIEFwcFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5vIG5lZWQgdG8gY3JlYXRlIG5ldyBhY2NvdW50cyBvciBjcmVkZW50aWFscy4gQ29ubmVjdCB5b3VyIHdhbGxldCBhbmQgeW91IGFyZSBnb29kIHRvIGdvIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiR2V0IGEgV2FsbGV0XCIsXG5cdFx0dXNlQVdhbGxldDogXCJVc2UgYSB3YWxsZXQgdG8gc2VjdXJlIGFuZCBtYW5hZ2UgeW91ciBORUFSIGFzc2V0cywgYW5kIHRvIGxvZyBpbiB0byBhbnkgTkVBUiBhcHAgd2l0aG91dCB0aGUgbmVlZCBmb3IgdXNlcm5hbWVzIGFuZCBwYXNzd29yZHMuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCJDb25uZWN0aW9uIEZhaWxlZFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIkNvbm5lY3Rpb24gU3VjY2Vzc2Z1bFwiLFxuXHRcdGNvbm5lY3RlZDogXCJDb25uZWN0ZWRcIixcblx0XHRjb25uZWN0aW5nVG86IFwiQ29ubmVjdGluZyB0b1wiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSBleHRlbnNpb24gd2luZG93XCIsXG5cdFx0XHRicm93c2VyOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIHdhbGxldCBhZnRlciByZWRpcmVjdFwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgbGVkZ2VyIGRldmljZVwiLFxuXHRcdFx0YnJpZGdlOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIHdhbGxldFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJDb25uZWN0IHdpdGggTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIk1ha2Ugc3VyZSB5b3VyIExlZGdlciBpcyBjb25uZWN0ZWQgc2VjdXJlbHksIGFuZCB0aGF0IHRoZSBORUFSIGFwcCBpcyBvcGVuIG9uIHlvdXIgZGV2aWNlXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIkNvbnRpbnVlXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJTcGVjaWZ5IEhEIFBhdGhcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiRW50ZXIgeW91ciBwcmVmZXJyZWQgSEQgcGF0aCwgdGhlbiBzY2FuIGZvciBhbnkgYWN0aXZlIGFjY291bnRzLlwiLFxuXHRcdHNjYW46IFwiU2NhblwiLFxuXHRcdHJldHJ5OiBcIlJldHJ5XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIGlzIG5vdCBhdmFpbGFibGVcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJBY2Nlc3MgZGVuaWVkIHRvIHVzZSBMZWRnZXIgZGV2aWNlXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5vIEFjY291bnRzIEZvdW5kXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIlNlbGVjdCBZb3VyIEFjY291bnRzXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIkNvbm5lY3RpbmcgMSBBY2NvdW50XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIkNhbid0IGZpbmQgYW55IGFjY291bnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTGVkZ2VyLiBQbGVhc2UgY3JlYXRlIGEgbmV3IE5FQVIgYWNjb3VudCBvblwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJvciBjb25uZWN0IGFuIGFub3RoZXIgTGVkZ2VyLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiQ29ubmVjdGluZ1wiLFxuXHRcdG9mQWNjb3VudHM6IFwib2YgQWNjb3VudHNcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiRmFpbGVkIHRvIGF1dG9tYXRpY2FsbHkgZmluZCBhY2NvdW50IGlkLiBQcm92aWRlIGl0IG1hbnVhbGx5OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCJPdmVydmlldyB0aGUgbGlzdCBvZiBhdXRob3JpemVkIGFjY291bnQocyksIGNvbXBsZXRlIHNpZ24gaW4gYnkgY2xpY2tpbmcgdGhlIGJ1dHRvbiBiZWxvdy5cIixcblx0XHRmaW5pc2g6IFwiRmluaXNoXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJZb3UnbGwgbmVlZCB0byBpbnN0YWxsXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJ0byBjb250aW51ZS4gQWZ0ZXIgaW5zdGFsbGluZ1wiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcInJlZnJlc2ggdGhlIHBhZ2UuXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJDb3BpZWQgdG8gY2xpcGJvYXJkXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIkZhaWxlZCB0byBjb3B5IHRvIGNsaXBib2FyZFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJTY2FuIHdpdGggWW91ciBNb2JpbGUgRGV2aWNlXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBDb3B5IHRvIGNsaXBib2FyZFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIlByZWZlciB0aGUgb2ZmaWNpYWwgZGlhbG9ndWUgb2ZcIixcblx0XHRvcGVuOiBcIk9wZW5cIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiQ2hvb3NlIGEgV2FsbGV0XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiVHJhbnNmZXIgWW91ciBBY2NvdW50c1wiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwiU2VsZWN0IGEgd2FsbGV0IHRoYXQgZml0cyB5b3VyIG5lZWRzIGFuZCBzdXBwb3J0cyB5b3VyIGNvbm5lY3RlZCBhY2NvdW50cy5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiU2VsZWN0IFlvdXIgQWNjb3VudHNcIixcblx0XHRhZnRlckRlY2lkZTogXCJBZnRlciB5b3UgZGVjaWRlIG9uIGEgd2FsbGV0LCB5b3UgY2FuIHNlbGVjdCB3aGljaCBhY2NvdW50cyB5b3Ugd2FudCB0byB0cmFuc2Zlci5cIixcblx0XHRkaXNjbGFpbWVyOiBcIllvdSB3b27igJl0IGJlIGFibGUgdG8gdHJhbnNmZXIgYWNjb3VudHMgdGhhdCBoYXZlIG5ldmVyIGJlZW4gZnVuZGVkIG9yIHVzZWQgb24gTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcImRvZXMgbm90IHN1cHBvcnQgYWNjb3VudCBleHBvcnQgYXQgdGhpcyB0aW1lLiBQbGVhc2Ugc2VsZWN0IGFub3RoZXIgd2FsbGV0LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwiU2VsZWN0IEFjY291bnRzIHRvIFRyYW5zZmVyXCIsXG5cdFx0XHRidXR0b246IFwiQ29udGludWVcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIkRlc2VsZWN0IEFsbFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcIlNlbGVjdCBBbGxcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIlRyYW5zZmVyIFVuYXZhaWxhYmxlXCIsXG5cdFx0XHRlcnJvcjogXCJBY2NvdW50IGRvZXMgbm90IGV4aXN0XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcIkxlZGdlciBzdXBwb3J0IHJlcXVpcmVkXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiQWNjb3VudCBub3QgZnVuZGVkXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIkNvcHkgVGVtcG9yYXJ5IFBhc3N3b3JkXCIsXG5cdFx0XHRkZXNjOiBcIllvdeKAmWxsIG5lZWQgdG8gZW50ZXIgdGhpcyBwYXNzd29yZCB3aGVuIHlvdSBiZWdpbiBleHBvcnRpbmcgeW91ciBhY2NvdW50cyB0byBhIGRpZmZlcmVudCB3YWxsZXQuXCIsXG5cdFx0XHRidXR0b246IFwiQ29udGludWVcIixcblx0XHRcdHRyYW5zZmVyQnV0dG9uOiBcIlRyYW5zZmVyIEFjY291bnRzXCIsXG5cdFx0XHRsYWJlbDogXCJDbGljayB0byBDb3B5XCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcIkkgY29waWVkIG9yIHdyb3RlIGRvd24gdGhlIHBhc3N3b3JkXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJDb21wbGV0ZSB0aGUgVHJhbnNmZXJcIixcblx0XHRcdGRlc2NPbmU6IFwiWW91IHdpbGwgbm93IGJlIHJlZGlyZWN0ZWQgdG8gdGhlIHdhbGxldCB5b3Ugc2VsZWN0ZWQgdG8gY29tcGxldGUgdGhlIHRyYW5zZmVyLlwiLFxuXHRcdFx0ZGVzY1R3bzogXCJPbmNlIGltcG9ydCBwYXJ0IG9mIHByb2Nlc3MgaXMgY29tcGxldGVkIGZyb20gc2VsZWN0ZWQgd2FsbGV0LCBwcmVzcyBidXR0b24gdG8gY29tcGxldGUgdGhlIHRyYW5zZmVyIHByb2Nlc3MuXCIsXG5cdFx0XHRzdGFydE92ZXJCdXR0b246IFwiU3RhcnQgT3ZlclwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbXBsZXRlXCJcblx0XHR9XG5cdH1cbn07XG52YXIgY29tcG9uZW50JDEgPSB7XG5cdGNsaWNrVG9Db3B5OiB7XG5cdFx0bGFiZWw6IFwiQ29waWVkXCIsXG5cdFx0dG9vbHRpcDogXCJDbGljayB0byBjb3B5XCJcblx0fVxufTtcbnZhciBlbiA9IHtcblx0bW9kYWw6IG1vZGFsJGIsXG5cdGNvbXBvbmVudDogY29tcG9uZW50JDFcbn07XG5cbnZhciBtb2RhbCRhID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJDb25lY3RhIFR1IEJpbGxldGVyYVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwiwr9RdWUgZXMgdW5hIEJpbGxldGVyYT9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiUmVzZ3VhcmRhIHkgQWRtaW5pc3RyYXIgVHVzIEFjdGl2b3MgRGlnaXRhbGVzXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiQWxtYWNlbmEgZGUgZm9ybWEgc2VndXJhIHkgdHJhbnNmaWVyZSB0dXMgY3J5cHRvcyB5IE5GVCdzXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJJbmljaWUgc2VzacOzbiBlbiBDdWFscXVpZXIgQXBsaWNhY2lvbiBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTm8gZXMgbmVjZXNhcmlvIGNyZWFyIG51ZXZhcyBjdWVudGFzIG8gY3JlZGVuY2lhbGVzLCDCoUNvbmVjdGEgdHUgYmlsbGV0ZXJhIHkgbGlzdG8hXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJPYnRlbiB1bmEgQmlsbGV0ZXJhXCIsXG5cdFx0dXNlQVdhbGxldDogXCJVc2EgdHUgQmlsbGV0ZXJhIHBhcmEgcmVzZ3VhcmRhciB5IGFkbWluaXN0cmFyIHR1cyBhY3Rpdm9zIGVuIE5FQVIsIGUgSW5pY2lhciBzZXNpw7NuIGVuIGN1YWxxdWllciBhcGxpY2FjaW9uIE5FQVIgc2luIGxhIG5lY2VzaWRhZCBkZSBub21icmVzIGRlIHVzdWFyaW9zIHkgY29udHJhc2XDsWFzXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCJDb25leGnDs24gRmFsbGlkYVwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIkNvbmV4acOzbiBFeGlzdG9zYVwiLFxuXHRcdGNvbm5lY3RlZDogXCJDb25lY3RhZG9cIixcblx0XHRjb25uZWN0aW5nVG86IFwiQ29uZWN0YW5kbyBhIFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCJDb25maXJtZSBsYSBjb25leGnDs24gZW4gbGEgdmVudGFuYSBkZSBleHRlbnNpw7NuXCIsXG5cdFx0XHRicm93c2VyOiBcIkNvbmZpcm1lIGxhIGNvbmV4acOzbiBlbiBsYSBiaWxsZXRlcmEgZGVzcHXDqXMgZGUgbGEgcmVkaXJlY2Npw7NuXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJDb25maXJtZSBsYSBjb25leGnDs24gZW4gZWwgZGlzcG9zaXRpdm8gZGUgbGlicm8gbWF5b3JcIixcblx0XHRcdGJyaWRnZTogXCJDb25maXJtYXIgbGEgY29uZXhpw7NuIGVuIGxhIGJpbGxldGVyYVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJDb25lY3RhciBjb24gTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIkFzZWfDunJlc2UgZGUgcXVlIHN1IGxlZGdlciBlc3TDoSBjb25lY3RhZGEgZGUgZm9ybWEgc2VndXJhIHkgcXVlIGxhIGFwbGljYWNpb24gTkVBUiBlc3TDqSBhYmllcnRhIGVuIHN1IGRpc3Bvc2l0aXZvXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIkNvbnRpbnVhclwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiRXNwZWNpZmlxdWUgbGEgcnV0YSBIRFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCJJbmdyZXNlIHN1IHJ1dGEgSEQgcHJlcmlkYSx5IGx1ZWdvIGJ1c3F1ZSBjdWFscXVpZXIgY3VlbnRhIGFjdGl2YS5cIixcblx0XHRzY2FuOiBcIkVzY2FuZWFyXCIsXG5cdFx0cmV0cnk6IFwiUmVpbnRlbnRhclwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkVsIExlZGdlciBubyBlc3TDoSBkaXNwb25pYmxlXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiQWNjZXNvIGRlbmVnYWRvIHBhcmEgdXNhciBlbCBkaXNwb3NpdGl2byBsZWRnZXJcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTm8gc2UgZW5jb250cmFyb24gY3VlbnRhc1wiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJTZWxlY2Npb25hIHR1cyBjdWVudGFzXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIkNvbmVjdGFuZG8gYSAxIGN1ZW50YVwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJObyBzZSBwdWRvIGVuY29udHJhciBuaW5ndW5hIGN1ZW50YSBhc29jaWFkYSBjb24gZXN0ZSBsZWRnZXIsUG9yIGZhdm9yIGNyZWEgdW5hIG51ZXZhIGN1ZW50YSBlbiBORUFSXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIm8gY29uZWN0YSBvdHJvIGxlZGdlclwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiQ29uZWN0YW5kb1wiLFxuXHRcdG9mQWNjb3VudHM6IFwiZGUgQ3VlbnRhc1wiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJObyBzZSBwdWRvIGVuY29udHJhciBhdXRvbWF0aWNhbWVudGUgZWwgaWQgZGUgbGEgY3VlbnRhLEluZ3Jlc2FsbyBtYW51YWxtZW50ZTpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiUmV2aXNlIGxhIGxpc3RhIGRlIGxhcyBjdWVudGFzIGF1dG9yaXphZGFzLENvbXBsZXRlIGVsIGluaWNpbyBkZSBzZXNpw7NuIGhhY2llZG8gY2xpY2sgYSBjb3VudGludWFjaW9uLlwiLFxuXHRcdGZpbmlzaDogXCJGaW5hbGl6YXJcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIlRlbmRyw6FzIHF1ZSBpbnN0YWxhclwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwiUGFyYSBjb250aW51YXIsIERlc3B1ZXMgZGUgaW5zdGFsYXJcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJSZWNhcmdhIGxhIHBhZ2luYVwiLFxuXHRcdG9wZW46IFwiQWJyaXJcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIkNvcGlhZG8gYWwgUG9ydGFwYXBlbGVzXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIkZhbGzDsyBsYSBjb3BpYSBhbCBQb3J0YXBhcGVsZXNcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiQnVzY2EgY29uIHR1IGRpc3Bvc2l0aXZvIG1vdmlsXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBDb3BpYXIgYWwgUG9ydGFwYXBlbGVzXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiwr9QcmVmaXJlcyBlbCBkacOhbG9nbyBvZmljaWFsIGRlXCIsXG5cdFx0b3BlbjogXCJBYnJpclwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgZXMgPSB7XG5cdG1vZGFsOiBtb2RhbCRhXG59O1xuXG52YXIgbW9kYWwkOSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi6L+e5o6l5L2g55qE6ZKx5YyFXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLku4DkuYjmmK/pkrHljIXvvJ9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi5L+d5oqk5ZKM566h55CG5L2g55qE5pWw5a2X6LWE5LqnXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi5a6J5YWo5a2Y5YKo5ZKM6L2s56e75L2g55qE5Yqg5a+G6LSn5biB5ZKMTkZUXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLnmbvlvZXku7vkvZUgTkVBUiDlupTnlKhcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLkuI3pnIDopoHliJvlu7rmlrDotKbmiLfmiJblr4bnoIHjgILov57mjqXkvaDnmoTpkrHljIXvvIzljbPlj6/lvIDlp4vkvb/nlKjvvIFcIixcblx0XHRnZXRBV2FsbGV0OiBcIuiOt+WPluaWsOi0puaIt1wiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi5L2/55So6ZKx5YyF5p2l5L+d5oqk5ZKM566h55CG5L2g55qEIE5FQVIg6LWE5Lqn77yM5peg6ZyA55So5oi35ZCN5ZKM5a+G56CB5Y2z5Y+v55m75b2V5Lu75L2VIE5FQVIg5bqU55SoXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLov57mjqXlpLHotKVcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLov57mjqXmiJDlip9cIixcblx0XHRjb25uZWN0ZWQ6IFwi5bey6L+e5o6lXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIuato+WcqOi/nuaOpVwiXG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIui/nuaOpSBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi56Gu5L+d5L2g55qEIExlZGdlciDlt7Lnu4/lronlhajov57mjqXvvIzlubbkuJQgTkVBUiDlupTnlKjlt7Lnu4/lnKjkvaDorr7lpIfkuIrmiZPlvIBcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi57un57utXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLmjIflrpogSEQg6Lev5b6EXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIui+k+WFpeS9oOWBj+WlveeahCBIRCDot6/lvoTvvIznhLblkI7kuLrku7vmhI/mtLvot4PotKbmiLfmiavnoIFcIixcblx0XHRzY2FuOiBcIuaJq+eggVwiLFxuXHRcdHJldHJ5OiBcIumHjeivlVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciDkuI3lj6/nlKhcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLorr/pl64gTGVkZ2VyIOiuvuWkh+iiq+aLkue7nVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLmsqHmnInmib7liLDotKbmiLdcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi6YCJ5oup5L2g55qE6LSm5oi3XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIuato+WcqOi/nuaOpTHkuKrotKbmiLdcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi5rKh5pyJ5om+5Yiw5Lu75L2V5LiO6L+Z5LiqIExlZGdlciDnm7jlhbPogZTnmoTotKbmiLfjgILor7fliJvlu7rmlrDotKbmiLfkuo5cIixcblx0XHRcIm9yQ29ubmVjdEFuQW5vdGhlckxlZGdlci5cIjogXCLmiJbov57mjqXlj6bkuIDkuKogTGVkZ2VyXCIsXG5cdFx0Y29ubmVjdGluZzogXCLmraPlnKjov57mjqVcIixcblx0XHRvZkFjY291bnRzOiBcIuS4qui0puaIt1wiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLml6Dms5Xoh6rliqjmib7liLDotKbmiLdJRO+8jOivt+S4u+WKqOaPkOS+m++8mlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLor7fmn6XnnIvlt7LmjojmnYPnmoTotKbmiLfliJfooajvvIzngrnlh7vku6XkuIvmjInpkq7lrozmiJDnmbvlvZVcIixcblx0XHRmaW5pc2g6IFwi5a6M5oiQXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLkvaDlsIbpnIDopoHlronoo4VcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIuS7pee7p+e7reOAguWuieijheWujFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIuivt+WIt+aWsOmhtemdolwiLFxuXHRcdG9wZW46IFwi5omT5byAXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLlpI3liLbliLDkuobliarotLTmnb9cIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi5aSN5Yi25Yiw5Ymq6LS05p2/5aSx6LSlXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIueUqOS9oOeahOenu+WKqOiuvuWkh+aJq+eggVwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIg5aSN5Yi25Yiw5Ymq6LS05p2/XCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi5biM5pyb5L2/55So5a6Y5pa55a+56K+d5qGG5LqOXCIsXG5cdFx0b3BlbjogXCLmiZPlvIBcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIHpoID0ge1xuXHRtb2RhbDogbW9kYWwkOVxufTtcblxudmFyIG1vZGFsJDggPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcItCh0LLRitGA0LbQtdGC0LUg0LLQsNGI0LjRjyDQn9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLQmtCw0LrQstC+INC1INCf0L7RgNGC0YTQtdC50Ls/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItCX0LDRidC40YLQtdGC0LUg0Lgg0YPQv9GA0LDQstC70Y/QstCw0LnRgtC1INC00LjQs9C40YLQsNC70L3QuNGC0LUg0YHQuCDQsNC60YLQuNCy0LhcIixcblx0XHRzYWZlbHlTdG9yZTogXCLQodGK0YXRgNCw0L3Rj9Cy0LDQudGC0LUg0Lgg0L/RgNC10YXQstGK0YDQu9GP0LnRgtC1INCx0LXQt9C+0L/QsNGB0L3QviDQstCw0YjQuNGC0LUg0LrRgNC40L/RgtC+INC4IE5GVC5cIixcblx0XHRsb2dJblRvQW55OiBcItCY0LfQv9C+0LvQt9Cy0LDQudGC0LUg0LLRgdGP0LrQviDQv9GA0LjQu9C+0LbQtdC90LjQtSDQvdCwIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLQndGP0LzQsCDQvdGD0LbQtNCwINC00LAg0YHRitC30LTQsNCy0LDRgtC1INC90L7QstC4INC/0YDQvtGE0LjQu9C4LiDQodCy0YrRgNC20LXRgtC1INC/0L7RgNGC0YTQtdC50LvQsCDRgdC4INC4INGB0YLQtSDQs9C+0YLQvtCy0LghXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLQodGK0LfQtNCw0LnRgtC1INCf0L7RgNGC0YTQtdC50LtcIixcblx0XHR1c2VBV2FsbGV0OiBcItCY0LfQv9C+0LvQt9Cy0LDQudGC0LUg0L/QvtGA0YLRhNC10LnQu9CwLCDQt9CwINC00LAg0LfQsNGJ0LjRgtC40YLQtSDQuCDRg9C/0YDQsNCy0LvRj9Cy0LDRgtC1INCw0LrRgtC40LLQuNGC0LUg0YHQuCDQvdCwIE5FQVIg0LrQsNC60YLQviDQuCDQtNCwINC40LfQv9C+0LvQt9Cy0LDRgtC1INCy0YHRj9C60L4g0L/RgNC40LvQvtC20LXQvdC40LUg0L3QsCBORUFSINCx0LXQtyDQvdGD0LbQtNCwINC+0YIg0L/QvtGC0YDQtdCx0LjRgtC10LvRgdC60Lgg0LjQvNC10L3QsCDQuCDQv9Cw0YDQvtC70LguXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLQodCy0YrRgNC30LLQsNC90LXRgtC+INC90LXRg9GB0L/QtdGI0L3QvlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItCh0LLRitGA0LfQstCw0L3QtdGC0L4g0YPRgdC/0LXRiNC90L5cIixcblx0XHRjb25uZWN0ZWQ6IFwi0KHQstGK0YDQt9Cw0L1cIixcblx0XHRjb25uZWN0aW5nVG86IFwi0KHQstGK0YDQt9Cy0LDQvdC1INC60YrQvFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLQn9C+0YLQstGK0YDQtNC10YLQtSDRgdCy0YrRgNC30LLQsNC90LXRgtC+INCyINC/0YDQvtC30L7RgNC10YbQsCDQvdCwINGA0LDQt9GI0LjRgNC10L3QuNC10YLQvlwiLFxuXHRcdFx0YnJvd3NlcjogXCLQn9C+0YLQstGK0YDQtNC10YLQtSDRgdCy0YrRgNC30LLQsNC90LXRgtC+INCyINC/0L7RgNGC0YTQtdC50LvQsCDRgdC70LXQtCDQv9GA0LXQvdCw0YHQvtGH0LLQsNC90LXRgtC+XCIsXG5cdFx0XHRoYXJkd2FyZTogXCLQn9C+0YLQstGK0YDQtNC10YLQtSDRgdCy0YrRgNC30LLQsNC90LXRgtC+INCyINGF0LDRgNC00YPQtdGA0L3QuNGPINC/0L7RgNGC0YTQtdC50LtcIixcblx0XHRcdGJyaWRnZTogXCLQn9C+0YLQstGK0YDQtNC10YLQtSDQstGA0YrQt9C60LDRgtCwINCyINC/0L7RgNGC0YTQtdC50LvQsFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLQodCy0YrRgNC20LXRgtC1INGB0LUg0YEgTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItCj0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0LLQsNGI0LjRj9GCIExlZGdlciDQtSDRgdCy0YrRgNC30LDQvSDQuCDRh9C1INC/0YDQuNC70L7QttC10L3QuNC10YLQviBORUFSINC1INC+0YLQstC+0YDQtdC90L4g0L1hINC90LXQs9C+LlwiLFxuXHRcdFwiY29udGludWVcIjogXCLQn9GA0L7QtNGK0LvQttC10YLQtVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi0J/QvtGB0L7Rh9C10YLQtSBIRCDQv9GK0YJcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi0JLRitCy0LXQtNC10YLQtSDQv9GA0LXQtNC/0L7Rh9C40YLQsNC90LjRjyBIRCDQv9GK0YIsINGB0LvQtdC0INC60L7QtdGC0L4g0YHQutCw0L3QuNGA0LDQudGC0LUg0LfQsCDQsNC60YLQuNCy0L3QuCDQsNC60LDRg9C90YLQuC5cIixcblx0XHRzY2FuOiBcItCh0LrQsNC90LjRgNCw0LnRgtC1XCIsXG5cdFx0cmV0cnk6IFwi0J7Qv9C40YLQsNC50YLQtSDQvtGC0L3QvtCy0L5cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIg0YPRgdGC0YDQvtC50YHRgtCy0L7RgtC+INC90LUg0LUg0LTQvtGB0YLRitC/0L3QvlwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcItCU0L7RgdGC0YrQv9GK0YIg0LfQsCDQuNC30L/QvtC70LfQstCw0L3QtSDQvdCwIExlZGdlciDQtSDQvtGC0LrQsNC30LDQvVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLQndGP0LzQsCDQvdCw0LzQtdGA0LXQvdC4INC/0YDQvtGE0LjQu9C4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LLQsNGI0LjRgtC1INC/0YDQvtGE0LjQu9C4XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCh0LLRitGA0LfQstCw0L3QtSDQvdCwIDEg0L/RgNC+0YTQuNC7XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItCd0Y/QvNCwINC90LDQvNC10YDQtdC90Lgg0L/RgNC+0YTQuNC70LgsINGB0YrQstGA0LfQsNC90Lgg0YEg0YLQvtC30LggTGVkZ2VyLiDQnNC+0LvRjywg0YHRitC30LTQsNC50YLQtSDQvdC+0LIgTkVBUiDQv9GA0L7RhNC40Lsg0L3QsFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLQuNC70Lgg0YHQstGK0YDQttC10YLQtSDQtNGA0YPQsyBMZWRnZXIuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLQodCy0YrRgNC30LLQsNC90LVcIixcblx0XHRvZkFjY291bnRzOiBcItC+0YIg0L/RgNC+0YTQuNC70LhcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi0JDQstGC0L7QvNCw0YLQuNGH0L3QvtGC0L4g0L3QsNC80LjRgNCw0L3QtSDQvdCwINC/0YDQvtGE0LjQu9CwINC90LUg0LHQtSDRg9GB0L/QtdGI0L3Qvi4g0JLRitCy0LXQtNC10YLQtSDQs9C+INGA0YrRh9C90L46XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItCf0YDQtdCz0LvQtdC00LDQudGC0LUg0YHQv9C40YHRitC60LAg0YEg0YPQv9GK0LvQvdC+0LzQvtGJ0LXQvdC4INC/0YDQvtGE0LjQu9C4LCDQt9Cw0LLRitGA0YjQtdGC0LUg0LLQu9C40LfQsNC90LXRgtC+LCDQutCw0YLQviDRidGA0LDQutC90LXRgtC1INCy0YrRgNGF0YMg0LHRg9GC0L7QvdCwINC/0L4t0LTQvtC70YMuLlwiLFxuXHRcdGZpbmlzaDogXCLQl9Cw0LLRitGA0YjQtdGC0LVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCp0LUg0YLRgNGP0LHQstCwINC00LAg0LjQvdGB0YLQsNC70LjRgNCw0YLQtVwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi0LfQsCDQtNCwINC/0YDQvtC00YrQu9C20LjRgtC1LiDQodC70LXQtCDQuNC90YHRgtCw0LvQuNGA0LDQvdC1XCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi0L/RgNC10LfQsNGA0LXQtNC10YLQtSDRgdGC0YDQsNC90LjRhtCw0YLQsC5cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNC90L4g0LIg0LrQu9C40L/QsdC+0YDQtNCwXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItCd0LXRg9GB0L/QtdGI0L3QviDQutC+0L/QuNGA0LDQvdC1INCyINC60LvQuNC/0LHQvtGA0LTQsFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCIg0KHQutCw0L3QuNGA0LDQudGC0LUg0YEg0LzQvtCx0LjQu9C90L7RgtC+INGB0Lgg0YPRgdGC0YDQvtC50YHRgtCy0L5cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiINCa0L7Qv9C40YDQsNC50YLQtSDQsiDQutC70LjQv9Cx0L7RgNC00LBcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLQn9GA0LXQtNC/0L7Rh9C40YLQsNC9INC10LfQuNC6INC30LAg0LrQvtGA0LXRgdC/0L7QvdC00LXQvdGG0LjRj1wiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgYmcgPSB7XG5cdG1vZGFsOiBtb2RhbCQ4XG59O1xuXG52YXIgbW9kYWwkNyA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi7KeA6rCRIOyXsOqysO2VmOq4sFwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi7KeA6rCR7J2AIOustOyKqCDsl63tlaDsnYQg7ZWY64KY7JqUP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLri7nsi6DsnZgg65SU7KeA7YS4IOyekOyCsOydhCDrs7TtmLjtlZjqs6Ag6rSA66as7ZWp64uI64ukLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIuyVlO2YuO2ZlO2PkOyZgCBORlTrpbwg7JWI7KCE7ZWY6rKMIOyggOyepe2VmOqzoCDsoITshqHtlaAg7IiYIOyeiOyKteuLiOuLpC5cIixcblx0XHRsb2dJblRvQW55OiBcIk5FQVIgQXBw7JeQIOuhnOq3uOyduO2VqeuLiOuLpC5cIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLsg4jroZzsmrQg6rOE7KCV7J2064KYIOu5hOuwgOuyiO2YuOulvCDrp4zrk6Qg7ZWE7JqUIOyXhuydtCDsp4DqsJHsnYQg7Jew6rKw7ZWcIO2bhCDrsJTroZwg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLsp4DqsJEg6rCA7KC47Jik6riwXCIsXG5cdFx0dXNlQVdhbGxldDogXCLsp4DqsJHsnYQg7IKs7Jqp7ZWY7JesIE5FQVIg7J6Q7IKw7J2EIOuztO2YuMK36rSA66as7ZWY6rOgLCDslYTsnbTrlJTsmYAg67mE67CA67KI7Zi4IOyXhuydtCBORUFSIOyVseyXkCDroZzqt7jsnbjtlaAg7IiYIOyeiOyKteuLiOuLpC5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIuyXsOqysCDsi6TtjKhcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLsl7DqsrAg7ISx6rO1XCIsXG5cdFx0Y29ubmVjdGVkOiBcIkNvbm5lY3RlZFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLsl7DqsrAg7KSROiBcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi7J217Iqk7YWQ7IWYIOywveyXkOyEnCDsl7DqsrDsnYQg7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XHRicm93c2VyOiBcIuumrOuLpOydtOugie2KuCDrkJwg7KeA6rCR7JeQ7IScIOyXsOqysOydhCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcdGhhcmR3YXJlOiBcIkxlZGdlciDquLDquLDsl5DshJwg7Jew6rKw7J2EIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFx0YnJpZGdlOiBcIuyngOqwkeyXkOyEnCDsl7DqsrAg7ZmV7J24XCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIkxlZGdlciDsl7DqsrDtlZjquLBcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiTGVkZ2Vy6rCAIOyViOyghO2VmOqyjCDsl7DqsrDrkJjslrQg7J6I6rOgLCBORUFSIOyVseydtCDsl7TroKQg7J6I64qUIOyngCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi6rOE7IaN7ZWY6riwXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJIRCBQYXRoIOyngOygle2VmOq4sFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLsm5DtlZjripQgSEQgUGF0aOulvCDshKDtg53tlZjqs6AsIO2ZnOyEse2ZlOuQnCDqs4TsoJXsnbQg7J6I64qUIOyngCDqsoDsg4ntlZjshLjsmpRcIixcblx0XHRzY2FuOiBcIuqygOyDiVwiLFxuXHRcdHJldHJ5OiBcIuuLpOyLnCDsi5zrj4RcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXLrpbwg7IKs7Jqp7ZWgIOyImCDsl4bsirXri4jri6RcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJMZWRnZXIg6riw6riwIOygkeq3vCDqtoztlZzsnbQg6rGw67aA65CY7JeI7Iq164uI64ukXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIuqzhOygleydhCDssL7snYQg7IiYIOyXhuyKteuLiOuLpFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLqs4TsoJUg7ISg7YOd7ZWY6riwXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIu2VmOuCmOydmCDqs4TsoJXsl5Ag7Jew6rKwXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIkxlZGdlcuyZgCDsl7DqsrDrkJwg6rOE7KCV7J2EIOywvuydhCDsiJgg7JeG7Iq164uI64ukLiDsg4jroZzsmrQg6rOE7KCV7J2EIOyDneyEse2VmOqxsOuCmCBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi64uk66W4IExlZGdlcuulvCDsl7DqsrDtlZjshLjsmpRcIixcblx0XHRjb25uZWN0aW5nOiBcIuqzhOyglSDsl7DqsrDtlZjquLA6IFwiLFxuXHRcdG9mQWNjb3VudHM6IFwi6rCcIOqzhOygleydhCDssL7slZjsirXri4jri6RcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi6rOE7KCVIElE66W8IOywvuyngCDrqrvtlojsirXri4jri6QuIOyImOuPmeycvOuhnCDsnoXroKXtlbTso7zshLjsmpQuXCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIuyduOymneuQnCDqs4TsoJUg66qp66Gd7J2EIO2ZleyduO2VnCDtm4Qg7JWE656YIOuyhO2KvOydhCDtgbTrpq3tlZjsl6wg66Gc6re47J247J2EIOyZhOujjO2VmOyEuOyalFwiLFxuXHRcdGZpbmlzaDogXCLsmYTro4xcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIu2VmOuTnOybqOyWtCDsp4DqsJFcIixcblx0XHRicm93c2VyOiBcIuu4jOudvOyasOyggCDsp4DqsJFcIixcblx0XHRpbmplY3RlZDogXCLsp4DqsJEg7ZmV7J6lXCIsXG5cdFx0YnJpZGdlOiBcIuu4jOumrOyngCDsp4DqsJFcIixcblx0XHRtb2JpbGU6IFwi66qo67CU7J28IOyngOqwkVwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwi7J247Iqk7YS07Yq4IOyngOqwkVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi64uk7J2MIO2ZleyepSDtlITroZzqt7jrnqjsnYQg7ISk7LmY7ZW07KO87IS47JqUOlwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwiLiDshKTsuZgg7JmE66OMIO2bhCDtjpjsnbTsp4Ag7IOI66GcIOqzoOy5qOydtCDtlYTsmpTtlanri4jri6QuIFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIuyDiOuhnCDqs6DsuahcIixcblx0XHRvcGVuOiBcIk9wZW5cIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIu2BtOumveuztOuTnOyXkCDrs7Xsgqwg7JmE66OMXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIu2BtOumveuztOuTnOyXkCDrs7Xsgqwg7Iuk7YyoXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIuuqqOuwlOydvCDsnqXsuZjrpbwg7IKs7Jqp7ZWY7JesIOyKpOy6lO2VtOyjvOyEuOyalFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIg7YG066a967O065Oc7JeQIOuzteyCrO2VmOq4sFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIuuLpOydjCDtlITroZzqt7jrnqjsl5DshJwg7KCc6rO17ZWY64qUIOqzteyLnSDtlITroZzshLjsiqTrpbwg7ISg7Zi47ZWY7Iut64uI6rmMOiBcIixcblx0XHRvcGVuOiBcIk9wZW5cIlxuXHR9XG59O1xudmFyIGtvID0ge1xuXHRtb2RhbDogbW9kYWwkN1xufTtcblxudmFyIG1vZGFsJDYgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIkvhur90IG7hu5FpIHbDrSBj4bunYSBi4bqhblwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwiVsOtIGzDoCBnw6w/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIkLhuqNvIG3huq10ICYgUXXhuqNuIGzDvSB0w6BpIHPhuqNuIHPhu5EgY+G7p2EgYuG6oW5cIixcblx0XHRzYWZlbHlTdG9yZTogXCJMxrB1IHRy4buvIHbDoCBjaHV54buDbiB0aeG7gW4gxJFp4buHbiB04butIHbDoCBORlQgY+G7p2EgYuG6oW4gbeG7mXQgY8OhY2ggYW4gdG/DoG4uXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLEkMSDbmcgbmjhuq1wIHbDoG8gYuG6pXQga+G7syDhu6luZyBk4bulbmcgdHLDqm4gTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIktow7RuZyBj4bqnbiB04bqhbyB0w6BpIGtob+G6o24gaG/hurdjIHRow7RuZyB0aW4gxJHEg25nIG5o4bqtcCBt4bubaS4gS+G6v3QgbuG7kWkgdsOtIGPhu6dhIGLhuqFuIHbDoCBi4bqvdCDEkeG6p3UhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJU4bqhbyBWw61cIixcblx0XHR1c2VBV2FsbGV0OiBcIlPhu60gZOG7pW5nIHbDrSDEkeG7gyBi4bqjbyBt4bqtdCB2w6AgcXXhuqNuIGzDvSB0w6BpIHPhuqNuIHRyw6puIE5FQVIgY+G7p2EgYuG6oW4gdsOgIMSRxINuZyBuaOG6rXAgdsOgbyBi4bqldCBr4buzIOG7qW5nIGThu6VuZyBORUFSIG7DoG8sIGtow7RuZyBj4bqnbiB0w6puIG5nxrDhu51pIGTDuW5nIHbDoCBt4bqtdCBraOG6qXUuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCJL4bq/dCBu4buRaSB0aOG6pXQgYuG6oWlcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJL4bq/dCBu4buRaSB0aMOgbmggY8O0bmdcIixcblx0XHRjb25uZWN0ZWQ6IFwixJDDoyBr4bq/dCBu4buRaVwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLEkGFuZyBr4bq/dCBu4buRaSB04bubaVwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB0cm9uZyBj4butYSBz4buVIHRp4buHbiDDrWNoIG3hu58gcuG7mW5nXCIsXG5cdFx0XHRicm93c2VyOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHRyb25nIHbDrSBzYXUga2hpIMSRxrDhu6NjIGNodXnhu4NuIGjGsOG7m25nXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB24bubaSB2w60gbOG6oW5oXCIsXG5cdFx0XHRicmlkZ2U6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgdHJvbmcgdsOtXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIkvhur90IG7hu5FpIHbDrSBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwixJDhuqNtIGLhuqNvIExlZGdlciBj4bunYSBi4bqhbiDEkcaw4bujYyBr4bq/dCBu4buRaSBhbiB0b8OgbiB2w6Ag4bupbmcgZOG7pW5nIE5FQVIgxJFhbmcgbeG7nyBz4bq1biB0csOqbiB0aGnhur90IGLhu4tcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiVGnhur9wIHThu6VjXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJDaOG7iSDEkeG7i25oIEhEIFBhdGhcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiTmjhuq1wIEhEIFBhdGggY+G7p2EgYuG6oW4sIHNhdSDEkcOzIHF1w6l0IHTDrG0gY8OhYyB0w6BpIGtob+G6o24gaG/huqF0IMSR4buZbmdcIixcblx0XHRzY2FuOiBcIlF1w6l0XCIsXG5cdFx0cmV0cnk6IFwiVGjhu60gbOG6oWlcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIga2jDtG5nIGto4bqjIGThu6VuZ1wiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIlRydXkgY+G6rXAgTGVkZ2VyIGLhu4sgdOG7qyBjaOG7kWlcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiS2jDtG5nIHTDrG0gdGjhuqV5IHTDoGkga2hv4bqjblwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJDaOG7jW4gdMOgaSBraG/huqNuIGPhu6dhIGLhuqFuXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIsSQYW5nIGvhur90IG7hu5FpIDEgdMOgaSBraG/huqNuXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIktow7RuZyB0aOG7gyB0w6xtIHRo4bqleSBi4bqldCBr4buzIHTDoGkga2hv4bqjbiBuw6BvIMSRxrDhu6NjIGxpw6puIGvhur90IHbhu5tpIExlZGdlciBuw6B5LiBWdWkgbMOybmcgdOG6oW8gbeG7mXQgdMOgaSBraG/huqNuIE5FQVIgbeG7m2lcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwiaG/hurdjIGvhur90IG7hu5FpIHbhu5tpIHbDrSBMZWRnZXIga2jDoWMuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLEkGFuZyBr4bq/dCBu4buRaVwiLFxuXHRcdG9mQWNjb3VudHM6IFwiY+G7p2EgdMOgaSBraG/huqNuXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIktow7RuZyB0aOG7gyB04buxIMSR4buZbmcgdMOsbSBpZCB0w6BpIGtob+G6o24uIE5o4bqtcCB0aOG7pyBjw7RuZzpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiVOG7lW5nIHF1YW4gZGFuaCBzw6FjaCBjw6FjIHTDoGkga2hv4bqjbiDEkcaw4bujYyDhu6d5IHF1eeG7gW4sIGhvw6BuIHThuqV0IMSRxINuZyBuaOG6rXAgYuG6sW5nIGPDoWNoIGLhuqVtIHbDoG8gbsO6dCBiw6puIGTGsOG7m2kuXCIsXG5cdFx0ZmluaXNoOiBcIkhvw6BuIHRow6BuaFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiQuG6oW4gc+G6vSBj4bqnbiBjw6BpIMSR4bq3dFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwixJHhu4MgYuG6r3QgxJHhuqd1LiBTYXUga2hpIGPDoGkgxJHhurd0IHhvbmdcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJU4bqjaSBs4bqhaSB0cmFuZy5cIixcblx0XHRvcGVuOiBcIk3hu59cIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIsSQw6Mgc2FvIGNow6lwIHbDoG8gYuG6o25nIGdoaSB04bqhbVwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJTYW8gY2jDqXAgdsOgbyBi4bqjbmcgZ2hpIHThuqFtIHRo4bqldCBi4bqhaVwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJRdcOpdCB24bubaSDEkWnhu4duIHRob+G6oWkgY+G7p2EgYuG6oW5cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIFNhbyBjaMOpcCB2w6BvIGLhuqNuZyBnaGkgdOG6oW1cIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJEaWFsb2d1ZSBjaMOtbmggdGjhu6ljIGPhu6dhXCIsXG5cdFx0b3BlbjogXCJN4bufXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJWw60gbOG6oW5oXCIsXG5cdFx0YnJvd3NlcjogXCJWw60gdHLDrG5oIGR1eeG7h3RcIixcblx0XHRpbmplY3RlZDogXCJWw60gdGnhu4duIMOtY2ggbeG7nyBy4buZbmdcIixcblx0XHRicmlkZ2U6IFwiVsOtIEPhuqd1XCIsXG5cdFx0bW9iaWxlOiBcIlbDrSBNb2JpbGVcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIlbDrSB04bupYyB0aMOsXCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIkNo4buNbiB2w61cIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCJDaHV54buDbiB0w6BpIGtob+G6o25cIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIkNo4buNbiB2w60gcGjDuSBo4bujcCB24bubaSBuaHUgY+G6p3UgY+G7p2EgYuG6oW4sIHbDrSDEkcaw4bujYyBjaOG7jW4gY+G6p24gaOG7lyB0cuG7oyBjw6FjIHTDoGkga2hv4bqjbiDEkWFuZyBz4butIGThu6VuZy5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiQ2jhu41uIHTDoGkga2hv4bqjblwiLFxuXHRcdGFmdGVyRGVjaWRlOiBcIlNhdSBraGkgY2jhu41uIMSRxrDhu6NjIHTDoGkga2hv4bqjbiBi4bqhbiBjw7MgY2h1eeG7g24uXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJC4bqhbiBraMO0bmcgdGjhu4MgY2h1eeG7g24gdMOgaSBraG/huqNuIG7hur91IHTDoGkga2hv4bqjbiDEkcOzIGNoxrBhIMSRxrDhu6NjIG5o4bqtbiB0aeG7gW4gaG/hurdjIGNoxrBhIHBow6F0IHNpbmggZ2lhbyBk4buLY2ggdHLDqm4gTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcImtow7RuZyBo4buXIHRy4bujIHh14bqldCB0w6BpIGtob+G6o24uIFZ1aSBsw7JuZyBjaOG7jW4gdsOtIGtow6FjLlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJWw60gbOG6oW5oXCIsXG5cdFx0XHRicm93c2VyOiBcIlbDrSB0csOsbmggZHV54buHdFwiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwiVsOtIHRp4buHbiDDrWNoIG3hu58gcuG7mW5nXCIsXG5cdFx0XHRicmlkZ2U6IFwiVsOtIEPhuqd1XCIsXG5cdFx0XHRtb2JpbGU6IFwiVsOtIE1vYmlsZVwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwiQ2jhu41uIHTDoGkga2hv4bqjbiDEkeG7gyBjaHV54buDblwiLFxuXHRcdFx0YnV0dG9uOiBcIkzhuqV5IGPhu6VtIG3huq10IGto4bqpdVwiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiQuG7jyBjaOG7jW4gdOG6pXQgY+G6o1wiLFxuXHRcdFx0c2VsZWN0QWxsOiBcIkNo4buNbiB04bqldCBj4bqjXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJDaHV54buDbiBraMO0bmcga2jhuqMgZOG7pW5nXCIsXG5cdFx0XHRlcnJvcjogXCJUw6BpIGtob+G6o24ga2jDtG5nIHThu5NuIHThuqFpXCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcIlnDqnUgY+G6p3UgaOG7lyB0cuG7oyBMZWRnZXJcIixcblx0XHRcdG5vQmFsYW5jZTogXCJUw6BpIGtob+G6o24gdHLhu5FuZ1wiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJTYW8gY2jDqXAgbeG6rXQga2jhuql1IHThuqFtIHRo4budaVwiLFxuXHRcdFx0ZGVzYzogXCJC4bqhbiBz4bq9IGPhuqduIG5o4bqtcCBt4bqtdCBraOG6qXUga2hpIGLhuq90IMSR4bqndSB4deG6pXQgY8OhYyBraG/huqNuIHThu5tpIHbDrSBraMOhYy5cIixcblx0XHRcdGJ1dHRvbjogXCJUaeG6v3AgdOG7pWNcIixcblx0XHRcdGxhYmVsOiBcIkLhuqVtIMSR4buDIHNhbyBjaMOpcFwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJUw7RpIMSRw6MgY2jDqXAgaG/hurdjIGdoaSBs4bqhaSBt4bqtdCBraOG6qXVcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIkhvw6BuIHRow6BuaCBjaHV54buDblwiLFxuXHRcdFx0ZGVzY09uZTogXCJC4bqhbiBz4bq9IMSRxrDhu6NjIGNodXnhu4NuIGjGsOG7m25nIHThu5tpIHTDoGkga2hv4bqjbiDEkcOjIGNo4buNbiDEkeG7gyBob8OgbiB04bqldCBxdcOhIHRyw6xuaC5cIixcblx0XHRcdGRlc2NUd286IFwiU2F1IGtoaSBuaOG6rXAsIG5o4bqlbiBuw7p0IMSR4buDIGhvw6BuIHThuqV0IHF1eSB0csOsbmggY2h1eeG7g24uXCIsXG5cdFx0XHRidXR0b246IFwiSG/DoG4gdGjDoG5oXCJcblx0XHR9XG5cdH1cbn07XG52YXIgY29tcG9uZW50ID0ge1xuXHRjbGlja1RvQ29weToge1xuXHRcdGxhYmVsOiBcIsSQw6Mgc2FvIGNow6lwXCIsXG5cdFx0dG9vbHRpcDogXCJC4bqlbSDEkeG7gyBzYW8gY2jDqXBcIlxuXHR9XG59O1xudmFyIHZpID0ge1xuXHRtb2RhbDogbW9kYWwkNixcblx0Y29tcG9uZW50OiBjb21wb25lbnRcbn07XG5cbnZhciBtb2RhbCQ1ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLgpIXgpKrgpKjgpL4g4KS14KWJ4KSy4KWH4KSfIChXYWxsZXQpIOCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpILgpaRcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIuCkteClieCksuClh+CknyDgpJXgpY3gpK/gpL4g4KS54KWIP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSU4KSwIOCkquCljeCksOCkrOCkguCkp+Ckv+CkpCDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRzYWZlbHlTdG9yZTogXCLgpIXgpKrgpKjgpYAg4KSV4KWN4KSw4KS/4KSq4KWN4KSf4KWL4KSV4KSw4KWH4KSC4KS44KWAIOCklOCksCDgpI/gpKjgpI/gpKvgpJ/gpYAg4KSV4KWLIOCkuOClgeCksOCkleCljeCkt+Ckv+CkpCDgpLDgpYLgpKog4KS44KWHIOCkuOCljeCkn+Cli+CksCDgpJTgpLAg4KSf4KWN4KSw4KS+4KSC4KS44KSr4KSwIOCkleCksOClh+CkguClpFwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiTkVBUiDgpKrgpLAg4KSV4KS/4KS44KWAIOCkreClgCDgpJDgpKog4KSu4KWH4KSCIOCkuOCkvuCkh+CkqCDgpIfgpKgg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi4KSo4KSPIOCkluCkvuCkpOClhyDgpK/gpL4g4KSy4KWJ4KSX4KS/4KSoIOCkrOCkqOCkvuCkqOClhyDgpJXgpYAg4KSG4KS14KS24KWN4KSv4KSV4KSk4KS+IOCkqOCkueClgOCkgiDgpLngpYjgpaQg4KSF4KSq4KSo4KS+IOCkteClieCksuClh+CknyhORUFSIFdhbGxldCngpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSCIOCklOCksCDgpIbgpLDgpILgpK0g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLgpI/gpJUg4KS14KWJ4KSy4KWH4KSfIOCkrOCkqOCkvuCkj+CkgeClpFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi4KSF4KSq4KSo4KWAIE5FQVIg4KS44KSC4KSq4KSk4KWN4KSk4KS/4KSv4KWL4KSCIOCkleCliyDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSU4KSwIOCkquCljeCksOCkrOCkguCkp+Ckv+CkpCDgpJXgpLDgpKjgpYcg4KSV4KWHIOCksuCkv+CkjyDgpLXgpYngpLLgpYfgpJ8g4KSV4KS+IOCkieCkquCkr+Cli+CklyDgpJXgpLDgpYfgpIIg4KSU4KSwIOCkleCkv+CkuOClgCDgpK3gpYAgTkVBUiDgpJDgpKogKGFwcCkg4KSu4KWH4KSCIOCksuClieCklyDgpIfgpKgg4KSV4KSw4KWH4KSCLCDgpJXgpL/gpLjgpYAg4KSJ4KSq4KSv4KWL4KSX4KSV4KSw4KWN4KSk4KS+ICh1c2VyKSDgpKjgpL7gpK4g4KSU4KSwIOCkquCkvuCkuOCkteCksOCljeCkoSDgpJXgpYAg4KSG4KS14KS24KWN4KSv4KSV4KSk4KS+IOCkqOCkueClgOCkgiDgpLngpYjgpaRcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIuCkleCkqOClh+CkleCljeCktuCkqCDgpLXgpL/gpKvgpLJ8XCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkuOCkq+CksnxcIixcblx0XHRjb25uZWN0ZWQ6IFwi4KS14KWJ4KSy4KWH4KSfIOCknOClgeClnCDgpJfgpK/gpL58XCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIuCkteClieCksuClh+CknyDgpJzgpYHgpZwg4KSw4KS54KS+IOCkueClh3xcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi4KSP4KSV4KWN4KS44KSf4KWH4KSC4KS24KSoIOCkteCkv+CkguCkoeCliyDgpK7gpYfgpIIg4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkleClgCDgpKrgpYHgpLfgpY3gpJ/gpL8g4KSV4KSw4KWH4KSCfFwiLFxuXHRcdFx0YnJvd3NlcjogXCLgpLDgpYDgpKHgpL7gpK/gpLDgpYfgpJXgpY3gpJ8g4KS54KWL4KSo4KWHIOCkleClhyDgpKzgpL7gpKYg4KS14KWJ4KSy4KWH4KSfIOCkruClh+CkgiDgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KSV4KWAIOCkquClgeCkt+CljeCkn+CkvyDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0XHRoYXJkd2FyZTogXCLgpJXgpYvgpLLgpY3gpKEg4KS14KWJ4KSy4KWH4KSfIOCkleClhyDgpLjgpL7gpKUg4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkleClgCDgpKrgpYHgpLfgpY3gpJ/gpL8g4KSV4KSw4KWH4KSCfFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLgpLLgpYfgpJzgpLAoTGVkZ2VyKeCkteClieCksuClh+CknyDgpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSCfFwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLgpLjgpYHgpKjgpL/gpLbgpY3gpJrgpL/gpKQg4KSV4KSw4KWH4KSCIOCkleCkvyDgpIbgpKrgpJXgpL4g4KSy4KWH4KSc4KSwIOCkuOClgeCksOCkleCljeCkt+Ckv+CkpCDgpLDgpYLgpKog4KS44KWHIOCknOClgeCkoeCkvOCkviDgpLngpYHgpIYg4KS54KWIIOCklOCksCBORUFSIOCkkOCkqiDgpIbgpKrgpJXgpYcg4KSh4KS/4KS14KS+4KSH4KS4IChEZXZpY2Up4KSq4KSwIOCkquCkueCksuClhyDgpLjgpYcg4KS54KWAIOCkluClgeCksuCkviDgpLngpYh8XCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIuCknOCkvuCksOClgCDgpLDgpJbgpYd8XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLgpLngpL7gpLDgpY3gpKEg4KSh4KS/4KS44KWN4KSVKEhhcmQgRGlzayngpKrgpKUoUGF0aCngpKjgpL/gpLDgpY3gpKfgpL7gpLDgpL/gpKQg4KSV4KSw4KWHfFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLgpIXgpKrgpKjgpL4g4KSP4KSa4KSh4KWAIOCkquCkpSDgpKbgpLDgpY3gpJwg4KSV4KSw4KWH4KSCLCDgpKvgpL/gpLAg4KS44KSV4KWN4KSw4KS/4KSvIOCkluCkvuCkpOCli+CkgiDgpJXgpYcg4KSy4KS/4KSPIOCkuOCljeCkleCliOCkqCDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0c2NhbjogXCLgpLjgpY3gpJXgpYjgpKgg4KSV4KSw4KWHfFwiLFxuXHRcdHJldHJ5OiBcIuCkpuCli+CkrOCkvuCksOCkviDgpKrgpY3gpLDgpK/gpL7gpLgg4KSV4KSw4KWHfFwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIuCksuClh+CknOCksCDgpIngpKrgpLLgpKzgpY3gpKcg4KSo4KS54KWA4KSCIOCkueCliHxcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLgpLLgpYfgpJzgpLAg4KSh4KS/4KS14KS+4KSH4KS4IOCkleCkviDgpIngpKrgpK/gpYvgpJcg4KSV4KSw4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KSq4KWN4KSw4KS14KWH4KS2IOCkqOCkv+Ckt+Clh+Ckp3xcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi4KSW4KS+4KSk4KS+IOCkqOCkueClgOCkgiDgpK7gpL/gpLLgpL58XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIuCkheCkquCkqOClhyDgpJbgpL7gpKTgpYcg4KSa4KWB4KSo4KWH4KSCfFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLgpI/gpJUg4KSW4KS+4KSk4KS+IOCkleCkqOClh+CkleCljeCknyDgpLngpYsg4KSw4KS54KS+IOCkueCliHxcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi4KSH4KS4IOCksuClh+CknOCksCDgpLjgpYcg4KSc4KWB4KSh4KS84KS+IOCkleCli+CkiCDgpJbgpL7gpKTgpL4g4KSo4KS54KWA4KSCIOCkruCkv+CksuCkvuClpCDgpJXgpYPgpKrgpK/gpL4g4KSP4KSVIOCkqOCkr+CkviBORUFSIOCkluCkvuCkpOCkviDgpKzgpKjgpL7gpI/gpIF8XCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIuCkheCkpeCkteCkviDgpKbgpYLgpLjgpLDgpYcg4KSy4KWH4KSc4KSwIOCkteClieCksuClh+CknyDgpLjgpYcg4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkguClpFwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi4KSc4KWB4KWcIOCksOCkueCkviDgpLngpYd8XCIsXG5cdFx0b2ZBY2NvdW50czogXCLgpJbgpL7gpKTgpL4g4KSF4KSsIOCknOClgeClnOCkviDgpKjgpLngpYDgpIIg4KS54KWHfFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLgpJbgpL7gpKTgpL4g4KSG4KSI4KSh4KWAIOCkuOCljeCkteCkmuCkvuCksuCkv+CkpCDgpLDgpYLgpKog4KS44KWHIOCkluCli+CknOCkqOClhyDgpK7gpYfgpIIg4KSF4KS44KSu4KSw4KWN4KSl4KWkIOCkruCliOCkqOCljeCkr+ClgeCkheCksiAoTWFudWFsbCkg4KSw4KWC4KSqIOCkuOClhyDgpJXgpYvgpLbgpL/gpLYg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLgpIXgpLXgpLLgpYvgpJXgpKgg4KSF4KSn4KS/4KSV4KWD4KSkIOCkleClgCDgpLjgpYLgpJrgpYAsIOCkqOClgOCkmuClhyDgpKbgpL/gpI8g4KSX4KSPIOCkrOCkn+CkqCDgpKrgpLAg4KSV4KWN4KSy4KS/4KSVIOCkleCksOCkleClhyDgpLLgpYngpJfgpL/gpKgg4KSq4KWC4KSw4KS+IOCkleCksOClh+CkguClpFwiLFxuXHRcdGZpbmlzaDogXCLgpLjgpK7gpL7gpKrgpY3gpKR8XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLgpIbgpKrgpJXgpYsg4KSH4KSC4KS44KWN4KSf4KWJ4KSyIOCkleCksOCkqOCkviDgpLngpYvgpJfgpL58XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLgpIfgpILgpLjgpY3gpJ/gpYngpLIg4KSV4KSw4KSo4KWHIOCkleClhyDgpKzgpL7gpKYg4KSc4KS+4KSw4KWAIOCksOCkluClh3xcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLgpKrgpYHgpKg6IOCksuCli+CkoSDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRvcGVuOiBcIuCkluCli+CksuClh3xcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIuCkleCljeCksuCkv+CkquCkrOCli+CksOCljeCkoShDbGlwYm9hcmQp4KSq4KSwIOCkleClieCkquClgCDgpJXgpL/gpK/gpL4g4KSX4KSv4KS+fFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLgpJXgpY3gpLLgpL/gpKrgpKzgpYvgpLDgpY3gpKEg4KSq4KSwIOCkleClieCkquClgCDgpJXgpLDgpKjgpL4g4KS14KS/4KSr4KSyIOCksOCkueCkvnxcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi4KSF4KSq4KSo4KWHIOCkq+Cli+CkqCAoTW9iaWxlKeCkuOClhyDgpLjgpY3gpJXgpYjgpKgg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIg4KSV4KWN4KSy4KS/4KSq4KSs4KWL4KSw4KWN4KShIOCkquCksCDgpJXgpYngpKrgpYAg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIuCkhuCkp+Ckv+CkleCkvuCksOCkv+CklSDgpLjgpILgpLXgpL7gpKYg4KSV4KWLIOCkquCljeCksOCkvuCkpeCkruCkv+CkleCkpOCkviDgpKbgpYfgpIJ8XCIsXG5cdFx0b3BlbjogXCLgpJbgpYvgpLLgpYd8XCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciBoaSA9IHtcblx0bW9kYWw6IG1vZGFsJDVcbn07XG5cbnZhciBtb2RhbCQ0ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLYtdmEINmF2K3Zgdi42KrZg1wiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi2YXYpyDZh9mKINin2YTZhdit2YHYuNip2J9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi2KrYo9mF2YrZhiDZiNil2K/Yp9ix2Kkg2KfZhNmF2YXYqtmE2YPYp9iqINin2YTYsdmC2YXZitipINin2YTYrtin2LXYqSDYqNmDXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi2YLZhSDYqNiq2K7YstmK2YYg2Ygg2KfYsdiz2KfZhCDYudmF2YTYp9iq2YMg2Ygg2KPYtdmI2YTZgyDYp9mE2LHZgtmF2YrYqSDYqNij2YXYp9mGXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLYs9is2YQg2KfZhNiv2K7ZiNmEINil2YTZiSDYo9mKINiq2LfYqNmK2YIg2YrYs9iq2K7Yr9mFINmG2YrYsVwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIi7ZhNinINiv2KfYudmKINmE2KXZhti02KfYoSDYrdiz2KfYqCDYrNiv2YrYry4g2YHZgti3INmC2YUg2KjYqtmI2LXZitmEINmF2K3Zgdi42KrZgyDZiNin2YbYt9mE2YJcIixcblx0XHRnZXRBV2FsbGV0OiBcItin2K3YtdmEINi52YTZiSDZhdit2YHYuNipXCIsXG5cdFx0dXNlQVdhbGxldDogXCLYp9iz2KrYrtiv2YUg2YXYrdmB2LjYqSDZhNiq2KPZhdmK2YYg2YjYpdiv2KfYsdipINij2LXZiNmEINmG2YrYsSDYp9mE2K7Yp9i12Kkg2KjZg9iMINmI2KfYr9iu2YQg2YTYo9mKINiq2LfYqNmK2YIg2YrYs9iq2K7Yr9mFINmG2YrYsSDYr9mI2YYg2KfZhNit2KfYrNipINil2YTZiSDYp9iz2YUg2KfZhNmF2LPYqtiu2K/ZhSDZiNmD2YTZhdip2KfZhNmF2LHZiNixXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLYp9iq2LXYp9mEINmB2KfYtNmEXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi2KfYqti12KfZhCDZhtin2KzYrVwiLFxuXHRcdGNvbm5lY3RlZDogXCLZhdiq2LXZhFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLYrNin2LHZiiDYp9mE2KfYqti12KfZhCDYqFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDZhtin2YHYsNipINin2YTYpdi22KfZgdipXCIsXG5cdFx0XHRicm93c2VyOiBcItmI2KfZgdmCINi52YTZiSDYp9mE2KfYqti12KfZhCDZgdmKINin2YTZhdit2YHYuNipINio2LnYryDYpdi52KfYr9ipINiq2YjYrNmK2YdcIixcblx0XHRcdGhhcmR3YXJlOiBcItmI2KfZgdmCINi52YTZiSDYp9mE2KfYqti12KfZhCDZgdmKINis2YfYp9iyINmE2YrYr9is2LFcIixcblx0XHRcdGJyaWRnZTogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYp9mE2YXYrdmB2LjYqVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLYp9iq2LXZhCDZhdi5INmE2YrYr9is2LFcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi2KrYo9mD2K8g2KPZhiDZhNmK2K/YrNixINmF2KrYtdmEINio2KPZhdin2YYsINmIINij2YYg2KrYt9io2YrZgiDZhtmK2LEg2YXZgdiq2YjYrSDZgdmKINis2YfYp9iy2YNcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi2KrYp9io2LlcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItit2K/YryDZhdiz2KfYsSDYp9mE2K3Ys9in2KhcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi2KPYr9iu2YQg2YXYs9in2LEg2KfZhNit2LPYp9ioINin2YTZhdmB2LbZhNiMINir2YUg2KfYqNit2Ksg2LnZhiDZg9mEINin2YTYrdiz2KfYqNin2Kog2KfZhNmG2LTYt9ipXCIsXG5cdFx0c2NhbjogXCLZhdiz2K1cIixcblx0XHRyZXRyeTogXCLYo9i52K8g2KfZhNmF2K3Yp9mI2YTYqVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcItmE2YrYr9is2LEg2LrZitixINmF2KrZiNmB2LFcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLYqtmFINix2YHYtiDYp9mE2KfYqti12KfZhCDYqNmE2YrYr9is2LFcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi2YTZhSDZitiq2YUg2KfZhNi52KvZiNixINi52YTZiSDYo9mKINit2LPYp9io2KfYqlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLYrdiv2K8g2K3Ys9in2KjYp9iq2YNcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YQg2KjYrdiz2KfYqCDZiNin2K3Yr1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLZhNinINmK2YXZg9mGINin2YTYudir2YjYsSDYudmE2Ykg2KPZiiDYrdiz2KfYqCDZhdix2KrYqNi3INio2YfYsNinINmE2YrYr9is2LEg2KfZhNix2KzYp9ihINil2YbYtNin2KEg2K3Ys9in2Kgg2YbZitixINis2K/ZitivINi52YTZiVwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLYp9mIINin2LHYqNi3INis2YfYp9iyINmE2YrYr9is2LEg2KLYrtixXCIsXG5cdFx0Y29ubmVjdGluZzogXCLYrNin2LHZiiDYp9mE2KfYqti12KfZhFwiLFxuXHRcdG9mQWNjb3VudHM6IFwi2YXZhiDYp9mE2K3Ys9in2KjYp9iqXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItmB2LTZhCDZgdmKINin2YTYp9iq2LXYp9mEINio2KfZhNit2LPYp9ioINiq2YTZgtin2KbZitinLiDZitix2KzZiSDYp9mE2KfYqti12KfZhCDYqNin2YTYrdiz2KfYqCDZitiv2YjZitinXCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItmE2KfYptit2Kkg2KfZhNit2LPYp9io2KfYqiDYp9mE2YXYtdix2K0g2KjZh9inLCDYo9mD2YXZhCDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNin2YTZhtmC2LEg2LnZhNmJINin2YTYstixINij2K/Zhtin2YdcIixcblx0XHRmaW5pc2g6IFwi2KXZhtmH2KfYoVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi2LPYqtit2KrYp9isINmE2KrYq9io2YrYqlwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi2YTZhNin2LPYqtmD2YXYp9mELiDYqNi52K8g2KfZhNiq2KvYqNmK2KpcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLZgtmFINio2KrYrdiv2YrYqyDYp9mE2LXZgdit2KlcIixcblx0XHRvcGVuOiBcItin2YHYqtitXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLYqtmFINin2YTZhtiz2K5cIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi2YHYtNmEINin2YTZhtiz2K5cIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi2KfZhdiz2K0g2KjYrNmH2KfYstmDINin2YTZhdit2YXZiNmEXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcItmG2LPYrlwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItiq2YHYttmEINin2YTYrdmI2KfYsSDYp9mE2LHYs9mF2Yog2YRcIixcblx0XHRvcGVuOiBcItmB2KrYrVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgYXIgPSB7XG5cdG1vZGFsOiBtb2RhbCQ0XG59O1xuXG52YXIgbW9kYWwkMyA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiU3Bvaml0ZSBjcnlwdG8gbm92xI1hbmlrIVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwixaB0byBqZSB0byBjcnlwdG8gbm92xI1hbmlrP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJPc2lndXJhanRlIGkgdXByYXZsamFqdGUgc3Zvam9tIGRpZ2l0YWxub20gaW1vdmlub20uXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiU2lndXJubyBwb2hyYW5pdGUgaSBwcmViYWNpdGUgc3ZvaiBjcnlwdG8gaSBORlQtZXZlLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiIFByaWphdml0ZSBzZSB1IGJpbG8ga29qdSBORUFSIGFwbGlrYWNpanVcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJOZW1hIHBvdHJlYmUgemEgc3R2YXJhbmplbSBub3ZpaCBuYWxvZ2EgaWxpIGtvcmlzbmnEjWtpaCBwb2RhdGFrYS4gU3Bvaml0ZSBzdm9qIGNyeXB0byBub3bEjWFuaWsgaSBzcHJlbW5pIHN0ZSFcIixcblx0XHRnZXRBV2FsbGV0OiBcIk90dm9yaXRlIGNyeXB0byBub3bEjWFuaWtcIixcblx0XHR1c2VBV2FsbGV0OiBcIktvcmlzdGl0ZSBjcnlwdG8gbm92xI1hbmlrIGRhIGJpc3RlIG9zaWd1cmFsaSBpIHVwcmF2bGphbGkgc3Zvam9tIE5FQVIgaW1vdmlub20sIHRlIHNlIHByaWphdml0ZSB1IGJpbG8ga29qdSBORUFSIGFwbGlrYWNpanUgYmV6IGtvcmlzbmnEjWtvZyBpbWVuYSBpIGxvemlua2UuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCJOZXVzcGplxaFubyBwb3Zleml2YW5qZS5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJVc3BqZcWhbm8gcG92ZXppdmFuamUuXCIsXG5cdFx0Y29ubmVjdGVkOiBcIlBvdmV6YW5vLlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJQb3Zleml2YW5qZSB1IHRpamVrdVwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCJQb3R2cmRpdGUgdmV6dSB1IGVrc3Rlcm5vbSBwcm96b3J1XCIsXG5cdFx0XHRicm93c2VyOiBcIk5ha29uIHJlZGlyZWtjaWplLCBwb3R2cmRpdGUgdmV6dSB1IG5vdsSNYW5pa3VcIixcblx0XHRcdGhhcmR3YXJlOiBcIlBvdHZyZGl0ZSB2ZXp1IHNhIG5vdsSNYW5pa29tXCIsXG5cdFx0XHRicmlkZ2U6IFwiUG90dnJkaXRlIHZlenUgdSBub3bEjWFuaWt1XCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIlBvdmXFvml0ZSBzZSBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbVwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJPc2lndXJhanRlIHNpZ3VybnUgdmV6dSBzIGhhcmR2ZXJza2ltIG5vdsSNYW5pa29tLCB0ZSBkYSBqZSBORUFSIGFwbGlrYWNpamEgb3R2b3JlbmEgbmEgdmHFoWVtIHVyZcSRYWp1XCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIk5hc3Rhdml0ZVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiU3BlY2lmaWNpcmFqdGUgSEQgcHV0YW5qdVwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCJVcGnFoWl0ZSBwcmVmZXJpcmFudSBIRCBwdXRhbmp1LCB6YXRpbSBza2VuaXJhanRlIGFrdGl2bmUgbmFsb2dlXCIsXG5cdFx0c2NhbjogXCJTa2VuaXJhanRlXCIsXG5cdFx0cmV0cnk6IFwiUG9rdcWhYWp0ZSBwb25vdm5vXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiSGFyZHZlcnNraSBub3bEjWFuaWsgbmlqZSBkb3N0dXBhbi5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJPZGJpamVuIHByaXN0dXAgemEga29yacWhdGVuamVtIGhhcmR2ZXJza29nIG5vdsSNYW5pa2FcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTmFsb3ppIG5pc3UgcHJvbmHEkWVuaVwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJPZGFiZXJpdGUgc3ZvamUgbmFsb2dlXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIlBvdmV6aXZhbmplIDEgbmFsb2dhXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIk5pamUgbW9ndcSHZSBwcm9uYcSHaSBuaXRpIGplZGFuIG5hbG9nIHBvdmV6YW4gcyBvdmltIGhhcmR2ZXJza2ltIG5vdsSNYW5pa29tLiBNb2xpbW8gdmFzLCBrcmVpcmFqdGUgbm92aSBORUFSIG5hbG9nXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIklsaSBwb3Zlxb5pdGUgZHJ1Z2kgaGFyZHZlcnNraSBub3bEjWFuaWsuXCIsXG5cdFx0Y29ubmVjdGluZzogXCJQb3Zleml2YW5qZVwiLFxuXHRcdG9mQWNjb3VudHM6IFwibmFsb2dhXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIk5ldXNwamXFoW5vIGF1dG9tYXRza28gcHJvbmFsYcW+ZW5qZSBJRCBuYWxvZ2EuIFVuZXNpdGUgcnXEjW5vOlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCJQcmVnbGVkYWp0ZSBwb3BpcyBvZG9icmVuaWggbmFsb2dhLCB6YXZyxaFpdGUgcHJpamF2dSBwcml0aXNrb20gbmEgbmnFvmUgcHJpa2F6YW5pIGd1bWIuXCIsXG5cdFx0ZmluaXNoOiBcIlphdnLFoWl0ZVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiIFBvdHJlYm5vIGplIGluc3RhbGlyYXRpIG1vZGFsXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJ6YSBuYXN0YXZhay4gTmFrb24gaW5zdGFsYWNpamVcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJvc3ZqZcW+aXRlIHN0cmFuaWN1LlwiLFxuXHRcdG9wZW46IFwiT3R2b3JpdGUgUVIgbW9kYWxcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIktvcGlyYW5vIHUgbWXEkXVzcHJlbW5pa1wiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJOZXVwc2plxaFubyBrb3BpcmFuamUgdSBtZcSRdXNwcmVtbmlrXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlNrZW5pcmFqdGUgc3ZvamltIG1vYmlsbmltIHVyZcSRYWplbVwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgS29waXJhanRlIHUgbWXEkXVzcHJlbW5pa1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIk9kYWJlcml0ZSBzbHXFvmJlbmkgZGlqYWxvZ1wiLFxuXHRcdG9wZW46IFwiT3R2b3JpdGVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiT2RhYmVyaSBXYWxsZXRcIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCJQcmVuZXNpIHN2b2plIG5hbG9nZVwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwiT2RhYmVyaXRlIHdhbGxldCBrb2ppIG9kZ292YXJhIHZhxaFpbSBwb3RyZWJhbWEgaSBwb2Ryxb5hdmEgdmHFoWUgcG92ZXphbmUgbmFsb2dlLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJPZGFiZXJpIHN2b2plIG5hbG9nZVwiLFxuXHRcdGFmdGVyRGVjaWRlOiBcIk5ha29uIMWhdG8gb2RsdcSNaXRlIGtvamkgd2FsbGV0IGtvcmlzdGl0ZSwgbW/FvmV0ZSBvZGFicmF0aSBrb2plIHJhxI11bmUgxb5lbGl0ZSBwcmViYWNpdGkuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJOZcSHZXRlIG1vxIdpIHByZWJhY2l0aSBuYWxvZ2Uga29qaSBuaXN1IG5pa2FkYSBiaWxpIGtvcmnFoXRlbmkgbmEgTkVBUi11LlwiLFxuXHRcdHdhcm5pbmc6IFwibmUgcG9kcsW+YXZhIGl6dm96IG5hbG9nYSB1IG92b20gdHJlbnV0a3UuIE1vbGltbyBvZGFiZXJpdGUgZHJ1Z2kgd2FsbGV0LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwiT2RhYmVyaSBuYWxvZ2UgemEgcHJpamVub3NcIixcblx0XHRcdGJ1dHRvbjogXCJHZW5lcmlyYWogbG96aW5rdVwiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiTWFrbmkgb2RhYmlyIHNhIHN2aWhcIixcblx0XHRcdHNlbGVjdEFsbDogXCJPZGFiZXJpIHN2ZVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiUHJpamVub3MgbmlqZSBkb3N0dXBhblwiLFxuXHRcdFx0ZXJyb3I6IFwiTmFsb2cgbmUgcG9zdG9qaVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJQb3RyZWJuYSBsZWRnZXIgcG9kcsWha2FcIixcblx0XHRcdG5vQmFsYW5jZTogXCJOYWxvZyBuZW1hIHNyZWRzdGF2YVwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJLb3BpcmFqIHByaXZyZW1lbnUgbG96aW5rdVwiLFxuXHRcdFx0ZGVzYzogXCJCaXQgxIdlIHBvdHJlYm5vIHVuaWpldGkgb3Z1IGxvemlua3UgbmEgcG/EjWV0a3UgaXp2b3phIG5hbG9nYSBuYSBkcnVnaSB3YWxsZXQuXCIsXG5cdFx0XHRidXR0b246IFwiTmFzdGF2aVwiLFxuXHRcdFx0bGFiZWw6IFwiS2xpa25pIHphIGtvcGlqdVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJLb3BpcmFvIHNhbSBpbGkgemFwaXNhbyBsb3ppbmt1XCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJaYXZyxaFpIHByaWplbm9zXCIsXG5cdFx0XHRkZXNjT25lOiBcIllvdSB3aWxsIG5vdyBiZSByZWRpcmVjdGVkIHRvIHRoZSB3YWxsZXQgeW91IHNlbGVjdGVkIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2Zlci5cIixcblx0XHRcdGRlc2NUd286IFwiS2FkYSBqZSB1bm9zIHMgb2RhYnJhbm9nIHdhbGxldGEgemF2csWhZW4sIHByaXRpc25pdGUgZ3VtYiBkYSBiaXN0ZSB6YXZyxaFpbGkgcHJpamVub3MuXCIsXG5cdFx0XHRidXR0b246IFwiWmF2csWhaVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGhyID0ge1xuXHRtb2RhbDogbW9kYWwkM1xufTtcblxudmFyIG1vZGFsJDIgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcItCf0L7QstGA0LfQtdGC0LUg0LPQviDQstCw0YjQuNC+0YIg0L3QvtCy0YfQsNC90LjQuiFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItCo0YLQviDQtSDQvdC+0LLRh9Cw0L3QuNC6P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLQl9Cw0YjRgtC40YLQtdGC0LUg0LPQuCDQuCDRg9C/0YDQsNCy0YPQstCw0ZjRgtC1INGB0L4g0LLQsNGI0LjRgtC1INC00LjQs9C40YLQsNC70L3QuCDRgdGA0LXQtNGB0YLQstCwLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcItCR0LXQt9Cx0LXQtNC90L4g0YHQutC70LDQtNC40YDQsNGY0YLQtSDQuCDQuNC30LLRgNGI0YPQstCw0ZjRgtC1INGC0YDQsNC90YHQsNC60YbQuNC4INGB0L4g0LLQsNGI0LjRgtC1INC60YDQuNC/0YLQviDQuCBORlQuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLQndCw0ZjQsNCy0LXRgtC1INGB0LUg0L3QsCDQutC+0ZjQsCDQsdC40LvQviBORUFSINCw0L/Qu9C40LrQsNGG0LjRmNCwXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3QtdC80LAg0L/QvtGC0YDQtdCx0LAg0LTQsCDQutGA0LXQuNGA0LDRgtC1INC90L7QstC4INGB0LzQtdGC0LrQuCDQuNC70Lgg0LjQvdCz0LXRgNC10L3RhtC40LguINCf0L7QstGA0LfQtdGC0LUg0LPQviDQstCw0YjQuNC+0YIg0L/QsNGA0LjRh9C90LjQuiDQuCDRgdGC0LUg0L/QvtC00LPQvtGC0LLQtdC90LghXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLQndCw0L/RgNCw0LLQtdGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi0JrQvtGA0LjRgdGC0LXRgtC1INC/0LDRgNC40YfQvdC40Log0LfQsCDQtNCwINCz0Lgg0LfQsNGI0YLQuNGC0LjRgtC1INC4INGD0L/RgNCw0LLRg9Cy0LDRgtC1INCy0LDRiNC40YLQtSBORUFSINGB0YDQtdC00YHRgtCy0LAg0Lgg0LTQsCDRgdC1INC90LDRmNCw0LLQuNGC0LUg0L3QsCDQutC+0ZjQsCDQsdC40LvQviBORUFSINCw0L/Qu9C40LrQsNGG0LjRmNCwINCx0LXQtyDQv9C+0YLRgNC10LHQsCDQvtC0INC60L7RgNC40YHQvdC40YfQutC4INC40LzQuNGa0LAg0Lgg0LvQvtC30LjQvdC60LguXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLQn9C+0LLRgNC30YPQstCw0ZrQtdGC0L4g0L3QtSDQsdC10YjQtSDRg9GB0L/QtdGI0L3Qvi5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLQo9GB0L/QtdGI0L3QviDQv9C+0LLRgNC30YPQstCw0ZrQtS5cIixcblx0XHRjb25uZWN0ZWQ6IFwi0J/QvtCy0YDQt9Cw0L3Qvi5cIixcblx0XHRjb25uZWN0aW5nVG86IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LUg0YHQvlwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLQn9C+0YLQstGA0LTQtdGC0LUg0LPQviDQv9C+0LLRgNC30YPQstCw0ZrQtdGC0L4g0LLQviDQtdC60YHRgtC10YDQvdC40L7RgiDQv9GA0L7Qt9C+0YDQtdGGXCIsXG5cdFx0XHRicm93c2VyOiBcItCf0L4g0L/RgNC10YPRgdC80LXRgNGD0LLQsNGa0LXRgtC+LCDQv9C+0YLQstGA0LTQtdGC0LUg0LPQviDQv9C+0LLRgNC30YPQstCw0ZrQtdGC0L4g0L7QtCDQvdC+0LLRh9Cw0L3QuNC+0LrRglwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INGB0L4g0LvQsNC00LXQvSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicmlkZ2U6IFwi0J/QvtGC0LLRgNC00LXRgtC1INGY0LAg0LLRgNGB0LrQsNGC0LAg0LLQviDQvdC+0LLRh9Cw0L3QuNC60L7RglwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLQn9C+0LLRgNC30LXRgtC1INGB0LUg0YHQviDQm9C10Z/QtdGAXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItCe0YHQuNCz0YPRgNCw0ZjRgtC1INGB0LUg0LTQtdC60LAg0LLQsNGI0LjQvtGCINCb0LXRn9C10YAg0LUg0L/QvtCy0YDQt9Cw0L0g0LHQtdC30LHQtdC00L3Qviwg0Lgg0LTQtdC60LAgTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsNGC0LAg0LUg0L7RgtCy0L7RgNC10L3QsCDQvdCwINCy0LDRiNC40L7RgiDRg9GA0LXQtFwiLFxuXHRcdFwiY29udGludWVcIjogXCLQn9GA0L7QtNC+0LvQttC10YLQtVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi0J3QsNCy0LXQtNC10YLQtSDQpdCUINC70L7QutCw0YbQuNGY0LBcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi0JLQvdC10YHQtdGC0LUg0ZjQsCDQstCw0YjQsNGC0LAg0L/RgNC10YTQtdGA0LjRgNCw0L3QsCDQpdCUINC70L7QutCw0YbQuNGY0LAsINCwINC/0L7RgtC+0LAg0YHQutC10L3QuNGA0LDRmNGC0LUg0LTQsCDQs9C4INC90LDRmNC00LXRgtC1INCw0LrRgtC40LLQvdC40YLQtSDRgdC80LXRgtC60LguXCIsXG5cdFx0c2NhbjogXCLQodC60LXQvdC40YDQsNGY0YLQtVwiLFxuXHRcdHJldHJ5OiBcItCe0LHQuNC00LXRgtC1INGB0LUg0L/QvtCy0YLQvtGA0L3QvlwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcItCb0LXRn9C10YDQvtGCINC90LUg0LUg0LTQvtGB0YLQsNC/0LXQvS5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLQn9GA0LjRgdGC0LDQv9C+0YIg0LfQsCDQutC+0YDQuNGB0YLQtdGa0LUg0L3QsCDQm9C10Z/QtdGAINGD0YDQtdC0INC1INC+0LTQsdC40LXQvVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLQndC10LzQsCDQvdCw0ZjQtNC10L3QuCDRgdC80LXRgtC60LhcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi0JjQt9Cx0LXRgNC10YLQtSDQs9C4INCy0LDRiNC40YLQtSDRgdC80LXRgtC60LhcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LUg0L3QsCDQtdC00L3QsCDRgdC80LXRgtC60LBcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi0J3QtSDRgdC1INC90LDRmNC00LXQvdC4INGB0LzQtdGC0LrQuCDQv9C+0LLRgNC30LDQvdC4INGB0L4g0L7QstC+0Zgg0JvQtdGf0LXRgC4g0JLQtSDQvNC+0LvQuNC80LUg0LrRgNC10LjRgNCw0ZjRgtC1INC90L7QstCwIE5FQVIg0YHQvNC10YLQutCwIFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLQuNC70Lgg0L/QvtCy0YDQt9C10YLQtSDQtNGA0YPQsyDQm9C10Z/QtdGALlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LVcIixcblx0XHRvZkFjY291bnRzOiBcItC90LAg0YHQvNC10YLQutC4XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItCd0LXRg9GB0L/QtdGI0L3QviDQsNCy0YLQvtC80LDRgtGB0LrQviDQsdCw0YDQsNGa0LUg0L3QsCDQmNCUINC90LAg0YHQvNC10YLQutCw0YLQsC4g0JLQvdC10YHQtdGC0LUg0LPQviDRgNCw0YfQvdC+OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLQn9GA0LXQs9C70LXQtCDQvdCwINC70LjRgdGC0LDRgtCwINC90LAg0L7QstC70LDRgdGC0LXQvdC4INGB0LzQtdGC0LrQuCwg0LfQsNCy0YDRiNC10YLQtSDRgdC1INC90LDRmNCw0LLQsNGC0LAg0YHQviDQutC70LjQutC90YPQstCw0ZrQtSDQvdCwINC60L7Qv9GH0LXRgtC+INC/0L7QtNC+0LvRgy5cIixcblx0XHRmaW5pc2g6IFwi0JfQsNCy0YDRiNC10YLQtVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi0KLRgNC10LHQsCDQtNCwINC40L3RgdGC0LDQu9C40YDQsNGC0LVcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItC30LAg0LTQsCDQv9GA0L7QtNC+0LvQttC40YLQtS4g0J/QviDQuNC90YHRgtCw0LvQuNGA0LDRmtC10YLQvlwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItCe0YHQstC10LbQtdGC0LUg0ZjQsCDRgdGC0YDQsNC90LDRgtCwLlwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0L3QviDQvdCwINC60LvQuNC/0LHQvtGA0LTQvtGCXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItCd0LXRg9GB0L/QtdGI0L3QviDQutC+0L/QuNGA0LDRmtC1INC90LAg0LrQu9C40L/QsdC+0YDQtFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLQodC60LXQvdC40YDQsNGY0YLQtSDRgdC+INCy0LDRiNC40L7RgiDRgtC10LvQtdGE0L7QvdGB0LrQuCDRg9GA0LXQtFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDRmNGC0LUg0L3QsCDQutC70LjQv9Cx0L7RgNC0XCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi0J/RgNC10YTQtdGA0LjRgNCw0ZjRgtC1INC+0YTQuNGG0LjRmNCw0LvQtdC9INC00LjQsNC70L7QsyDQvdCwXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0YnJvd3NlcjogXCLQndC+0LLRh9Cw0L3QuNC6INC90LAg0LjQvdGC0LXRgNC90LXRgiDQv9GA0LXQu9C40YHRgtGD0LLQsNGHXCIsXG5cdFx0aW5qZWN0ZWQ6IFwi0JXQutGB0YLQtdC90LfQuNGY0LAg0LfQsCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0bW9iaWxlOiBcItCc0L7QsdC40LvQtdC9INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcItCY0L3RgdGC0LDQvdGCINC/0LDRgNC40YfQvdC40LpcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwi0J7QtNCx0LXRgNC10YLQtSDQv9Cw0YDQuNGH0L3QuNC6XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwi0J/RgNC10YTRgNC70LXRgtC1INCz0Lgg0LLQsNGI0LjRgtC1INC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuFwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwi0JjQt9Cx0LXRgNC10YLQtdC9INC90L7QstGH0LDQvdC40Log0LrQvtGYINCz0Lgg0LfQsNC00L7QstC+0LvRg9Cy0LAg0LLQsNGI0LjRgtC1INCx0LDRgNCw0L3RmtCwINC4INCz0Lgg0L/QvtC00LTRgNC20YPQstCwINCy0LDRiNC40YLQtSDQv9C+0LLRgNC30LDQvdC4INC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuC5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi0JjQt9Cx0LXRgNC10YLQtSDQs9C4INCy0LDRiNC40YLQtSDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LhcIixcblx0XHRhZnRlckRlY2lkZTogXCLQntC00LrQsNC60L4g0ZzQtSDQuNC30LHQtdGA0LXRgtC1INC90L7QstGH0LDQvdC40LosINC80L7QttC10YLQtSDQtNCwINC40LfQsdC10YDQtdGC0LUg0LrQvtC4INC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuCDRgdCw0LrQsNGC0LUg0LTQsCDQs9C4INC/0YDQtdGE0YDQu9C40YLQtS5cIixcblx0XHRkaXNjbGFpbWVyOiBcItCd0LUg0LzQvtC20LXRgtC1INC00LAg0L/RgNGE0YDQu9Cw0YLQtSDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60Lgg0LrQvtC4INC90LjQutC+0LPQsNGIINC90LUg0LHQuNC70LUg0L3QsNC00L7Qv9C+0LvQvdCw0YLQuCDQuNC70Lgg0LrQvtGA0LjRgdGC0LXQvdC4INC90LAgTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcItC90LUg0L/QvtC00LTRgNC20YPQstCwINC40LfQstC10LfRg9Cy0LDRmtC1INC90LAg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4INCy0L4g0L7QstC+0Zgg0LzQvtC80LXQvdGCLiDQktC1INC80L7Qu9C40LzQtSDQuNC30LHQtdGA0LXRgtC1INC00YDRg9CzINC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQvdCwINC40L3RgtC10YDQvdC10YIg0L/RgNC10LvQuNGB0YLRg9Cy0LDRh1wiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwi0JXQutGB0YLQtdC90LfQuNGY0LAg0LfQsCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70LXQvSDQvdC+0LLRh9Cw0L3QuNC6XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCLQmNC30LHQtdGA0LXRgtC1INCz0Lgg0LrQvtGA0LjRgdC90LjRh9C60LjRgtC1INGB0LzQtdGC0LrQuCDQt9CwINC00LAg0LPQuCDQv9GA0LXRhNGA0LvQuNGC0LUuXCIsXG5cdFx0XHRidXR0b246IFwi0JTQvtCx0LjRmNGC0LUg0LvQvtC30LjQvdC60LBcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcItCe0YLRgdC10LvQtdC60YLQuNGA0LDRmNGC0LUg0YHQtVwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcItCY0LfQsdC10YDQtdGC0LUg0YHQtVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwi0KLRgNCw0L3RgdGE0LXRgNC+0YIg0LUg0L3QtdC00L7RgdGC0LDQv9C10L1cIixcblx0XHRcdGVycm9yOiBcItCa0L7RgNC40YHQvdC40YfQutCw0YLQsCDRgdC80LXRgtC60LAg0L3QtSDQv9C+0YHRgtC+0LhcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwi0J/QvtGC0YDQtdCx0L3QsCDQtSDQv9C+0LTQtNGA0YjQutCwINC+0LQg0JvQtdGf0LXRgFwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcItCh0LzQtdGC0LrQsNGC0LAg0L3QtSDQtSDRhNC40L3QsNC90YHQuNGA0LDQvdCwXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcItCa0L7Qv9C40YDQsNGY0YLQtSDRmNCwINC/0YDQuNCy0YDQtdC80LXQvdCw0YLQsCDQu9C+0LfQuNC90LrQsFwiLFxuXHRcdFx0ZGVzYzogXCLQjNC1INGC0YDQtdCx0LAg0LTQsCDRmNCwINCy0L3QtdGB0LXRgtC1INC+0LLQsNCwINC70L7Qt9C40L3QutCwINC60L7Qs9CwINGc0LUg0LfQsNC/0L7Rh9C90LXRgtC1INC00LAg0LPQuCDQuNC30LLQtdC30YPQstCw0YLQtSDQstCw0YjQuNGC0LUg0YHQvNC10YLQutC4INC90LAg0LTRgNGD0LMg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHRcdGJ1dHRvbjogXCLQn9GA0L7QtNC+0LvQttC10YLQtVwiLFxuXHRcdFx0bGFiZWw6IFwi0JrQu9C40LrQvdC10YLQtSDQt9CwINC00LAg0LrQvtC/0LjRgNCw0YLQtVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCLQiNCwINC60L7Qv9C40YDQsNCyINC40LvQuCDQt9Cw0L/QuNGI0LDQsiDQu9C+0LfQuNC90LrQsNGC0LBcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcItCX0LDQstGA0YjQtdGC0LUg0LPQviDQv9GA0LXQvdC+0YHQvtGCXCIsXG5cdFx0XHRkZXNjT25lOiBcItCh0LXQs9CwINGc0LUg0LHQuNC00LXRgtC1INC/0YDQtdC90LDRgdC+0YfQtdC90Lgg0L3QsCDQuNC30LHRgNCw0L3QuNC+0YIg0L3QvtCy0YfQsNC90LjQuiDQt9CwINC30LDQstGA0YjRg9Cy0LDRmtC1INC90LAg0L/RgNC10L3QvtGB0L7Rgi5cIixcblx0XHRcdGRlc2NUd286IFwi0J7RgtC60LDQutC+INGc0LUg0LfQsNCy0YDRiNC4INGD0LLQvtC30L7RgiDQvtC0INC40LfQsdGA0LDQvdC40L7RgiDQvdC+0LLRh9Cw0L3QuNC6LCDQv9GA0LjRgtC40YHQvdC10YLQtSDQs9C+INC60L7Qv9GH0LXRgtC+INC30LAg0LTQsCDQs9C+INC30LDQstGA0YjQuNGC0LUg0L/RgNC10L3QvtGB0L7Rgi5cIixcblx0XHRcdGJ1dHRvbjogXCLQl9Cw0LLRgNGI0LXRgtC1XCJcblx0XHR9XG5cdH1cbn07XG52YXIgbWsgPSB7XG5cdG1vZGFsOiBtb2RhbCQyXG59O1xuXG52YXIgbW9kYWwkMSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiUG92ZcW+aXRlIHN2b2pvIGRlbmFybmljbyFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIkthaiBqZSBkZW5hcm5pY2E/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlphdmFydWp0ZSBpbiB1cHJhdmxqYWp0ZSBzdm9qYSBkaWdpdGFsbmEgc3JlZHN0dmEuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiVmFybm8gc2hyYW5qdWp0ZSBpbiBwcmVuYcWhYWp0ZSBzdm9qZSBrcmlwdG92YWx1dGUgaW4gTkZUamUuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJQcmlqYXZpdGUgc2UgdiBrYXRlcm8ga29saSBhcGxpa2FjaWpvIG5hIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJOaSB2YW0gdHJlYmEgdXN0dmFyamF0aSBub3ZpaCByYcSNdW5vdi4gUG92ZcW+aXRlIHN2b2pvIGRlbmFybmljbyBpbiB6YcSNbml0ZSFcIixcblx0XHRnZXRBV2FsbGV0OiBcIlVzdHZhcml0ZSBkZW5hcm5pY29cIixcblx0XHR1c2VBV2FsbGV0OiBcIlVwb3JhYml0ZSBkZW5hcm5pY28sIGRhIGJpIHphdmFyb3ZhbGkgaW4gdXByYXZsamFsaSBzIHN2b2phIE5FQVIgZGlnaXRhbG5hIHNyZWRzdHZhLCBpbiBzZSBwcmlqYXZpdGUgdiBrYXRlcm8ga29saSBhcGxpa2FjaWpvIGVrb3Npc3RlbWEgTkVBUlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiUG92ZXphdmEgbmkgYmlsYSB1c3BlxaFuYS5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJQb3ZlemF2YSBqZSBiaWxhIHVzcGXFoW5hLlwiLFxuXHRcdGNvbm5lY3RlZDogXCJWYcWhYSBkZW5hcm5pY2EgamUgcG92ZXphbmEuXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIlBvdmV6b3ZhbmplIHpcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiUG90cmRpdGUgcG92ZXphdm8gdiBva251IHJhesWhaXJpdHZlXCIsXG5cdFx0XHRicm93c2VyOiBcIlBvIHByZXVzbWVyaXR2aSBwb3RyZGl0ZSBwb3ZlemF2byB2IGRlbmFybmljaVwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiUG90cmRpdGUgcG92ZXphdm8gcyBobGFkbm8gZGVuYXJuaWNvXCIsXG5cdFx0XHRicmlkZ2U6IFwiUG90cmRpdGUgcG92ZXphdm8gdiBkZW5hcm5pY2lcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiUG92ZcW+aXRlIHNlIHogTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIlByZXByacSNYWp0ZSBzZSwgZGEgamUgdmHFoSBMZWRnZXIgdmFybm8gcG92ZXphbiBpbiBkYSBqZSBhcGxpa2FjaWphIE5FQVIgb2RwcnRhIHYgdmHFoWkgbmFwcmF2aVwiLFxuXHRcdFwiY29udGludWVcIjogXCJOYWRhbGp1alwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiRG9sb8SNaXRlIEhEIHBvdFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCJWbmVzaXRlIMW+ZWxlbm8gSEQgcG90LCBuYXRvIHBvacWhxI1pdGUgdnNlIGFrdGl2bmUgcmHEjXVuZS5cIixcblx0XHRzY2FuOiBcIlNrZW5pcmFqdGVcIixcblx0XHRyZXRyeTogXCJQb3NrdXNpdGUgem5vdmFcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIgbmkgbmEgdm9sam9cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJEb3N0b3AgemEgdXBvcmFibyBuYXByYXZlIExlZGdlciB6YXZybmplblwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJOaSBuYWpkZW5paCByYcSNdW5vdlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJJemJlcml0ZSBWYcWhaSByYcSNdW5pXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIlBvdmV6b3ZhbmplIGVuZWdhIHJhxI11bmFcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTmkgbW9nb8SNZSBuYWp0aSBub2JlbmVnYSByYcSNdW5hLCBwb3ZlemFuZWdhIHMgdGVtIExlZGdlcmplbS4gVXN0dmFyaXRlIG5vdiBORUFSIHJhxI11biBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwiYWxpIHBvdmXFvml0ZSBkcnVnIExlZGdlci4uXCIsXG5cdFx0Y29ubmVjdGluZzogXCJQb3Zlem92YW5qZVwiLFxuXHRcdG9mQWNjb3VudHM6IFwicmHEjXVub3ZcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiSUQtamEgcmHEjXVuYSBuaSBiaWxvIG1vZ2/EjWUgc2Ftb2Rlam5vIG5hanRpLiBaYWdvdG92aXRlIGdhIHJvxI1ubzpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiT2dsZWp0ZSBzaSBzZXpuYW0gcG9vYmxhxaHEjWVuaWggcmHEjXVub3YsIGRva29uxI1hanRlIHByaWphdm8gcyBrbGlrb20gbmEgc3BvZG5qaSBndW1iLlwiLFxuXHRcdGZpbmlzaDogXCJLb27EjWFqdGVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIk1vcmFsaSBnYSBib3N0ZSBuYW1lc3RpdGlcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIm5hZGFsamV2YXRpLiBQbyBuYW1lc3RpdHZpXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiT3N2ZcW+aXRlIHN0cmFuLlwiLFxuXHRcdG9wZW46IFwiT2Rwcml0ZVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiS29waXJhbm8gdiBwb2Rsb8W+bmkgbWFwaVwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJLb3BpcmFuamUgdiBwb2Rsb8W+bmkgbWFwaSBuaSB1c3BlbG9cIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiU2tlbmlyYWp0ZSBzIHN2b2pvIG1vYmlsbm8gbmFwcmF2b1wiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgS29waXJhanRlIHYgcG9kbG/Fvm5pIG1hcGlcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJQcmVmZXJpcmFqdGUgdXJhZG5vIHBvZ292b3JubyBva25vXCIsXG5cdFx0b3BlbjogXCJPZHByaXRlXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIbGFkbmEgZGVuYXJuaWNhXCIsXG5cdFx0YnJvd3NlcjogXCJEZW5hcm5pY2EgYnJza2FsbmlrYVwiLFxuXHRcdGluamVjdGVkOiBcIlJhesWhaXJpdGV2IHphIGRlbmFybmljb1wiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgZGVuYXJuaWNhXCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsbmEgZGVuYXJuaWNhXCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJUYWtvasWhbmphIGRlbmFybmljYVwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJJemJlcml0ZSBkZW5hcm5pY29cIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCJQcmVuZXNpdGUgc3ZvamUgcmHEjXVuZVwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwiSXpiZXJpdGUgZGVuYXJuaWNvLCBraSB1c3RyZXphIHZhxaFpbSBwb3RyZWJhbSBpbiBwb2RwaXJhIHZhxaFlIHBvdmV6YW5lIHJhxI11bmUuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkl6YmVyaXRlIHZhxaFpIHJhxI11bmlcIixcblx0XHRhZnRlckRlY2lkZTogXCJLbyBzZSBvZGxvxI1pdGUgemEgZGVuYXJuaWNvLCBsYWhrbyBpemJlcmV0ZSwga2F0ZXJlIHJhxI11bmUgxb5lbGl0ZSBwcmVuZXN0aS5cIixcblx0XHRkaXNjbGFpbWVyOiBcIk5lIGJvc3RlIG1vZ2xpIHByZW5lc3RpIFJhxI11bm92LCBraSBuaWtvbGkgbmlzbyBiaWxpIGZpbmFuY2lyYW5pIGFsaSB1cG9yYWJsamVuaSBuYSBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwidHJlbnV0bm8gbmUgcG9kcGlyYSBpenZvemEgcmHEjXVuYS4gSXpiZXJpdGUgZHJ1Z28gZGVuYXJuaWNvXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcIkhsYWRuYSBkZW5hcm5pY2FcIixcblx0XHRcdGJyb3dzZXI6IFwiRGVuYXJuaWNhIGJyc2thbG5pa2FcIixcblx0XHRcdGluamVjdGVkOiBcIlJhesWhaXJpdGV2IHphIGRlbmFybmljb1wiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSBkZW5hcm5pY2FcIixcblx0XHRcdG1vYmlsZTogXCJNb2JpbG5hIGRlbmFybmljYVwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwiSXpiZXJpdGUgcmHEjXVuaSB6YSBwcmVub3MuXCIsXG5cdFx0XHRidXR0b246IFwiUHJpZG9iaXRlIGdlc2xvXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJQcmVrbGnEjWkgaXpiaXJvIHZzZWhcIixcblx0XHRcdHNlbGVjdEFsbDogXCJJemJlcmkgdnNlXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJQcmVub3MgbmkgbmEgdm9sam9cIixcblx0XHRcdGVycm9yOiBcIlJhxI11biBuZSBvYnN0YWphXCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcIlBvdHJlYm5hIGplIHBvZHBvcmEgemEgTGVkZ2VyXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiUmHEjXVuIG5pIGZpbmFuY2lyYW5cIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiS29waXJhaiB6YcSNYXNubyBnZXNsb1wiLFxuXHRcdFx0ZGVzYzogXCJUbyBnZXNsbyBib3N0ZSBtb3JhbGkgdm5lc3RpLCBrbyBib3N0ZSB6YcSNZWxpIGl6dmHFvmF0aSBzdm9qZSByYcSNdW5lIHYgZHJ1Z28gZGVuYXJuaWNvLlwiLFxuXHRcdFx0YnV0dG9uOiBcIk5hZGFsanVqdGVcIixcblx0XHRcdGxhYmVsOiBcIktsaWtuaXRlIHphIGtvcGlyYW5qZVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJHZXNsbyBzZW0ga29waXJhbCBhbGkgemFwaXNhbFwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiRG9rb27EjWFqdGUgcHJlbm9zXCIsXG5cdFx0XHRkZXNjT25lOiBcIlpkYWogYm9zdGUgcHJldXNtZXJqZW5pIHYgZGVuYXJuaWNvLCBraSBzdGUgam8gaXpicmFsaSB6YSBkb2tvbsSNYW5qZSBwcmVub3NhLlwiLFxuXHRcdFx0ZGVzY1R3bzogXCJLbyBqZSB1dm96bmkgZGVsIHBvc3RvcGthIGtvbsSNYW4gaXogaXpicmFuZSBkZW5hcm5pY2UsIHByaXRpc25pdGUgZ3VtYiB6YSBkb2tvbsSNYW5qZSBwb3N0b3BrYSBwcmVub3NhLlwiLFxuXHRcdFx0YnV0dG9uOiBcIktvbsSNYWp0ZVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIHNsID0ge1xuXHRtb2RhbDogbW9kYWwkMVxufTtcblxudmFyIG1vZGFsID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQn9C+0LLQtdC20LjRgtC1INGB0LLQvtGYINC90L7QstGH0LDQvdC40LohXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLQqNGC0LAg0ZjQtSDQvdC+0LLRh9Cw0L3QuNC6P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLQntCx0LXQt9Cx0LXQtNC40YLQtSDQuCDRg9C/0YDQsNCy0ZnQsNGY0YLQtSDRgdCy0L7RmNC+0Lwg0LTQuNCz0LjRgtCw0LvQvdC+0Lwg0LjQvNC+0LLQuNC90L7QvC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLQkdC10LfQsdC10LTQvdC+INGH0YPQstCw0ZjRgtC1INC4INC/0YDQtdC90L7RgdC40YLQtSDRgdCy0L7RmNC1INC60YDQuNC/0YLQvtCy0LDQu9GD0YLQtSDQuCBORlQuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLQn9GA0LjRmNCw0LLQuNGC0LUg0YHQtSDQvdCwINCx0LjQu9C+INC60L7RmNGDINCw0L/Qu9C40LrQsNGG0LjRmNGDIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLQndC10LzQsCDQv9C+0YLRgNC10LHQtSDQtNCwINC60YDQtdC40YDQsNGC0LUg0L3QvtCy0LUg0L3QsNC70L7Qs9C1INC40LvQuCDQsNC60YDQtdC00LjRgtC40LLQtS4g0J/QvtCy0LXQttC40YLQtSDQvdC+0LLRh9Cw0L3QuNC6INC4INGB0L/RgNC10LzQvdC4INGB0YJlIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0J3QsNCx0LDQstC40YLQtSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0dXNlQVdhbGxldDogXCLQmtC+0YDQuNGB0YLQuNGC0LUg0L3QvtCy0YfQsNC90LjQuiDQtNCwINC+0LHQtdC30LHQtdC00LjRgtC1INC4INGD0L/RgNCw0LLRmdCw0YLQtSDRgdCy0L7RmNC40LwgTkVBUiDRgdGA0LXQtNGB0YLQstC40LzQsCDQuCDQtNCwINGB0LUg0L/RgNC40ZjQsNCy0LjRgtC1INGDINCx0LjQu9C+INC60L7RmNGDINCw0L/Qu9C40LrQsNGG0LjRmNGDIE5FQVIg0LHQtdC3INC/0L7RgtGA0LXQsdC1INC30LAg0LrQvtGA0LjRgdC90LjRh9C60LjQvCDQuNC80LXQvdC40LzQsCDQuCDQu9C+0LfQuNC90LrQsNC80LAuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLQktC10LfQsCDQvdC40ZjQtSDRg9GB0L/QvtGB0YLQsNCy0ZnQtdC90LAuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi0JLQtdC30LAg0ZjQtSDRg9GB0L/QtdC70LAuXCIsXG5cdFx0Y29ubmVjdGVkOiBcItCf0L7QstC10LfQsNC9LlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLQn9C+0LLQtdC30LjQstCw0ZrQtSDQvdCwXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcItCf0L7RgtCy0YDQtNC40YLQtSDQstC10LfRgyDRgyDRgdC/0L7RmdC90L7QvCDQv9GA0L7Qt9C+0YDRg1wiLFxuXHRcdFx0YnJvd3NlcjogXCLQndCw0LrQvtC9INC/0YDQtdGD0YHQvNC10YDQsNCy0LDRmtCwLCDQv9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YMg0L3QvtCy0YfQsNC90LjQutGDXCIsXG5cdFx0XHRoYXJkd2FyZTogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YHQsCDRhdC70LDQtNC90LjQvCDQvdC+0LLRh9Cw0L3QuNC60L7QvFwiLFxuXHRcdFx0YnJpZGdlOiBcItCf0L7RgtCy0YDQtNC40YLQtSDQstC10LfRgyDRgdCwINC90L7QstGH0LDQvdC40LrQvtC8XCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcItCf0L7QstC10LbQuNGC0LUg0YHQtSDRgdCwIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQo9Cy0LXRgNC40YLQtSDRgdC1INC00LAg0ZjQtSDQstCw0YggTGVkZ2VyINCx0LXQt9Cx0LXQtNC90L4g0L/QvtCy0LXQt9Cw0L0g0Lgg0LTQsCDRmNC1INCw0L/Qu9C40LrQsNGG0LjRmNCwIE5FQVIg0L7RgtCy0L7RgNC10L3QsCDQvdCwINCy0LDRiNC10Lwg0YPRgNC10ZLQsNGY0YNcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J3QsNGB0YLQsNCy0LhcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCd0LDQstC10LTQuNGC0LUg0KXQlCDQv9GD0YLQsNGa0YNcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi0KPQvdC10YHQuNGC0LUg0LbQtdGZ0LXQvdGDINC20LXRmdC10L3RgyDQpdCUINC/0YPRgtCw0ZrRgywg0LAg0LfQsNGC0LjQvCDRgdC60LXQvdC40YDQsNGY0YLQtSDRgdCy0LUg0LDQutGC0LjQstC90LUg0L3QsNC70L7Qs9C1LlwiLFxuXHRcdHNjYW46IFwi0KHQutC10L3QuNGA0LDRmNGC0LVcIixcblx0XHRyZXRyeTogXCLQn9C+0LrRg9GI0LDRmCDQv9C+0L3QvtCy0L5cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIg0L3QuNGY0LUg0LTQvtGB0YLRg9C/0LDQvS5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLQn9GA0LjRgdGC0YPQvyDRmNC1INC+0LTQsdC40ZjQtdC9INC30LAg0LrQvtGA0LjRiNGb0LXRmtC1IExlZGdlciDRg9GA0LXRktCw0ZjQsFwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLQndCwbNC+0LfQuCDQvdC40YHRgyDQv9GA0L7QvdCw0ZLQtdC90LhcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INCS0LDRiCDQvdCwbNC+0LNcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi0J/QvtCy0LXQt9Cw0YLQuCAxINC90LBs0L7Qs1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLQndC40ZjQtSDQvNC+0LPRg9Gb0LUg0L/RgNC+0L3QsNGb0Lgg0L3QuNGY0LXQtNCw0L0g0L3QsGzQvtCzINC/0L7QstC10LfQsNC9INGB0LAg0L7QstC40LwgTGVkZ2VyLdC+0LwuINCd0LDQv9GA0LDQstC40YLQtSDQvdC+0LLQuCBORUFSINC90LBs0L7Qs1wiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLQuNC70Lgg0L/QvtCy0LXQttC40YLQtSDQtNGA0YPQs9C4IExlZGdlci5cIixcblx0XHRjb25uZWN0aW5nOiBcItCf0L7QstC10LfQuNCy0LDRmtC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvdCwbNC+0LPQsFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLQkNGD0YLQvtC80LDRgtGB0LrQviDQv9GA0L7QvdCw0LvQsNC20LXRmtC1IElELWEg0L3QsGzQvtCz0LAg0L3QuNGY0LUg0YPRgdC/0LXQu9C+LiDQndCw0LLQtdC00LjRgtC1INCz0LAg0YDRg9GH0L3QvjpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi0J/RgNC10LPQu9C10LTQsNGY0YLQtSDQu9C40YHRgtGDINC+0LLQu9Cw0YjRm9C10L3QuNGFINGA0LDRh9GD0L3QsCwg0LfQsNCy0YDRiNC40YLQtSDQv9GA0LjRmNCw0LLRgyDQutC70LjQutC+0Lwg0L3QsCDQtNGD0LPQvNC1INC40YHQv9C+0LQuXCIsXG5cdFx0ZmluaXNoOiBcItCX0LDQstGA0YjQuFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi0JzQvtGA0LDRm9C10YLQtSDQtNCwINC40L3RgdGC0LDQu9C40YDQsNGC0LVcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItC30LAg0L3QsNGB0YLQsNCy0LDQui4g0J3QsNC60L7QvSDQuNC90YHRgtCw0LvQuNGA0LDRmtCwXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi0L/QvtC90L7QstC+INGD0YfQuNGC0LDRgtC4INGB0YLRgNCw0L3QuNGG0YMuXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LhcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNC90L4g0YMg0LzQtdGS0YPRgdC/0YDQtdC80L3QuNC6XCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItCa0L7Qv9C40YDQsNGa0LUg0YMg0LzQtdGS0YPRgdC/0YDQtdC80L3QuNC6INC90LjRmNC1INGD0YHQv9C10LvQvlwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLQodC60LXQvdC40YDQsNGY0YLQtSDQv9C+0LzQvtGb0YMg0LzQvtCx0LjQu9C90L7QsyDRg9GA0LXRktCw0ZjQsFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIg0JrQvtC/0LjRgNCw0Zgg0YMg0LzQtdGS0YPRgdC/0YDQtdC80L3QuNC6XCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi0J/RgNC10YTQtdGA0LjRgNCw0YLQtSDQt9Cy0LDQvdC40YfQvdC4INC00LjRmNCw0LvQvtCzINC+0LRcIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQuFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQv9GA0LXRgtGA0LDQttC40LLQsNGH0LAsXCIsXG5cdFx0aW5qZWN0ZWQ6IFwi0JTQvtC00LDRgtCw0Log0LfQsCDQvdC+0LLRh9Cw0L3QuNC6LFwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70L3QuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCLQmNC90YHRgtCw0L3RgiDQvdC+0LLRh9Cw0L3QuNC6XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcItCY0LfQsNCx0LXRgNC40YLQtSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwi0J/RgNC10L3QtdGB0LjRgtC1INGB0LLQvtGY0LUg0L3QsNC70L7Qs9C1XCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QvtCy0YfQsNC90LjQuiDQutC+0ZjQuCDQvtC00LPQvtCy0LDRgNCwINCy0LDRiNC40Lwg0L/QvtGC0YDQtdCx0LDQvNCwINC4INC60L7RmNC4INC/0L7QtNGA0LbQsNCy0LAg0LLQsNGI0LUg0L/QvtCy0LXQt9Cw0L3QtSDQvdCw0LvQvtCz0LUuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsNCx0LXRgNC40YLQtSDQstCw0YjQtSDQvdCw0LvQvtCz0LVcIixcblx0XHRhZnRlckRlY2lkZTogXCLQndCw0LrQvtC9INGI0YLQviDRgdC1INC+0LTQu9GD0YfQuNGC0LUg0LfQsCDQvdC+0LLRh9Cw0L3QuNC6LCDQvNC+0LbQtdGC0LUg0LjQt9Cw0LHRgNCw0YLQuCDQutC+0ZjQtSDQvdCw0LvQvtCz0LUg0LbQtdC70LjRgtC1INC00LAg0L/RgNC10L3QtdGB0LXRgtC1LlwiLFxuXHRcdGRpc2NsYWltZXI6IFwi0J3QtdGb0LXRgtC1INC80L7Rm9C4INC00LAg0L/RgNC10L3QtdGB0LXRgtC1INC90LDQu9C+0LPQtSDQutC+0ZjQuCDQvdC40LrQsNC00LAg0L3QuNGB0YMg0LHQuNC70Lgg0YTQuNC90LDQvdGB0LjRgNCw0L3QuCDQuNC70Lgg0LrQvtGA0LjRiNGb0LXQvdC4INC90LAgIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCLRgtGA0LXQvdGD0YLQvdC+INC90LUg0L/QvtC00YDQttCw0LLQsCDQuNC30LLQvtC3INC90LDQu9C+0LPQsC4g0JjQt9Cw0LHQtdGA0LjRgtC1INC00YDRg9Cz0Lgg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJvd3NlcjogXCLQndC+0LLRh9Cw0L3QuNC6INC/0YDQtdGC0YDQsNC20LjQstCw0YfQsCxcIixcblx0XHRcdGluamVjdGVkOiBcItCU0L7QtNCw0YLQsNC6INC30LAg0L3QvtCy0YfQsNC90LjQuixcIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0bW9iaWxlOiBcItCc0L7QsdC40LvQvdC4INC90L7QstGH0LDQvdC40LpcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcItCY0LfQsNCx0LXRgNC40YLQtSDQvdCw0LvQvtCz0LUg0LfQsCDQv9GA0LXQvdC+0YEuXCIsXG5cdFx0XHRidXR0b246IFwi0JTQvtCx0LjRmNGC0LUg0L/RgNC40YHRgtGD0L/QvdGDINGE0YDQsNC30YNcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcItCf0L7QvdC40YjRgtC40YLQtSDQuNC30LHQvtGAXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INGB0LLQtVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwi0KLRgNCw0L3RgdGE0LXRgCDQvdC40ZjQtSDQtNC+0YHRgtGD0L/QsNC9XCIsXG5cdFx0XHRlcnJvcjogXCLQndCw0LvQvtCzINC90LUg0L/QvtGB0YLQvtGY0LhcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwi0J/QvtGC0YDQtdCx0L3QsCDQv9C+0LTRgNGI0LrQsCDQt9CwIExlZGdlclwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcItCd0LDQu9C+0LMg0L3QuNGY0LUg0YTQuNC90LDQvdGB0LjRgNCw0L1cIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwi0JrQvtC/0LjRgNCw0Zgg0L/RgNC40LLRgNC10LzQtdC90YMg0LvQvtC30LjQvdC60YNcIixcblx0XHRcdGRlc2M6IFwi0JzQvtGA0LDRm9C10YLQtSDQtNCwINGD0L3QtdGB0LXRgtC1INC+0LLRgyDQu9C+0LfQuNC90LrRgyDQutCw0LTQsCDQv9C+0YfQvdC10YLQtSDQtNCwINC40LfQstC+0LfQuNGC0LUg0YHQstC+0ZjQtSDQvdCw0LvQvtCz0LUg0YMg0LTRgNGD0LPQuCDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdFx0YnV0dG9uOiBcItCd0LDRgdGC0LDQstC40YLQtVwiLFxuXHRcdFx0bGFiZWw6IFwi0JrQu9C40LrQvdC40YLQtSDQtNCwINCx0LjRgdGC0LUg0LrQvtC/0LjRgNCw0LvQuFwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCLQmtC+0L/QuNGA0LDQviDRgdCw0Lwg0LjQu9C4INC30LDQv9C40YHQsNC+INC70L7Qt9C40L3QutGDXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCLQlNC+0LLRgNGI0LjRgtC1INGC0YDQsNC90YHRhNC10YBcIixcblx0XHRcdGRlc2NPbmU6IFwi0KHQsNC00LAg0ZvQtdGC0LUg0LHQuNGC0Lgg0L/RgNC10YPRgdC80LXRgNC10L3QuCDQvdCwINC90L7QstGH0LDQvdC40Log0LrQvtGY0Lgg0YHRgtC1INC40LfQsNCx0YDQsNC70Lgg0LTQsCDQt9Cw0LLRgNGI0LjRgtC1INGC0YDQsNC90YHRhNC10YAuXCIsXG5cdFx0XHRkZXNjVHdvOiBcItCa0LDQtNCwINGB0LUg0LTQtdC+INC/0YDQvtGG0LXRgdCwINGD0LLQvtC30LAg0LfQsNCy0YDRiNC4INC40Lcg0LjQt9Cw0LHRgNCw0L3QvtCzINC90L7QstGH0LDQvdC40LrQsCwg0L/RgNC40YLQuNGB0L3QuNGC0LUg0LTRg9Cz0LzQtSDQtNCwINC30LDQstGA0YjQuNGC0LUg0L/RgNC+0YbQtdGBINC/0YDQtdC90L7RgdCwLlwiLFxuXHRcdFx0YnV0dG9uOiBcItCX0LDQstGA0YjQuNGC0LVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBzciA9IHtcblx0bW9kYWw6IG1vZGFsXG59O1xuXG5jb25zdCBnZXRMYW5ndWFnZSA9IGxhbmd1YWdlQ29kZSA9PiB7XG4gIHN3aXRjaCAobGFuZ3VhZ2VDb2RlKSB7XG4gICAgY2FzZSBcImVuXCI6XG4gICAgICByZXR1cm4gZW47XG4gICAgY2FzZSBcImVzXCI6XG4gICAgICByZXR1cm4gZXM7XG4gICAgY2FzZSBcInpoXCI6XG4gICAgICByZXR1cm4gemg7XG4gICAgY2FzZSBcImJnXCI6XG4gICAgICByZXR1cm4gYmc7XG4gICAgY2FzZSBcImtvXCI6XG4gICAgICByZXR1cm4ga287XG4gICAgY2FzZSBcInZpXCI6XG4gICAgICByZXR1cm4gdmk7XG4gICAgY2FzZSBcImhpXCI6XG4gICAgICByZXR1cm4gaGk7XG4gICAgY2FzZSBcImFyXCI6XG4gICAgICByZXR1cm4gYXI7XG4gICAgY2FzZSBcImhyXCI6XG4gICAgICByZXR1cm4gaHI7XG4gICAgY2FzZSBcIm1rXCI6XG4gICAgICByZXR1cm4gbWs7XG4gICAgY2FzZSBcInNsXCI6XG4gICAgICByZXR1cm4gc2w7XG4gICAgY2FzZSBcInNyXCI6XG4gICAgICByZXR1cm4gc3I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBlbjtcbiAgfVxufTtcbmxldCBjaG9zZW5MYW5nO1xuY29uc3QgYWxsb3dPbmx5TGFuZ3VhZ2UgPSBsYW5nQ29kZSA9PiB7XG4gIGNob3NlbkxhbmcgPSBsYW5nQ29kZTtcbn07XG4vLyAoaS5lIGVuLUNBIHJldHVybnMganVzdCBlbilcbmNvbnN0IHNob3J0ZW5MYW5ndWFnZUNvZGUgPSBsYW5nID0+IHtcbiAgcmV0dXJuIGxhbmcuaW5kZXhPZihcIi1cIikgIT09IC0xID8gbGFuZy5zcGxpdChcIi1cIilbMF0gOiBsYW5nLnNwbGl0KFwiX1wiKVswXTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgZmluZE9iamVjdFByb3BCeVN0cmluZ1BhdGggPSAob2JqLCBwcm9wKSA9PiB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgX2luZGV4ID0gcHJvcC5pbmRleE9mKFwiLlwiKTtcbiAgaWYgKF9pbmRleCA+IC0xKSB7XG4gICAgY29uc3QgY3VycmVudFByb3AgPSBwcm9wLnN1YnN0cmluZygwLCBfaW5kZXgpO1xuICAgIGNvbnN0IG5leHRQcm9wID0gcHJvcC5zdWJzdHJpbmcoX2luZGV4ICsgMSk7XG4gICAgcmV0dXJuIGZpbmRPYmplY3RQcm9wQnlTdHJpbmdQYXRoKG9ialtjdXJyZW50UHJvcF0sIG5leHRQcm9wKTtcbiAgfVxuICByZXR1cm4gb2JqW3Byb3BdO1xufTtcbmNvbnN0IHRyYW5zbGF0ZSA9IHBhdGggPT4ge1xuICBsZXQgYnJvd3NlckxhbmcgPSB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlcyA/IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIDogbnVsbDtcbiAgYnJvd3NlckxhbmcgPSBicm93c2VyTGFuZyB8fCB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlO1xuICBjb25zdCBsYW5ndWFnZUNvZGUgPSBzaG9ydGVuTGFuZ3VhZ2VDb2RlKGNob3NlbkxhbmcgfHwgYnJvd3NlckxhbmcpO1xuICBjb25zdCBzZWxlY3RlZExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKTtcbiAgY29uc3QgdGV4dCA9IGZpbmRPYmplY3RQcm9wQnlTdHJpbmdQYXRoKHNlbGVjdGVkTGFuZ3VhZ2UsIHBhdGgpO1xuICByZXR1cm4gdGV4dCAmJiB0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIiA/IHRleHQgOiBwYXRoO1xufTtcblxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyLCBhbGxvd09ubHlMYW5ndWFnZSwgZ2V0QWN0aXZlQWNjb3VudCwgaXNDdXJyZW50QnJvd3NlclN1cHBvcnRlZCwgc2VyaWFsaXplTmVwNDEzLCBzZXR1cFdhbGxldFNlbGVjdG9yLCB0cmFuc2xhdGUsIHZlcmlmeUZ1bGxLZXlCZWxvbmdzVG9Vc2VyLCB2ZXJpZnlTaWduYXR1cmUsIHdhaXRGb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/here-wallet/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupHereWallet: () => (/* binding */ setupHereWallet)\n/* harmony export */ });\n/* harmony import */ var _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @here-wallet/core */ \"(ssr)/./node_modules/@here-wallet/core/build/index.js\");\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$a = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$9 = fails$a;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$8 = fails$a;\n\nvar functionBindNative = !fails$8(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar call$6 = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$1 ? call$6.bind(call$6) : function () {\n  return call$6.apply(call$6, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$1(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$2 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND = functionBindNative;\n\nvar FunctionPrototype$1 = Function.prototype;\nvar bind = FunctionPrototype$1.bind;\nvar call$5 = FunctionPrototype$1.call;\nvar uncurryThis$a = NATIVE_BIND && bind.bind(call$5, call$5);\n\nvar functionUncurryThis = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis$a(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$5.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$9 = functionUncurryThis;\n\nvar toString$2 = uncurryThis$9({}.toString);\nvar stringSlice = uncurryThis$9(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice(toString$2(it), 8, -1);\n};\n\nvar uncurryThis$8 = functionUncurryThis;\nvar fails$7 = fails$a;\nvar classof$2 = classofRaw$1;\n\nvar $Object$3 = Object;\nvar split = uncurryThis$8(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$7(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$3('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$2(it) == 'String' ? split(it, '') : $Object$3(it);\n} : $Object$3;\n\nvar $TypeError$5 = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (it == undefined) throw $TypeError$5(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\n\nvar toIndexedObject$3 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$1(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$b = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$a = isCallable$b;\n\nvar isObject$5 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$a(it);\n};\n\nvar global$9 = global$a;\nvar isCallable$9 = isCallable$b;\n\nvar aFunction = function (argument) {\n  return isCallable$9(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$3 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\n\nvar uncurryThis$7 = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);\n\nvar getBuiltIn$2 = getBuiltIn$3;\n\nvar engineUserAgent = getBuiltIn$2('navigator', 'userAgent') || '';\n\nvar global$8 = global$a;\nvar userAgent = engineUserAgent;\n\nvar process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION = engineV8Version;\nvar fails$6 = fails$a;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$6(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$1 = getBuiltIn$3;\nvar isCallable$8 = isCallable$b;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$1('Symbol');\n  return isCallable$8($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$1 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$7 = isCallable$b;\nvar tryToString = tryToString$1;\n\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$1 = function (argument) {\n  if (isCallable$7(argument)) return argument;\n  throw $TypeError$4(tryToString(argument) + ' is not a function');\n};\n\nvar aCallable = aCallable$1;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n\nvar call$4 = functionCall;\nvar isCallable$6 = isCallable$b;\nvar isObject$4 = isObject$5;\n\nvar $TypeError$3 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$4(fn, input))) return val;\n  if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  throw $TypeError$3(\"Can't convert object to primitive value\");\n};\n\nvar shared$3 = {exports: {}};\n\nvar global$7 = global$a;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$2(global$7, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$7[key] = value;\n  } return value;\n};\n\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible = requireObjectCoercible$2;\n\nvar $Object$1 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$1(requireObjectCoercible(argument));\n};\n\nvar uncurryThis$6 = functionUncurryThis;\nvar toObject$1 = toObject$2;\n\nvar hasOwnProperty = uncurryThis$6({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$1(it), key);\n};\n\nvar uncurryThis$5 = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$5(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);\n};\n\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$7 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$3 = function (name) {\n  if (!hasOwn$7(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$7(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$3 = functionCall;\nvar isObject$3 = isObject$5;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$2 = wellKnownSymbol$3;\n\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$2('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$3(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$3(exoticToPrim, input, pref);\n    if (!isObject$3(result) || isSymbol$1(result)) return result;\n    throw $TypeError$2(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar global$4 = global$a;\nvar isObject$2 = isObject$5;\n\nvar document = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$2(document) && isObject$2(document.createElement);\n\nvar documentCreateElement = function (it) {\n  return EXISTS$1 ? document.createElement(it) : {};\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar fails$5 = fails$a;\nvar createElement = documentCreateElement;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$5(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$6 = descriptors;\nvar call$2 = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$2 = toIndexedObject$3;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$6 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$2(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$6(O, P)) return createPropertyDescriptor$1(!call$2(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$5 = descriptors;\nvar fails$4 = fails$a;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$1 = isObject$5;\n\nvar $String$1 = String;\nvar $TypeError$1 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function (argument) {\n  if (isObject$1(argument)) return argument;\n  throw $TypeError$1($String$1(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar toPropertyKey = toPropertyKey$2;\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$2 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\n\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function (object, key, value) {\n  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$5 = hasOwnProperty_1;\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$5(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || (DESCRIPTORS$2 && getDescriptor(FunctionPrototype, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$4 = functionUncurryThis;\nvar isCallable$5 = isCallable$b;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$4(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$2 = store$1.inspectSource;\n\nvar global$3 = global$a;\nvar isCallable$4 = isCallable$b;\nvar inspectSource$1 = inspectSource$2;\n\nvar WeakMap$1 = global$3.WeakMap;\n\nvar nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$1 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar hiddenKeys$3 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$2 = global$a;\nvar uncurryThis$3 = functionUncurryThis;\nvar isObject = isObject$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$4 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey = sharedKey$1;\nvar hiddenKeys$2 = hiddenKeys$3;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$1 = global$2.TypeError;\nvar WeakMap = global$2.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$3(store.get);\n  var wmhas = uncurryThis$3(store.has);\n  var wmset = uncurryThis$3(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys$2[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn$4(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$1(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$4(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$4(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$3 = fails$a;\nvar isCallable$3 = isCallable$b;\nvar hasOwn$3 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource = inspectSource$2;\nvar InternalStateModule = internalState;\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$3(function () {\n  return defineProperty$1(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$3(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS$1) defineProperty$1(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$3(options, 'arity') && value.length !== options.arity) {\n    defineProperty$1(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$3(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$1) defineProperty$1(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$3(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$3(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\nvar isCallable$2 = isCallable$b;\nvar definePropertyModule$1 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$2 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$2(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$1.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$1 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$1 = toIndexedObject$3;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike = lengthOfArrayLike$1;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$1($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar toIndexedObject = toIndexedObject$3;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$1 = hiddenKeys$3;\n\nvar push = uncurryThis$2([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$2(hiddenKeys$1, key) && hasOwn$2(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$2(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$2 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$2;\n\nvar hiddenKeys = enumBugKeys$1.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn = getBuiltIn$3;\nvar uncurryThis$1 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\n\nvar concat$1 = uncurryThis$1([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$1 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$1(target, key) && !(exceptions && hasOwn$1(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$2 = fails$a;\nvar isCallable$1 = isCallable$b;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$1 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$1(detection) ? fails$2(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\n\nvar isForced_1 = isForced$1;\n\nvar global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn$1 = defineBuiltIn$2;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$1;\n  } else if (STATIC) {\n    target = global$1[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$1[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$1(target, key, sourceProperty, options);\n  }\n};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$2;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\nvar DESCRIPTORS = descriptors;\nvar uncurryThis = functionUncurryThis;\nvar call$1 = functionCall;\nvar fails$1 = fails$a;\nvar objectKeys = objectKeys$1;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject = toObject$2;\nvar IndexedObject = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$1(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $ = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar wellKnownSymbol$1 = wellKnownSymbol$3;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$1('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable = isCallable$b;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol = wellKnownSymbol$3;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\nvar classof = classof$1;\n\nvar $String = String;\n\nvar toString = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar anObject$1 = anObject$4;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$2;\nvar anObject = anObject$4;\nvar $toString = toString;\nvar fails = fails$a;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nconst initHereWallet = config => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    store,\n    logger,\n    emitter,\n    options,\n    defaultProvider,\n    defaultStrategy\n  } = config;\n  const here = new _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__.HereWallet({\n    networkId: options.network.networkId,\n    nodeUrl: options.network.nodeUrl,\n    defaultProvider,\n    defaultStrategy\n  });\n  function getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(\"HereWallet:getAccounts\");\n      const accountIds = yield here.getAccounts();\n      const accounts = [];\n      for (let i = 0; i < accountIds.length; i++) {\n        accounts.push({\n          accountId: accountIds[i],\n          publicKey: (yield here.signer.getPublicKey(accountIds[i], options.network.networkId)).toString()\n        });\n      }\n      return accounts;\n    });\n  }\n  return {\n    get networkId() {\n      return here.networkId;\n    },\n    buildImportAccountsUrl() {\n      return `https://my.herewallet.app/import?network=${options.network.networkId}`;\n    },\n    account(id) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:account\");\n        return yield here.account(id);\n      });\n    },\n    switchAccount(id) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:switchAccount\");\n        yield here.switchAccount(id);\n      });\n    },\n    getAccountId() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getAccountId\");\n        return yield here.getAccountId();\n      });\n    },\n    isSignedIn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:isSignedIn\");\n        return yield here.isSignedIn();\n      });\n    },\n    signIn(data) {\n      var _a;\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signIn\");\n        const contractId = data.contractId !== \"\" ? data.contractId : undefined;\n        yield here.signIn(Object.assign(Object.assign({}, data), {\n          contractId: contractId\n        }));\n        emitter.emit(\"signedIn\", {\n          contractId: data.contractId,\n          methodNames: (_a = data.methodNames) !== null && _a !== void 0 ? _a : [],\n          accounts: yield getAccounts()\n        });\n        return yield getAccounts();\n      });\n    },\n    getHereBalance() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getHereBalance\");\n        return yield here.getHereBalance();\n      });\n    },\n    getAvailableBalance() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:getAvailableBalance\");\n        return yield here.getAvailableBalance();\n      });\n    },\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signOut\");\n        yield here.signOut();\n      });\n    },\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return getAccounts();\n      });\n    },\n    signAndSendTransaction(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signAndSendTransaction\", data);\n        const {\n          contract\n        } = store.getState();\n        if (!here.isSignedIn || !contract) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        return yield here.signAndSendTransaction(Object.assign({\n          receiverId: contract.contractId\n        }, data));\n      });\n    },\n    verifyOwner() {\n      return __awaiter(this, void 0, void 0, function* () {\n        throw Error(\"HereWallet:verifyOwner is deprecated, use signMessage method with implementation NEP0413 Standard\");\n      });\n    },\n    signMessage(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signMessage\", data);\n        return yield here.signMessage(data);\n      });\n    },\n    signAndSendTransactions(data) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"HereWallet:signAndSendTransactions\", data);\n        return yield here.signAndSendTransactions(data);\n      });\n    }\n  };\n});\n\nvar icon = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xOS43MzM1IDExLjY4MzFMMjEuNzA4OSA4TDI0LjI5ODMgMTYuNjc2NkwyMC40MTYgMTQuOTIxNUwxOS43MzM1IDExLjY4MzFaTTUuNzYzODggMTUuNTQwOUwzLjc1NTYyIDE5LjE2MjFMOS44OTYwNSAyMi4xNjYxTDE4LjM0NzMgMjEuNTgyOEw1Ljc2Mzg4IDE1LjU0MDlaTTQuNjQ0NjQgMjIuMzY5NEwyLjY0ODY1IDI1Ljk3MTNMMTQuOTA4MyAzMi4wNTc1TDM1LjMzODggMzAuODE3NEwzNy4zMzQ4IDI3LjIxNTRMMTYuOTA0MyAyOC40NTU3TDQuNjQ0NjQgMjIuMzY5NFoiIGZpbGw9IiMyQzMwMzQiLz4KPHBhdGggZD0iTTM3LjMzNTkgMjcuMjE1N0wxNi45MTEyIDI4LjQ1NjFMNC41NDYzMyAyMi4zNTU0TDE3LjkzNTggMjEuNTQ1M0w1Ljc2Mzg3IDE1LjU0MDlMMTEuNzQxIDEwLjQ3ODZMMjQuMTQwMSAxNi41NzYzTDIxLjcwOSA4TDMzLjU1NyAxMy44MUwzNy4zMzU5IDI3LjIxNTdaIiBmaWxsPSIjRkRCRjFDIi8+Cjwvc3ZnPgo=\";\n\nfunction setupHereWallet({\n  deprecated = false,\n  iconUrl = icon,\n  defaultStrategy,\n  defaultProvider\n} = {}) {\n  return () => __awaiter(this, void 0, void 0, function* () {\n    return {\n      id: \"here-wallet\",\n      type: \"injected\",\n      metadata: {\n        name: \"Here Wallet\",\n        description: \"Mobile wallet for NEAR Protocol\",\n        useUrlAccountImport: true,\n        downloadUrl: \"https://herewallet.app\",\n        iconUrl,\n        deprecated,\n        available: true\n      },\n      init: config => initHereWallet(Object.assign(Object.assign({}, config), {\n        defaultStrategy,\n        defaultProvider\n      }))\n    };\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2hlcmUtd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLE1BQU07O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7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b2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9oZXJlLXdhbGxldC9pbmRleC5qcz9iMjgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhlcmVXYWxsZXQgfSBmcm9tICdAaGVyZS13YWxsZXQvY29yZSc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJGEgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgZmFpbHMkYSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGE7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBmYWlscyQ4ID0gZmFpbHMkYTtcblxudmFyIGZ1bmN0aW9uQmluZE5hdGl2ZSA9ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCQ2ID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQxID8gY2FsbCQ2LmJpbmQoY2FsbCQ2KSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkNi5hcHBseShjYWxsJDYsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQgPSBGdW5jdGlvblByb3RvdHlwZSQxLmJpbmQ7XG52YXIgY2FsbCQ1ID0gRnVuY3Rpb25Qcm90b3R5cGUkMS5jYWxsO1xudmFyIHVuY3VycnlUaGlzJGEgPSBOQVRJVkVfQklORCAmJiBiaW5kLmJpbmQoY2FsbCQ1LCBjYWxsJDUpO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRhKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCQ1LmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckMiA9IHVuY3VycnlUaGlzJDkoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMkOSgnJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nJDIoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkNyA9IGZhaWxzJGE7XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZlJhdyQxO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkOCgnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkMygneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkMihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQzKGl0KTtcbn0gOiAkT2JqZWN0JDM7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyAkVHlwZUVycm9yJDUoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0JDEocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKGl0KSk7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJGIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkYjtcblxudmFyIGlzT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRhKGl0KTtcbn07XG5cbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRhO1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkYjtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSQ5KGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4kMyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsJDlbbmFtZXNwYWNlXSkgOiBnbG9iYWwkOVtuYW1lc3BhY2VdICYmIGdsb2JhbCQ5W25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyQ3KHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQzO1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQyKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkOCA9IGdsb2JhbCRhO1xudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwkOC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwkOC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJDYgPSBmYWlscyRhO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDM7XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRiO1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMiA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDEoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSQ4KCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkMSgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQyKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDIoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkYjtcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDE7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkNyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ0KHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkMTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQxID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcblxudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJGI7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDU7XG5cbnZhciAkVHlwZUVycm9yJDMgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkNihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJDQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJDYoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJDQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJDYoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDQodmFsID0gY2FsbCQ0KGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJDMoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkYTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMihnbG9iYWwkNywga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkN1trZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCQ2ID0gZ2xvYmFsJGE7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMiA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJDZbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDMuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjMuMycsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcblxudmFyICRPYmplY3QkMSA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3RcbnZhciB0b09iamVjdCQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0JDEocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQyO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyQ2KHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQxKGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQxID0gdW5jdXJyeVRoaXMkNSgxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckMSgrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJGE7XG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQyKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCQ1LlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDE7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJDcoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biQ3KFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ1O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQxO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkMztcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkMigndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbnZhciB0b1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QkMyhpbnB1dCkgfHwgaXNTeW1ib2wkMShpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCQzKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkMyhyZXN1bHQpIHx8IGlzU3ltYm9sJDEocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJDIoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMjtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJGE7XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDU7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbCQ0LmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCQyKGRvY3VtZW50KSAmJiBpc09iamVjdCQyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDUgPSBmYWlscyRhO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQ7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyQ3ICYmICFmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDI7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkMztcbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDI7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FJDEgPSBpZThEb21EZWZpbmU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyQ2ID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQyKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24kNihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKCFjYWxsJDIocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyQ0ID0gZmFpbHMkYTtcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyQ1ICYmIGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcblxudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCQ1O1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDEoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkMSgkU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JDQ7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMjtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ0ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQzKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCQzKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkMyhBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDI7XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IERFU0NSSVBUT1JTJDMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQyICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24kNShGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkMiB8fCAoREVTQ1JJUFRPUlMkMiAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRiO1xudmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ0KEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJDUoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbnZhciBpbnNwZWN0U291cmNlJDIgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbnZhciBnbG9iYWwkMyA9IGdsb2JhbCRhO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkYjtcbnZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDI7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkMy5XZWFrTWFwO1xuXG52YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkNChXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlJDEoV2Vha01hcCQxKSk7XG5cbnZhciBzaGFyZWQkMSA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgdWlkID0gdWlkJDI7XG5cbnZhciBrZXlzID0gc2hhcmVkJDEoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQxID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG52YXIgaGlkZGVuS2V5cyQzID0ge307XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBuYXRpdmVXZWFrTWFwO1xudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGE7XG52YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDI7XG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQxO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkMztcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQyLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsJDIuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQxKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkMyhzdG9yZS5nZXQpO1xuICB2YXIgd21oYXMgPSB1bmN1cnJ5VGhpcyQzKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJDMoc3RvcmUuc2V0KTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDEoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0KHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDJbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kNChpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDEoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ0KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ0KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxudmFyIGZhaWxzJDMgPSBmYWlscyRhO1xudmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkYjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQyO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTJDEgJiYgIWZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkkMShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiQxID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24kMyh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkMSkgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQzKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDEodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDMob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDEpIGRlZmluZVByb3BlcnR5JDEodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDMoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJDModGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0sICd0b1N0cmluZycpO1xuXG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRiO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBtYWtlQnVpbHRJbiA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSQyKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5JDEoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7fTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxudmFyIHRvTGVuZ3RoJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQzO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkMTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDEoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCQzO1xudmFyIGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQzO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzJDIoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093biQyKGhpZGRlbktleXMkMSwga2V5KSAmJiBoYXNPd24kMihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJDIoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDIgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDI7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMkMS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgaGlkZGVuS2V5cyk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kMztcbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkNDtcblxudmFyIGNvbmNhdCQxID0gdW5jdXJyeVRoaXMkMShbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyQxID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdCQyKGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0JDEoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBvd25LZXlzID0gb3duS2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDEodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kMShleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJDIgPSBmYWlscyRhO1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkYjtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDEgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkMShkZXRlY3Rpb24pID8gZmFpbHMkMihkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQxLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMS5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMS5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQxLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDE7XG5cbnZhciBnbG9iYWwkMSA9IGdsb2JhbCRhO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kMjtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMTtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkMTtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkMVtUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwkMVtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDEodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDI7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQxID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyQxID0gZmFpbHMkYTtcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0ID0gdG9PYmplY3QkMjtcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbCQxKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciBhc3NpZ24gPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJDM7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBRyQxXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJGI7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkMztcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDEgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgY2xhc3NvZiA9IGNsYXNzb2YkMTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkNDtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0JDEodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgcmVnRXhwRmxhZ3MgPSByZWdleHBGbGFncztcblxudmFyIFJlZ0V4cFByb3RvdHlwZSQxID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIHJlZ2V4cEdldEZsYWdzID0gZnVuY3Rpb24gKFIpIHtcbiAgdmFyIGZsYWdzID0gUi5mbGFncztcbiAgcmV0dXJuIGZsYWdzID09PSB1bmRlZmluZWQgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSQxKSAmJiAhaGFzT3duKFIsICdmbGFncycpICYmIGlzUHJvdG90eXBlT2YoUmVnRXhwUHJvdG90eXBlJDEsIFIpXG4gICAgPyBjYWxsKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQyO1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkNDtcbnZhciAkdG9TdHJpbmcgPSB0b1N0cmluZztcbnZhciBmYWlscyA9IGZhaWxzJGE7XG52YXIgZ2V0UmVnRXhwRmxhZ3MgPSByZWdleHBHZXRGbGFncztcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciBuJFRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4kVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgbiRUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgZGVmaW5lQnVpbHRJbihSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHBhdHRlcm4gPSAkdG9TdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciBmbGFncyA9ICR0b1N0cmluZyhnZXRSZWdFeHBGbGFncyhSKSk7XG4gICAgcmV0dXJuICcvJyArIHBhdHRlcm4gKyAnLycgKyBmbGFncztcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbmNvbnN0IGluaXRIZXJlV2FsbGV0ID0gY29uZmlnID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgc3RvcmUsXG4gICAgbG9nZ2VyLFxuICAgIGVtaXR0ZXIsXG4gICAgb3B0aW9ucyxcbiAgICBkZWZhdWx0UHJvdmlkZXIsXG4gICAgZGVmYXVsdFN0cmF0ZWd5XG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGhlcmUgPSBuZXcgSGVyZVdhbGxldCh7XG4gICAgbmV0d29ya0lkOiBvcHRpb25zLm5ldHdvcmsubmV0d29ya0lkLFxuICAgIG5vZGVVcmw6IG9wdGlvbnMubmV0d29yay5ub2RlVXJsLFxuICAgIGRlZmF1bHRQcm92aWRlcixcbiAgICBkZWZhdWx0U3RyYXRlZ3lcbiAgfSk7XG4gIGZ1bmN0aW9uIGdldEFjY291bnRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpnZXRBY2NvdW50c1wiKTtcbiAgICAgIGNvbnN0IGFjY291bnRJZHMgPSB5aWVsZCBoZXJlLmdldEFjY291bnRzKCk7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NvdW50SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgIGFjY291bnRJZDogYWNjb3VudElkc1tpXSxcbiAgICAgICAgICBwdWJsaWNLZXk6ICh5aWVsZCBoZXJlLnNpZ25lci5nZXRQdWJsaWNLZXkoYWNjb3VudElkc1tpXSwgb3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZCkpLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgbmV0d29ya0lkKCkge1xuICAgICAgcmV0dXJuIGhlcmUubmV0d29ya0lkO1xuICAgIH0sXG4gICAgYnVpbGRJbXBvcnRBY2NvdW50c1VybCgpIHtcbiAgICAgIHJldHVybiBgaHR0cHM6Ly9teS5oZXJld2FsbGV0LmFwcC9pbXBvcnQ/bmV0d29yaz0ke29wdGlvbnMubmV0d29yay5uZXR3b3JrSWR9YDtcbiAgICB9LFxuICAgIGFjY291bnQoaWQpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmFjY291bnRcIik7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLmFjY291bnQoaWQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzd2l0Y2hBY2NvdW50KGlkKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpzd2l0Y2hBY2NvdW50XCIpO1xuICAgICAgICB5aWVsZCBoZXJlLnN3aXRjaEFjY291bnQoaWQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBY2NvdW50SWQoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpnZXRBY2NvdW50SWRcIik7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLmdldEFjY291bnRJZCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc1NpZ25lZEluKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6aXNTaWduZWRJblwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuaXNTaWduZWRJbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduSW4oZGF0YSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbkluXCIpO1xuICAgICAgICBjb25zdCBjb250cmFjdElkID0gZGF0YS5jb250cmFjdElkICE9PSBcIlwiID8gZGF0YS5jb250cmFjdElkIDogdW5kZWZpbmVkO1xuICAgICAgICB5aWVsZCBoZXJlLnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7XG4gICAgICAgICAgY29udHJhY3RJZDogY29udHJhY3RJZFxuICAgICAgICB9KSk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcInNpZ25lZEluXCIsIHtcbiAgICAgICAgICBjb250cmFjdElkOiBkYXRhLmNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXM6IChfYSA9IGRhdGEubWV0aG9kTmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgIGFjY291bnRzOiB5aWVsZCBnZXRBY2NvdW50cygpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geWllbGQgZ2V0QWNjb3VudHMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0SGVyZUJhbGFuY2UoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpnZXRIZXJlQmFsYW5jZVwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuZ2V0SGVyZUJhbGFuY2UoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0QXZhaWxhYmxlQmFsYW5jZSgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEF2YWlsYWJsZUJhbGFuY2VcIik7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLmdldEF2YWlsYWJsZUJhbGFuY2UoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk91dCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnNpZ25PdXRcIik7XG4gICAgICAgIHlpZWxkIGhlcmUuc2lnbk91dCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cIiwgZGF0YSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb250cmFjdFxuICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFoZXJlLmlzU2lnbmVkSW4gfHwgIWNvbnRyYWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBzaWduZWQgaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICByZWNlaXZlcklkOiBjb250cmFjdC5jb250cmFjdElkXG4gICAgICAgIH0sIGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdmVyaWZ5T3duZXIoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkhlcmVXYWxsZXQ6dmVyaWZ5T3duZXIgaXMgZGVwcmVjYXRlZCwgdXNlIHNpZ25NZXNzYWdlIG1ldGhvZCB3aXRoIGltcGxlbWVudGF0aW9uIE5FUDA0MTMgU3RhbmRhcmRcIik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25NZXNzYWdlKGRhdGEpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnNpZ25NZXNzYWdlXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5zaWduTWVzc2FnZShkYXRhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoZGF0YSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbkFuZFNlbmRUcmFuc2FjdGlvbnNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbnZhciBpY29uID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOREFpSUdobGFXZG9kRDBpTkRBaUlIWnBaWGRDYjNnOUlqQWdNQ0EwTUNBME1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhPUzQzTXpNMUlERXhMalk0TXpGTU1qRXVOekE0T1NBNFRESTBMakk1T0RNZ01UWXVOamMyTmt3eU1DNDBNVFlnTVRRdU9USXhOVXd4T1M0M016TTFJREV4TGpZNE16RmFUVFV1TnpZek9EZ2dNVFV1TlRRd09Vd3pMamMxTlRZeUlERTVMakUyTWpGTU9TNDRPVFl3TlNBeU1pNHhOall4VERFNExqTTBOek1nTWpFdU5UZ3lPRXcxTGpjMk16ZzRJREUxTGpVME1EbGFUVFF1TmpRME5qUWdNakl1TXpZNU5Fd3lMalkwT0RZMUlESTFMamszTVROTU1UUXVPVEE0TXlBek1pNHdOVGMxVERNMUxqTXpPRGdnTXpBdU9ERTNORXd6Tnk0ek16UTRJREkzTGpJeE5UUk1NVFl1T1RBME15QXlPQzQwTlRVM1REUXVOalEwTmpRZ01qSXVNelk1TkZvaUlHWnBiR3c5SWlNeVF6TXdNelFpTHo0S1BIQmhkR2dnWkQwaVRUTTNMak16TlRrZ01qY3VNakUxTjB3eE5pNDVNVEV5SURJNExqUTFOakZNTkM0MU5EWXpNeUF5TWk0ek5UVTBUREUzTGprek5UZ2dNakV1TlRRMU0wdzFMamMyTXpnM0lERTFMalUwTURsTU1URXVOelF4SURFd0xqUTNPRFpNTWpRdU1UUXdNU0F4Tmk0MU56WXpUREl4TGpjd09TQTRURE16TGpVMU55QXhNeTQ0TVV3ek55NHpNelU1SURJM0xqSXhOVGRhSWlCbWFXeHNQU0lqUmtSQ1JqRkRJaTgrQ2p3dmMzWm5QZ289XCI7XG5cbmZ1bmN0aW9uIHNldHVwSGVyZVdhbGxldCh7XG4gIGRlcHJlY2F0ZWQgPSBmYWxzZSxcbiAgaWNvblVybCA9IGljb24sXG4gIGRlZmF1bHRTdHJhdGVneSxcbiAgZGVmYXVsdFByb3ZpZGVyXG59ID0ge30pIHtcbiAgcmV0dXJuICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwiaGVyZS13YWxsZXRcIixcbiAgICAgIHR5cGU6IFwiaW5qZWN0ZWRcIixcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG5hbWU6IFwiSGVyZSBXYWxsZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW9iaWxlIHdhbGxldCBmb3IgTkVBUiBQcm90b2NvbFwiLFxuICAgICAgICB1c2VVcmxBY2NvdW50SW1wb3J0OiB0cnVlLFxuICAgICAgICBkb3dubG9hZFVybDogXCJodHRwczovL2hlcmV3YWxsZXQuYXBwXCIsXG4gICAgICAgIGljb25VcmwsXG4gICAgICAgIGRlcHJlY2F0ZWQsXG4gICAgICAgIGF2YWlsYWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGluaXQ6IGNvbmZpZyA9PiBpbml0SGVyZVdhbGxldChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHtcbiAgICAgICAgZGVmYXVsdFN0cmF0ZWd5LFxuICAgICAgICBkZWZhdWx0UHJvdmlkZXJcbiAgICAgIH0pKVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzZXR1cEhlcmVXYWxsZXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/meteor-wallet/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/meteor-wallet/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupMeteorWallet: () => (/* binding */ setupMeteorWallet)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var _meteorwallet_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @meteorwallet/sdk */ \"(ssr)/./node_modules/@meteorwallet/sdk/dist/meteor-sdk/src/index.js\");\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$a = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$9 = fails$a;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$8 = fails$a;\n\nvar functionBindNative = !fails$8(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar call$6 = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$1 ? call$6.bind(call$6) : function () {\n  return call$6.apply(call$6, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$1(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$2 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND = functionBindNative;\n\nvar FunctionPrototype$1 = Function.prototype;\nvar bind = FunctionPrototype$1.bind;\nvar call$5 = FunctionPrototype$1.call;\nvar uncurryThis$a = NATIVE_BIND && bind.bind(call$5, call$5);\n\nvar functionUncurryThis = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis$a(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$5.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$9 = functionUncurryThis;\n\nvar toString$2 = uncurryThis$9({}.toString);\nvar stringSlice = uncurryThis$9(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice(toString$2(it), 8, -1);\n};\n\nvar uncurryThis$8 = functionUncurryThis;\nvar fails$7 = fails$a;\nvar classof$2 = classofRaw$1;\n\nvar $Object$3 = Object;\nvar split = uncurryThis$8(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$7(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$3('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$2(it) == 'String' ? split(it, '') : $Object$3(it);\n} : $Object$3;\n\nvar $TypeError$5 = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (it == undefined) throw $TypeError$5(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\n\nvar toIndexedObject$3 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$1(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$b = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$a = isCallable$b;\n\nvar isObject$5 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$a(it);\n};\n\nvar global$9 = global$a;\nvar isCallable$9 = isCallable$b;\n\nvar aFunction = function (argument) {\n  return isCallable$9(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$3 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\n\nvar uncurryThis$7 = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);\n\nvar getBuiltIn$2 = getBuiltIn$3;\n\nvar engineUserAgent = getBuiltIn$2('navigator', 'userAgent') || '';\n\nvar global$8 = global$a;\nvar userAgent = engineUserAgent;\n\nvar process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION = engineV8Version;\nvar fails$6 = fails$a;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$6(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$1 = getBuiltIn$3;\nvar isCallable$8 = isCallable$b;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$1('Symbol');\n  return isCallable$8($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$1 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$7 = isCallable$b;\nvar tryToString = tryToString$1;\n\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$1 = function (argument) {\n  if (isCallable$7(argument)) return argument;\n  throw $TypeError$4(tryToString(argument) + ' is not a function');\n};\n\nvar aCallable = aCallable$1;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n\nvar call$4 = functionCall;\nvar isCallable$6 = isCallable$b;\nvar isObject$4 = isObject$5;\n\nvar $TypeError$3 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$4(fn, input))) return val;\n  if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n  throw $TypeError$3(\"Can't convert object to primitive value\");\n};\n\nvar shared$3 = {exports: {}};\n\nvar global$7 = global$a;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$2(global$7, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$7[key] = value;\n  } return value;\n};\n\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible = requireObjectCoercible$2;\n\nvar $Object$1 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$1(requireObjectCoercible(argument));\n};\n\nvar uncurryThis$6 = functionUncurryThis;\nvar toObject$1 = toObject$2;\n\nvar hasOwnProperty = uncurryThis$6({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$1(it), key);\n};\n\nvar uncurryThis$5 = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$5(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);\n};\n\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$7 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$3 = function (name) {\n  if (!hasOwn$7(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$7(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$3 = functionCall;\nvar isObject$3 = isObject$5;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$2 = wellKnownSymbol$3;\n\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$2('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$3(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$3(exoticToPrim, input, pref);\n    if (!isObject$3(result) || isSymbol$1(result)) return result;\n    throw $TypeError$2(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar global$4 = global$a;\nvar isObject$2 = isObject$5;\n\nvar document = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$2(document) && isObject$2(document.createElement);\n\nvar documentCreateElement = function (it) {\n  return EXISTS$1 ? document.createElement(it) : {};\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar fails$5 = fails$a;\nvar createElement = documentCreateElement;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$5(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$6 = descriptors;\nvar call$2 = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$2 = toIndexedObject$3;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$6 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$2(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$6(O, P)) return createPropertyDescriptor$1(!call$2(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$5 = descriptors;\nvar fails$4 = fails$a;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$1 = isObject$5;\n\nvar $String$1 = String;\nvar $TypeError$1 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function (argument) {\n  if (isObject$1(argument)) return argument;\n  throw $TypeError$1($String$1(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar toPropertyKey = toPropertyKey$2;\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$3(O);\n  P = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$2 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\n\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function (object, key, value) {\n  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$5 = hasOwnProperty_1;\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$5(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || (DESCRIPTORS$2 && getDescriptor(FunctionPrototype, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$4 = functionUncurryThis;\nvar isCallable$5 = isCallable$b;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$4(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$2 = store$1.inspectSource;\n\nvar global$3 = global$a;\nvar isCallable$4 = isCallable$b;\nvar inspectSource$1 = inspectSource$2;\n\nvar WeakMap$1 = global$3.WeakMap;\n\nvar nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$1 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar hiddenKeys$3 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$2 = global$a;\nvar uncurryThis$3 = functionUncurryThis;\nvar isObject = isObject$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$4 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey = sharedKey$1;\nvar hiddenKeys$2 = hiddenKeys$3;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$1 = global$2.TypeError;\nvar WeakMap = global$2.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$3(store.get);\n  var wmhas = uncurryThis$3(store.has);\n  var wmset = uncurryThis$3(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys$2[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn$4(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$1(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$4(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$4(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$3 = fails$a;\nvar isCallable$3 = isCallable$b;\nvar hasOwn$3 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource = inspectSource$2;\nvar InternalStateModule = internalState;\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$3(function () {\n  return defineProperty$1(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$3(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS$1) defineProperty$1(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$3(options, 'arity') && value.length !== options.arity) {\n    defineProperty$1(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$3(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$1) defineProperty$1(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$3(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$3(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\nvar isCallable$2 = isCallable$b;\nvar definePropertyModule$1 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$2 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$2(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$1.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$1 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$1 = toIndexedObject$3;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike = lengthOfArrayLike$1;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$1($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar toIndexedObject = toIndexedObject$3;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$1 = hiddenKeys$3;\n\nvar push = uncurryThis$2([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$2(hiddenKeys$1, key) && hasOwn$2(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$2(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$2 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$2;\n\nvar hiddenKeys = enumBugKeys$1.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn = getBuiltIn$3;\nvar uncurryThis$1 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\n\nvar concat$1 = uncurryThis$1([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$1 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$1(target, key) && !(exceptions && hasOwn$1(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$2 = fails$a;\nvar isCallable$1 = isCallable$b;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$1 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$1(detection) ? fails$2(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\n\nvar isForced_1 = isForced$1;\n\nvar global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn$1 = defineBuiltIn$2;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$1;\n  } else if (STATIC) {\n    target = global$1[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$1[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$1(target, key, sourceProperty, options);\n  }\n};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$2;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\nvar DESCRIPTORS = descriptors;\nvar uncurryThis = functionUncurryThis;\nvar call$1 = functionCall;\nvar fails$1 = fails$a;\nvar objectKeys = objectKeys$1;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject = toObject$2;\nvar IndexedObject = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$1(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $ = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nvar wellKnownSymbol$1 = wellKnownSymbol$3;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$1('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable = isCallable$b;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol = wellKnownSymbol$3;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\nvar classof = classof$1;\n\nvar $String = String;\n\nvar toString = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar anObject$1 = anObject$4;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$2;\nvar anObject = anObject$4;\nvar $toString = toString;\nvar fails = fails$a;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar icon = `data:image/png;base64,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`;\n\nconst setupWalletState = (params, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const keyStore = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.keyStores.BrowserLocalStorageKeyStore(window.localStorage, \"_meteor_wallet\");\n  const near = yield near_api_js__WEBPACK_IMPORTED_MODULE_0__.connect(Object.assign(Object.assign({\n    keyStore\n  }, network), {\n    headers: {}\n  }));\n  const wallet = new _meteorwallet_sdk__WEBPACK_IMPORTED_MODULE_1__.MeteorWallet({\n    near,\n    appKeyPrefix: \"near_app\"\n  });\n  return {\n    wallet,\n    keyStore\n  };\n});\nconst createMeteorWalletInjected = ({\n  options,\n  logger,\n  store,\n  params\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const _state = yield setupWalletState(params, options.network);\n  const getAccounts = () => __awaiter(void 0, void 0, void 0, function* () {\n    const accountId = _state.wallet.getAccountId();\n    const account = _state.wallet.account();\n    if (!accountId || !account) {\n      return [];\n    }\n    const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);\n    return [{\n      accountId,\n      publicKey: publicKey ? publicKey.toString() : \"\"\n    }];\n  });\n  return {\n    signIn({\n      contractId,\n      methodNames = []\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"MeteorWallet:signIn\", {\n          contractId,\n          methodNames\n        });\n        if (methodNames.length) {\n          yield _state.wallet.requestSignIn({\n            methods: methodNames,\n            type: _meteorwallet_sdk__WEBPACK_IMPORTED_MODULE_1__.EMeteorWalletSignInType.SELECTED_METHODS,\n            contract_id: contractId\n          });\n        } else {\n          yield _state.wallet.requestSignIn({\n            type: _meteorwallet_sdk__WEBPACK_IMPORTED_MODULE_1__.EMeteorWalletSignInType.ALL_METHODS,\n            contract_id: contractId\n          });\n        }\n        const accounts = yield getAccounts();\n        logger.log(\"MeteorWallet:signIn\", {\n          contractId,\n          methodNames,\n          account: accounts[0]\n        });\n        return accounts;\n      });\n    },\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (_state.wallet.isSignedIn()) {\n          yield _state.wallet.signOut();\n        }\n      });\n    },\n    isSignedIn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!_state.wallet) {\n          return false;\n        }\n        return _state.wallet.isSignedIn();\n      });\n    },\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return getAccounts();\n      });\n    },\n    verifyOwner({\n      message\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"MeteorWallet:verifyOwner\", {\n          message\n        });\n        const response = yield _state.wallet.verifyOwner({\n          message\n        });\n        if (response.success) {\n          return response.payload;\n        } else {\n          throw new Error(`Couldn't verify owner: ${response.message}`);\n        }\n      });\n    },\n    signMessage({\n      message,\n      nonce,\n      recipient,\n      state\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"MeteorWallet:signMessage\", {\n          message,\n          nonce,\n          recipient,\n          state\n        });\n        const accountId = _state.wallet.getAccountId();\n        const response = yield _state.wallet.signMessage({\n          message,\n          nonce,\n          recipient,\n          accountId,\n          state\n        });\n        if (response.success) {\n          return response.payload;\n        } else {\n          throw new Error(`Couldn't sign message owner: ${response.message}`);\n        }\n      });\n    },\n    signAndSendTransaction({\n      signerId,\n      receiverId,\n      actions\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"MeteorWallet:signAndSendTransaction\", {\n          signerId,\n          receiverId,\n          actions\n        });\n        const {\n          contract\n        } = store.getState();\n        if (!_state.wallet.isSignedIn()) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        if (!receiverId && !contract) {\n          throw new Error(\"No receiver found to send the transaction to\");\n        }\n        const account = _state.wallet.account();\n        return account[\"signAndSendTransaction_direct\"]({\n          receiverId: receiverId !== null && receiverId !== void 0 ? receiverId : contract.contractId,\n          actions\n        });\n      });\n    },\n    signAndSendTransactions({\n      transactions\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"MeteorWallet:signAndSendTransactions\", {\n          transactions\n        });\n        if (!_state.wallet.isSignedIn()) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        return _state.wallet.requestSignTransactions({\n          transactions\n        });\n      });\n    },\n    buildImportAccountsUrl() {\n      return `https://wallet.meteorwallet.app/batch-import?network=${_state.wallet._networkId}`;\n    }\n  };\n});\nfunction setupMeteorWallet({\n  iconUrl = icon,\n  deprecated = false\n} = {}) {\n  return () => __awaiter(this, void 0, void 0, function* () {\n    return {\n      id: \"meteor-wallet\",\n      type: \"injected\",\n      metadata: {\n        available: true,\n        name: \"Meteor Wallet\",\n        description: \"Securely store and stake your NEAR tokens and compatible assets with Meteor.\",\n        iconUrl,\n        deprecated,\n        downloadUrl: \"https://wallet.meteorwallet.app\",\n        useUrlAccountImport: true\n      },\n      init: options => {\n        return createMeteorWalletInjected(Object.assign(Object.assign({}, options), {\n          params: {\n            iconUrl\n          }\n        }));\n      }\n    };\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21ldGVvci13YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ21DOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLE1BQU07O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NB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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxxRUFBcUUseUJBQXlCO0FBQzlGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGJhc2VtaW50Ly4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9tZXRlb3Itd2FsbGV0L2luZGV4LmpzPzY3ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBFTWV0ZW9yV2FsbGV0U2lnbkluVHlwZSwgTWV0ZW9yV2FsbGV0IH0gZnJvbSAnQG1ldGVvcndhbGxldC9zZGsnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCRhID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIGZhaWxzJGEgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRhO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgZmFpbHMkOCA9IGZhaWxzJGE7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMSA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGNhbGwkNiA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG52YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMSA/IGNhbGwkNi5iaW5kKGNhbGwkNikgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJDYuYXBwbHkoY2FsbCQ2LCBhcmd1bWVudHMpO1xufTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kID0gRnVuY3Rpb25Qcm90b3R5cGUkMS5iaW5kO1xudmFyIGNhbGwkNSA9IEZ1bmN0aW9uUHJvdG90eXBlJDEuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRhID0gTkFUSVZFX0JJTkQgJiYgYmluZC5iaW5kKGNhbGwkNSwgY2FsbCQ1KTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkYShmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkNS5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDIgPSB1bmN1cnJ5VGhpcyQ5KHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzJDkoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyQyKGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDcgPSBmYWlscyRhO1xudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJDgoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDMoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJDIoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkMyhpdCk7XG59IDogJE9iamVjdCQzO1xuXG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciQ1KFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDI7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkMyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMShpdCkpO1xufTtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRiID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGI7XG5cbnZhciBpc09iamVjdCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkYShpdCk7XG59O1xuXG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkYTtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGI7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkOShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCQ5W25hbWVzcGFjZV0pIDogZ2xvYmFsJDlbbmFtZXNwYWNlXSAmJiBnbG9iYWwkOVtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkNyh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kMztcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kMignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkYTtcbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsJDgucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsJDguRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyQ2ID0gZmFpbHMkYTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQxXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQzO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkYjtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyICRPYmplY3QkMiA9IE9iamVjdDtcblxudmFyIGlzU3ltYm9sJDIgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQxKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkOCgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDEoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMihpdCkpO1xufTtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQyKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGI7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQxO1xuXG52YXIgJFR5cGVFcnJvciQ0ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDYWxsYWJsZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNCh0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDE7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkMSA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcbn07XG5cbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRiO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCQ1O1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJDYoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDQodmFsID0gY2FsbCQ0KGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZSQ2KGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0JDQodmFsID0gY2FsbCQ0KGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSQ2KGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkNChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvciQzKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIHNoYXJlZCQzID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJGE7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JDIoZ2xvYmFsJDcsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJDdba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRhO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDIgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUkMyA9IGdsb2JhbCQ2W1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkkMihTSEFSRUQsIHt9KTtcblxudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcblxuKHNoYXJlZCQzLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjIzLjMnLFxuICBtb2RlOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjMuMy9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDI7XG5cbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkMjtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkNih7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkMShpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckMSA9IHVuY3VycnlUaGlzJDUoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDEoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbnZhciBnbG9iYWwkNSA9IGdsb2JhbCRhO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMignd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkNS5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQxO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biQ3KFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24kNyhTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkNTtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMjtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJDM7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJDIoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JDMoaW5wdXQpIHx8IGlzU3ltYm9sJDEoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkMyhleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDMocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQyKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRhO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCQ1O1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwkNC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkMihkb2N1bWVudCkgJiYgaXNPYmplY3QkMihkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyQ1ID0gZmFpbHMkYTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50O1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkNyAmJiAhZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDM7XG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQyO1xudmFyIGhhc093biQ2ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkNiA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkMihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJDYoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSghY2FsbCQyKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkNCA9IGZhaWxzJGE7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkNSAmJiBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkNTtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDEgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQxKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDEoJFN0cmluZyQxKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCQ0O1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDI7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkNCA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCQzKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkMyhBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkMyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0JDMoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyO1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBERVNDUklQVE9SUyQzID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkMiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJDUoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDIgfHwgKERFU0NSSVBUT1JTJDIgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkYjtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkNChGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSQ1KHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQyID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkYTtcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGI7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQyO1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJDMuV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJDQoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQxKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDEgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIHVpZCA9IHVpZCQyO1xuXG52YXIga2V5cyA9IHNoYXJlZCQxKCdrZXlzJyk7XG5cbnZhciBzaGFyZWRLZXkkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxudmFyIGhpZGRlbktleXMkMyA9IHt9O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRhO1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkNTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyO1xudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMTtcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDM7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkMi5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCQyLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkMSgnSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzJDMoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMkMyhzdG9yZS5oYXMpO1xuICB2YXIgd21zZXQgPSB1bmN1cnJ5VGhpcyQzKHN0b3JlLnNldCk7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQxKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQyW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDQoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQxKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kNChpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kNChpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyQzID0gZmFpbHMkYTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGI7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkMjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQxICYmICFmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDEoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDModmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDEpIGRlZmluZVByb3BlcnR5JDEodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kMyhvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQzKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQxKSBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093biQzKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSQzKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkYjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDIgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkMih2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuXG52YXIgdHJ1bmMgPSBtYXRoVHJ1bmM7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluJDEgPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxudmFyIHRvQWJzb2x1dGVJbmRleCQxID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDEoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMShpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkMTtcblxuLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkMztcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IGxlbmd0aE9mQXJyYXlMaWtlJDE7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQxKCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkMztcbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMSA9IGhpZGRlbktleXMkMztcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyQyKFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kMihoaWRkZW5LZXlzJDEsIGtleSkgJiYgaGFzT3duJDIoTywga2V5KSAmJiBwdXNoKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQyKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQyID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQyO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzJDEuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDM7XG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JDQ7XG5cbnZhciBjb25jYXQkMSA9IHVuY3VycnlUaGlzJDEoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIG93bktleXMkMSA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkMihpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093biQxKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duJDEoZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWlscyQyID0gZmFpbHMkYTtcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGI7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlJDEoZGV0ZWN0aW9uKSA/IGZhaWxzJDIoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDEuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDEuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMS5QT0xZRklMTCA9ICdQJztcblxudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQxO1xuXG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkYTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMjtcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDI7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJDE7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJDFbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJDFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbiQxKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQyO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMSA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkMSA9IGZhaWxzJGE7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDI7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG52YXIgb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXN5bWJvbCAtLSBzYWZlXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGNhbGwkMShwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgYXNzaWduID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCQzO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDEoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUckMV0gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRiO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJDM7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQxID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIGNsYXNzb2YgPSBjbGFzc29mJDE7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JDQ7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCQxKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVnZXhwRmxhZ3M7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUkMSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciByZWdleHBHZXRGbGFncyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUkMSkgJiYgIWhhc093bihSLCAnZmxhZ3MnKSAmJiBpc1Byb3RvdHlwZU9mKFJlZ0V4cFByb3RvdHlwZSQxLCBSKVxuICAgID8gY2FsbChyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kMjtcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JDQ7XG52YXIgJHRvU3RyaW5nID0gdG9TdHJpbmc7XG52YXIgZmFpbHMgPSBmYWlscyRhO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVnZXhwR2V0RmxhZ3M7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbiRUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuJFRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIG4kVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIGRlZmluZUJ1aWx0SW4oUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwYXR0ZXJuID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgZmxhZ3MgPSAkdG9TdHJpbmcoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgaWNvbiA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVpzQUFBR2JDQU1BQUFBbFJzM0tBQUFDL1ZCTVZFVUFBQUIxZ2RkZFdzNmNxK0pzYWRSZFhhbExUSmhGUlh0VFU0MTVpTmhPVG81K3BlNDFOWHhqWU04cUttc2NIR3VSbitNU0dabDBvdkozZUw2RXFQRVhGMTlRVWNGZG5mTmxjdFpabXZOdmM5cHJiZGFNc1BBMU5vWWtKSEZkWGRGU2crMDhSZUZNTzlWVlRkZzNrL1Zkay9CSFNMMWJYYWMrbVBWRGx2UWNJcUZLY3VwSmxmUXZMM2xSY3VsTFM0MDRpdkpMUk53OVA3ZEhrUElvS0hRL2xQUXBMYXBQbS9SR1JvaG1sdkYwb1BDQmc3cEZQdDRVRkZCT1E5QWtLYWcwT0s5SWUrMDRQTEpZVDlaZVlMdEpSc2M0T0g5TFhPRS9UdUlyTDY0a0pHOWRaK0VWSEp4RFp1ZEZndTVBWHVaSGsvTkhqZkU5UE1BMk9MVlFmT3RMZCt0UWpmQnJiTFo3ZmJGR2RPczhkKzFEai9KQ0s5aFBUNDlKay9KcW52SmFWYzRqSTNFWEhwdFJUY2xWVWN4T1M4ZFVRZGhOUTkxU085cFpVZEJMUnQ1V1I5VWdJR2xMU2NWWVU4MFlHRkpYVE5KR1JjTWJHMXREZk8xQlhPVkRlZXhTUHR0SlI4UlZSTlpEVitNVUZFVlRVTW9oSVc1QmFPaENjdXFrb2U5RWgrOURnTzVDUWNCQ2RldEFYK1ZIVCtGQ2JlbEJaZWRQUWR4QmF1bElUZUJKUzk5R1VlRkZVK0pBWWVaWVR0RWRIV0JLU2Q4WEYwNFdGa3NlSG1OQ1dlUVRFMEpFVmVJU0VqOTRhKzQ5UHIxV1N0UlFQOXhBUUw1Rml2QkNiK2xGai9JZkgyWVpHVlZCWStZYUdsaEdsdk5FaE80VkZVazVPN3RHa3ZORmpQRVBEem9SRVQwdE1MREN2LzAyT0xnd003SXFMYTAwTnJaYVZNOGNJcUFjSEY0a0thZ3lOYlFoSnFWQ1d1UU9EalZHbXZRbks2dEVRc0lLQ2kwZEhXMU1SOHRRU3N1QWNmVVlHR21ycVBOaVhkOTdiZkZLU045aFhORk5TOUN2clBRR0JpTUZESk1URTJaSVJNaGZXdHNWRzZORlJjMC9RTWZJeGY5QWx2UUlDRnhRVHRVb0ozbHBaTlU1T2NDYm1PdzBOSnJSenY4WkhvcG9ZT05jVjlVd0w0YW1wUEFQRnBnU0VsUlJUY0pFUWFjd01ibzZPcTFXVTlnOFBMTStqdklWRlYwZElhbUJmZUFvS3BNM2NPc25Lck9PaStaSlNORTdnKzlHTTlzNFZ1VTdPcUowY05vMWUrODNhT2x5WitxN3VQa3lYK2d6VCtSTFI3VkpVSFZiQUFBQVlIUlNUbE1BQ1pFY2dSQWFZRmNqankrM2liL3pFOXhoVkZQMmxtb3VobWsvUTNYY1hFdisvYkwrcUdOSzlkN1ZxOHlqZnpiKzJhMms3ZW04c2FLYWdqLysrZENsanZ2R25IZnAwcjdzNnMyYjd1M3ozYjd1Nk5yTzgrSFBjTnI1OXVqVStMRGxTTFhOQUFBcEtrbEVRVlI0MnV6WVBVN0VNQkFGNElsUWZ0WkVBU2tOVGR4U1JkdHNzZEsyYUl2Y1l1NHhkNXZDdFV2RWRSQUNhU1JndlNsSU5zTHZ1OEx6ako5TkFBQUFBQUFBQUFBQUFBQUFBSkN6c2pvTmJoemQwRmNWd1haVWpUdDcvdUluVno4UmJNTGUrZkFxTE1JZmhEbkd3MWdYQkxmV3R4cVV2OUdnNTVlUzRKYjJvd2IrVlFoZFEzQTc5U0VJWDZJOFlMSGRqQXZLQ1JMYUhhMnByTzc3cHE2Yi9xbksvRlNVWStBcjRyU250VlMxOHdkVkVWSFZ3M2xvTW82bmFDTmZwWDZkY0lybm81Y29MSGJkdlUxdVQzbXlhSktDMzlIaWl1RWNmbHg4SW9HN25qSlVXalJwc1N0b1ljMmtLdndMRVJsM2xKdXlEVHhUR0dsUjFWR1ZMeEgxdVRYNXdxSzVMamEwb0pOWDRRUlZSem14aFRhSCtwSVc4L3lnbkNheHplajMxYUtaSnd5MGxNYWl1VXluYkFxYk5iU1oxTitSV1cxcWpIU1pUTTduMUd4aWNDeWFLN1RMNGlGcURXMCtuUW95NnkwMEUzTW9CSWxvRXVLSnpCOUdzNVd5dUFtSmhaWVNqMlJXWEdoRy9TUDliKy9zMnJGckUxRWNCL0JMYkZxalJjV2FVQlR0SU9na2hWS2tJQVJSVTFHM09PZ2lSSzYzNVFYTzVZWTdFTzR2eU5DcDRGQndUV2lFNk9MamtPc1FBaEhoQ0NZbGk0aVRFZXprME1YbmE4anZKZWJhOUwwbmVTbCtoNjZ2OE1uMzk5NjlPOW9hSHB0VkdHcVNXL04vcWdFTlY1elBpK09oZ1RpSlkzMTdRd2FhNC9EaE5LNy9DNXIveFdGcFNQaHNubzZKQnVJdG45Q09hOGhBYzJqR2Z4aGdhWTdQVVMweWZlSGl4WXNYNHJFSVYydTRjZnlWc2RNODkyYzFkWFBwMnQxVTJzV21pVFBwMUtPRmVRNGFYaHh2VmlvTjErL0RVZllZSFZ1NHFpUFRNTkIrckJaT0p5OGRnZVo3emhIQWNXYWx0b2JQNXJtaVEyM2hxb1dROFNlb0c4dkNabkorZEpxY0NJNDNLNU9HdDd5WE5RVXpmOVdrTUFNNEZuNjhNREtORUk2L0lvK0d1N3lORlUyOVRLV1JiVUFBQjVrNEdSdVpoc1VadzhNRnRJYlR4bC9WbEV2VTFFbUc0WkRncGZoaE5HY29qVkJ6R25PU2FIeG40RjlRNVFVc1Z5SjNFWkVKeDdFeTA0ZlRpT0o0aTFKb05vR0dBOGRaVnV3Vld5UkthU2lPaWJINU40NjVGTlBDTTAwSG1pQ092M3BPU21zMnlmSTVmcHl6YXRsRW9vWk9ZMkdNc3RWcTFuUmROSURqSmc5c3pXWk9HTWUvSVllR0xuOWNiTG8wdHVFYXYzWnFlNlhTM3BmZEp0NUFBemdMQjlGc2l1UDRKeVhRZFA4UEp6ZEVad0puV2lTcTJ6YWhNWTBmdGFEZERrakkzNWROMTlUN2NETHhrSUZHYVlSeG5PV1lPRTFpSFpibncvR3VLUFRWQUtVaE9MaTYzVzZYZW1rSE93aXpPT2hWTk96d1RHREVjZXFuSkF3MFNrUER1K1hVbjJuS2hOS1E0R2FKeURBSjJ0dkk3V3ZPUm56b1FQdTZ2aTRCeHprYmw5UWFzZVkwMUhtRFEyalcxb0NtTCswdmxta0FEbXBGaHc2MGRSSnhuUHFLUkpyaGU4NkUzZGxRR29LRDlCclFBTTd1UnQ5cExSVkdJNDdqTGNmbERUUllubVBYdTZXcGtValVYcVBCdTBBRENZS215K0xndVdFRFRRcE9ZMFpPYTBTYjQxelIxRWlQQmxWTEFaQ3dVODFFREU1cmFyQTFYd3NGS1RqK3JEQk5CWllPMjNNbTZJT0JIbzM5RVdyRGhvQlZzUUU0N3YyL2FhVGdlQThGSHlwbUVnVjJhZTdUbXVPcjhjVjZKTHJXalc3WGd0TFF0SCswREFZbkhXTUhHcVdSZ2VNa0ZnVmJRMmhJeEp2anJ5cnhkRU5vOHZrOHRUR3FwVENiSFl3WW5QVDBRR3NBaDRZUHh4TzlnSjZwVk9CM3diZm53R2RZQ29UU2RISFFyekNiWU51d0RNREpuR0JwS2hYQUVXaU9WeGVsU1ZUb3lqU0hOV2NDWHQ1UUdyQUp3bXoyOHFZQk9LMExETTBMc0JGb2puaHJUaWErMDRVbE5LZXVRbTBJVFRhYjN3LzBKc1FHY0Zybkdab1hnTVBSSElrMEZWaFpiTStwMzlER0gwb0RPRWE0VGMyMjRHV2J0WEdhb2VIRGtiN1hrTmJBeWpTOHpmR3ZLUEJSWnlTYXoyWUI1NkN6d0VzRGJBeVVPUWMwMUlZYlJ6N042TTBKdmRGVDRFcUF0b2JGc2UzdE1KdGRWemNnNldtR2hyYzVrbWw2NjNMdU9VQXpvNDA5UFJyQUNYMzJESnBZQnh3ekJUUUNPSEpwQ29BamRGcXJLM0RKQ1RTQTg2RVpjbWRUMDVFT09PNFVTeU0wMXVEd0hMOCtsVnk2ZVhNcE9UVzN5RVZUNEdpT291OEdnSWJCK2JqVEhtcnppOVFHY05BY3BYa05NaUxOOFJLM3ROaTEyNWxPNTMyNVdDeS83WHphdW5NdmZoU2FGNFJtZEp6K0tFZ0RyZW5EK1ZEZEM0YmVDaGc2ZzVQYXAza3RCY2NyUEpsUFB0amFLcjdiSWluK1NiblRlWEQ3MGhGcE9KdmpUQUpOdHpqdytNbE9OTXZXQVFjLzZ0SUFEdjlZeStXK1ZkLzhmUGZtelR1d0taYkw3OStXYjhlUE10QzRtNk1helcvcTdpNjByVElPQTdqekM0Y295a0JrSWtJSEU3elRDeEg4MkpoNm9lek9DMjhVMGlhWjY5WW1TeS9Xa1F3Q3ZmS3VOU2toelphTGhzSUpKQ0g5eWxvT2JXaENFdE8wN0t3VjFpNXpTVk5idCtJeTdDZ3RkRkQ4dnlkSi95YzV6VG5wKzU1MjlabWdGMnJBbjg5ejNyeUpGZ2ROcG5PNytNZWZOVFRQMHBOQXM0dlQvdTFieDc3bmZJU0d2VG45MXpmbi94ME9EME5LT0tqeitMc1BHNlBCRjZWcnpwR2l3ZGJzaGJQNDdNOC9wRjhYc05zc1FJTTR0MTkrNGMyL2ZENU5jSHFiSDk0YkRrTkVuT3JxREkxUHZLOU9NekRRZzMybGZPYjhIMmpLczViTy92RW44SlMrQlBXc2FPeTBWZGs4K3ZGTnprY3l3RHhydlF0cjgvNXcyYVoyMWtoMTNsRnR6VUFFd3RpY28wT0RnMVpISnphMVNMNDZDSGxXS0pvbWpUWUkwdHpWZGJpSURIdHpnTVkvNzRlSU92SlpnOXo1UkpVRy80MWdhTTRSb2NIV3dDMk56UWJYMERJY2c5R2lUeTlDZE8wV0kvdzVVaHhEYTdQYlp6YXo0eEFhRDlDUWdFeEpwVEpyaUhOV2VkQWlsYnBHbUpwenhHZ01lb01PQU5Ma0QycHdJRFpqTy93eTJnd1FtMFRIOEdqSmJZWW80a1Fhd2lHdDhaUm9Cc2ZDbnNsT2IzZ3NOQ1REK1VDbE5USWNxaHVDbzBSamlLV0w2MWs3Skx0ZVRNZE1NaHlESkdoakUrNWJ6VDYwVVhqbXFIMmVFeUUwSG9JekZvNEp1ZTIrdnI3dFhHdlhVQWhuamRqYyt1aFlYUnJKeFFUVk0rZG8wdWh0UlhzbWtTaEFFb21NZmN0bWsrR1k5c0lSVnEyY1dRenJyRVdhUFVBRENZOTE1dUx4ZUlvRWZpK0VoNnFmT1hmZXFUZG92ZzRNeGF3ZFVacFllajJUc084bWtWbFA2MVZ4SUk5V09hRFJBcWVuUXVNUDUrUHh2dDJrNG4yV0dwenhkL2Vtd2RaUXoxcmIwYVBSTDlvejlxcGtzb0NqTm1zR1laV3ptcVUyMUVmcGp0M1crSlB4Vko4MDhYZ01jYkE0ZFFZTlEzR1VQa0kwbGNPemNiRlFvc0dBbFU1dDFvREdpalFzelpIUzVIWkxnOVdacW1yT3hIZkg1VFErcEdGNTVod1ZtdDFCVzdUam5pSE91c0draENQU3VCd09kcHp5czhicjlTSk5OVTdLT3pTR09IaFVRNW92LzhMWFk1cTEvd01ONEd6RmRBcXpWcVpCSFBwWmc5YmM5cElnVFhYaXlaQzBPTGMra2RQZzZ6SE8ybEdnZVdHWHBvQTAwaVN5T2tOZEhKc2hXYVpoYjg1QWhjYVBOTFU0RnVuN25Ja2Zqc2xwU05obURXbGUvZnliczJmT25EbDc4bDJtci94cTN4ckUyY0xqZ0d6V2hGVzN5K3hneHlHdDhaWnBQRWhUYXlPRXhoQm5LUFJlRlkyalRLTTZhK280LzN6MndudG56NTJmWFY1dWFXbFpYcDQ5Zis2czZ1WDNJZEtnVFRGV3o4YVVYSFc1blNJTTY2ekJvTTE1dXhScHdHWTdQQ2k5SURoZDNaclNxN0hQV24vUDBvOW5XcFpuV3pDenl5MmY0dU9OTWV5RGhxT0dWMnRWT21VYXB6cU9lbk44elY2Z2dTalJ3R25BRXBKY2ZBNitYME9ET0F5ejF0L2I5bUFjQ2xNVHNQb1Vla29ScHRZWTY3Y0dVc2ltRGJxOWNJREdEVFNJUXo5cnZ1c3dhSVRHbzBBRGdmYzRrczl6SHArV0RKckRKNFoxMXFBMHpTMTNVS1JLcCtVTmJRRm9CdzF0N0duYlhqYTZNZzJFZGRZR29EVmRJbzBYYUJSdFFwS1BETzZjeE5hVWFSaG1EU0syWmdGcDlxZ081YW1BZmREVWJWQm5KTGZxRGdJTE93NjBwa0xqVHdLTmlnM2lRRytRQmw2dG5QM09HdW9BVGY4RGxObEw1NlBYWHpqNEhGT213U1J3MHpDa05jR2drK1BBaFhYV3pOZTdnSWJFbndjYVJadXBrT1JqNnJIM2NkRE1ac1NobjdWZUZSckFPUysvamRDZXhpUWJOTld6QUdZa3VSb2dOQnJnK0s1UFRwVm9QTVpVU3BFR3pnS0RZUW5PYVd5TnJLYzBPTDI5UUtPUzJiZGYwVWFBblFiUDBOTEFvQVVEbkJqV1dZUFdURnNzb28wM3AxYWJiZW5IMUtHeEV5VWF2QU9ubnpXa1VjVTVxNUVCTzAyaHNLaVgyZVJXQXdIT2FrVWM2dWFZMnlhbkppMFd5eVRXUnNFbVB5akJDZjN3RnFGeElnMUxjNUJHRmVjRU93QUxEU2F4anBPR2d5YlNFQnpHV1ROZkYya0lqdnJUSnRVM09leEhuTUZ6MkJvTmNKQkdKY3Z5ajF5MXA5R24xV2tLZU5kWk5XaldVaGhuemRFR2cxWk9BNU1takVtL2ZmUDRaVGtOenRwK2o5STlQVWlqVmh4OHozdGdyVkdpd2M4STlDYjVvRlZvMkdZdDRteXpBRTNGeHJLZFVxYnA4dzc3RVdjd2RCeE9hRWl6bitiSWNaQkdQY3R2NDd1Y0Eyck5ZaU0wV1ZQdEFUcTV5aU1OeTZ4RkhJUUdiZHFWYlZKeEk5UUdjVUx2d0xQR2lpOUVQMnRJMDJoeDhFTGlnQVl0cTA2VHdNK2tjZEFDUE1wUXpoclNZTHp0ZlNsRm1tN1NHclQ1KzhSclgzSU9Cd1dPYk5hUXBzSGlmTW9Bb0U1ak1HVXo2cTJ4cDJPMWc3WVQ0RjB1RjVpd3pwcXozekxkMmRtSnZlbmNUaW5SdEk3NVBSN1VHWjcvbWVQd2hWaG1EV2thSHJYakdwSWdqV0drVkp1aU9rMUNUcE5jY2ZOV0YrSlF6eHJRZEU1Yk9pSDR2TW1sbEZwRGFDUTQ4L2NEVm9jWTVsbnJpQ0FOdzZpeDA3U0tOdnJGUXFIaFFjUGs4NzFSVnltTXMwYU9BVVFHYlNhOXliaENhOEpBZ3pqaGU4TStsME1NODZ4RmtLWmhteGUxdDNueFNtc3J3VEhwMXpNVWc2YkxMVVhkTGkxd3VIN0wzUklONm5oYVUvVnBob2tMNG5qbW00TU9DRk56YUZzRE51ZTBiMDBNYUFpT0xXMHZxTkpnYTNEUmdyd2JjZWhuamV2dHZOdmVqamo0d0ZHa1FaeTVKMEhPcVlhamZ2RkpSd1A1NkJXdFd4UHJiaTNoNkxjUyt4ZzB2QTlvanJvaHpEaGNQNkdSNFhqejhYcURKbjQxQ25IbU42MVdmQm1HWnc3Tm9KR2MxL2dkemh2WHVzRkdUS3lvWXBQSjRxQmhiWFlDQVdMRE9tc3dhRUFqeDRGM24vRzlhVUJHYWpPLzVuQTdJZXpORVZ2ei9HM2VhT3FHb0Uyak5CaGhBV3FET0xSSGFWZFB1MGdqeDhIYlRsbHJwRGh6YTc2Z0U4S08wOUVCTk0vZjVtVFRsU3RYS2pxeDlVU2pnNGJKcjdoNEFzTTRhMVo0MWhpTmRYQU1xYmlNeGkvQ29NNDgwckROV21TQTBEeC9tL2UrN1Zhd1VXZ05KbmsvR2dpQ0M5dXN1WG83SHhtTjlYQzh4dTI0cERvZ3BmZDd1OUJHYkkwNTRJUXdOd2RwbnU5WjROMlBid0JOU1FjM3JhRVRHcjYzYVlzR2c1UTRTQk1oTkFvNGswSmZ2TFJzcVZROGxiU0V2VjBReENFMCtDSVV6VUdhQVFvYTdjL1F4Nys2ZktPQ1EzUmlXNGtHQncwajJEZytDR0daTlorMWh3eWFFazZYMXlqa3dBVjh0Z1dqeDBOa0VLZE1RNDNEU3FQOWU4K1h2bXE2QVpIWTRQc2J0VUZERy9ob0FHM29tdVBxV1lIVzFNT3BYSHA2SjQydCtYeXJzUXRrS3RtbGNRQ05GamgwZzZiOW5jMnBwc3VYb1RpUzVzVFdNL3Vnd2NlTkdHb2NkMlRsa2Q1WUR3ZDFLaFJsRjhRQkd0N0thWUhqRzNqd21BSkY4N3ZPRjV0dVhLN0JpUzBtQ28wT0d0N1hrT0l3ekpvTGFJeDZOUnpNWkZkVnlqUldMWEI4UGhvYTdUOGpPTmwwN2JJWXlheGR3ZUtvdFFZdkJXWmtOdnRxanJzSFdnTlJ3ckZVcGNabTdxRXpZSVd3NHhDYTBaWlI2a243UUtzald0TzFhM0tjV042ZWFZZ0diZHFpQWNDaG5iWFNvSkhRTnVmcEdrZGF3NDRqRHRyb0tEWE9zbFluNkxlK3VuQk5oZ002VTJuRVFScTlycTZOMEU5c3FHY3QyRUZvNkhHOFQ5ZWNRS01GanRnYUNOQ01QdGVUd0trbXNKRTNoK0JrTXdVN0pwRloxd0ZOZlp1MkdaQ2huYlVndG9adTF1YXdOWXc0WmpQUWlLR1EwZkk3VUtjM3JsMm9oMk1vRmpMbEkwRWhrYkVYYlVCVFA4bnJ4SVp5MWdJZEs0SU5US2liOC9RaDByRGhtS0UxNDJVYXFsbWIvVkFibWhOTkZ5QnlIRkhueWxTNm1DMWtJQWw3dHFpTG1YUkt5UzNNOENCRE5Xc3dhSG1ialFIbjZab1ZhWmh3b0RYL0FrMDVGRGl6MzJqMXNMbDRvWlE5Y2JwanNkYkZyV0t4dUxWbzBodDB5a2t1UmNHR0NpY1FBUm94bERoelFJTi9meFljaC9uQnhQajQrQ2pob1hybUxKL1JhTkcrYmlySjFKczF3ak1WZzk4TTBCazFtMDFpUXpOcjRxQkJhSnZUTmVkeEFvMFdPQTdTR2hLc3pUNXB0UHJQQ0Q3WXVIaTFIZzVlZkpLTTZGUWo3UEJnUTRFVEdBQWFnNEVlNS9ZVStRWUpPdzZoZWZMdnJWc2xuSEdhV1p0OSt5V04zdG44ZFBHaUNnNmtqS09xa3pjNTRCQzkzMWtqcmJFUkdnYWN1MHU4MjZVQmpzL2hBQnBJVlhNUWg0S0dPcWVBUmhtbnU4SG00TVhBdnB2RHc2QUJEQVBPOUZvdzRIS3g0L2ljWlpxYTVoQ1owVU9tZVhuam9wZ0xHczFhYm5PRzU3RTREVFhIeWZ2MFFNT0U4N1FmRm8wRkIybituaEJsS2ppWVE2WTVEb3NHWVo4MUhEVXV5dlA3bTdXQXp3WTBURGpUY1AvdFpzTEIxa3hNQUE3UndlYmdpWUNDaG5yUk5xNWVCUmdOWnkyNUJNVXB5VFI0UThBUHJDUk5CZ29jdE9tRWc0RGJ6WTVEV2pOVXRzRlprNXlrRDVIbUE2QUJIQzFuVFZqaG93U24wYU0weDV1QnhrU0RnenJUbTRHQW14Mkhjd0xORU9CZ2MyVFBuTU9pT2Q1MDh5cUpwck9XZytKZ2MxUm5qVGZiQkpNWUJweTdDMUFiSmh5a1FSeHNEb2FDaG5iUmJsYmhYTkJpMWdRVFY4TGhHNWsxM2dldEVjTXdhMU1XTSs5bXhuRUNUUWh0Wk0zQjRod0N6WW1OWDI4ZUFFNXVkU2FLelZHZXRTZ01HdjYvYjJoeHBqZUJoaFdISXpRaHhLblRITUE1Qkpwakg5Lzh0UWFuNFJzQ0paMlIwbkdna2RNYURCclFNT05NTDRFTkl3NmhHUXlWY0JTZU9YZ2lVS1JoZjJ2ekt3UncwRWJ0dEFacG9EbDVJVkxCa2R0SS8vbVJRZE9oalJ3SDBnak9kRnZVelloajVaN2NBeHFTS3B1OWJnZ09udWIxalY5K1FSd3RqOUttNUlnRGNGUlBhMUVIMEZUQzhzeVo4a1dEMURoSU0xaUZVLyswQnI4VWFkaHo2b3RmOW9rRGFSVEh4bUZ6NnVGRXlhQmg2R2R0eXN2eFFTWWNxL1hKdmVGQnhGRTVyYlVjTU0xN1FFTndVQWR4S3FFOVNnT09ZVUQ1bWVOeVIzdE5oQVpEUFd2VGF5NCtDS0hHSVRUNEEzUWFlZWFNS3RPdzF3WnljTE9XYjFZOHJmSFJoVHpTc00zYTlFTTMybERnbEduQUJpSzFrVFVIWlVZUGtPYmtoaWh6Y0xNbUpEY0RvTFAzbTlCQTFMcVpGRXc2RE11c1RUOE1nZzAxanR2NlpENHMrN0ZnNnFlMWc2SjU2K012TGwxQ0hGRkgyeHNDVXo2blgrQkJKMUE3YXlEREw2ems4a0REaklNMjFEZ3U2MzFDbzRnRGtlRm9Ub08xdVVSczJHZE5LVUp5cDVtZm1hbWVOVDRhRGJUdEpBVWRoblhXeE9jTkJRN1MxUHhZTUxrTk5nZUNweldrMGJJMlFDUEgwZnJpY3lTWjNGbnlSV2Rtb2hDZUI1YVpxQ3V5dENNazRhL1REaWZXeFVVRGxEaHU2LzA1ZjVpa3dlYWdEclpHMDd6OHhlL0VwbmJXdEwvNEhCR1MrZFg3UzcwK3poMTBXYzI5QzVzcithUXdnbk9teGF3Wlk3NW9nQTZIdE1idlY4QlJPYTJOSW8xbXRmbjl0MHNVemFIOG1Eb241RTJHbFowVm13bW9jTXkwYXc3Y0N3Um9jQ28wYUtOMGtwYWYxcEJHdTV6OGo3MTdpNDJpQ3VNQXZtdTlnRVVsaUFnQ1l1T0ZLT0lGRkZFZVZFUUY3d1F2cUMrdThmYlEydENDaExvUVdpNE5kOWd0WlVOU1NndWh3SzRCVENpNGFiZHQ5b0ZzbXE1dEk3dHArbUREQTIxTkEwMEpCQkl3ZnJQZDl1dDJaczQ1YzNwV1pxYm5NOUVYbi9qbCs4L1o3eHZPWk8zWkF6anBqalhrK1J2cXp6L2hYL2cvaSt5Y1dBZlljT0FFU3R0YjlnTU5vWE9JRTRJMDBJeGZmRzdQSUE3R21wakJKNzNFNDhUZ3RqWU9IQi9TSERYeXpFR2FaNEJHZE50czJ3WTI1M1E3NXllZVdCTnZ3NHpUa09NSkdjYnhKbWlnMElZYWE5ZzVTQ1A2YWJNdGdTUHdtU080ak9KMHhSdjlSbkg4Q1JyRUlYeGhWejBod0VBVDNUWmJ0MEVKamJWdmJtK3N4VHFEUVlNNGZwOUNnemlHVDJzWG5oa3ZuTWI1NHRhdEF6aVlhd1lIbjlnNkFwODUvSVBQaGtoRm94OXg2SVBQcWdEUTRPVTNITStjQ3hCb3dtdEcxbGJFb2NmYUw1YUl0UzU4UjU2cGMvd0tEZHFvY01pRFQ2UVJYSTluYlFJYnU4VmFEQnFISGNjZmFPOHIyNDg0UncxMURoUUdtc2lhbXJWcEV3bUhmWjlqcWxqcitqY1k4clBHbXRJMVJXVktjY1phTTNhTnlIby9ZV08vV091Q0YwZ1lPd2RvK2didnZzRmlqN1VMNmFHWnZIaVRVc1ppN1FjTHhOcXZYUlZzT0lsQUswclNjTVZhTXdhYTBMb3phL3QyQWc1MThHbU9XTlBDaWVWNEd2ME1PTUVFVFpGS0I0b0pwN3BuSG5hTnlISyt1Mms3NEF6WTJDcld1bFlYVUhHUWhxVnp0QnZuOVRSOWQraXg3VHZBUnE5emZqUnJyREhpclBCU1l5M2t1OVpYV3dSRmFCemk0TE1hYVFUWFcxazdFSWZ5ekxGZXJIWGxuQ2JqK0VMZXpnU05Tb2NWcHladE5HTVg3MUJzTkdMdG5GbG5hMFlHbnptN1l2RlFTQmVuMUIrcWdJOGRZcWxqalRMNFJCcnhkZWV0SFVvaGpxSmpqY0VuVytkODE5VmUyZ2dMYWkwY2Z5alFVZCtITW1vYyt1QlRQQTJlQkhiczJ3YzI2bGl6elQ2bm9Tc243Z2VkNFRnQitHbnE3bzVFYTJ1TGlEcEhTYWMxcEJGZlU0RUdiTlN4WnFOOVRzNnVybjg3dkNHSU5zUUJtR0NCcXpNU3dZdUpTSStjL1hxeE5nZHBoTmR6V1dzQXg3S3h4anI0M05XVjA1N3RDWVlHSytpdGFDOERtZjZxNVkyMTF4MVFkODljZnUvODJiUG4zN3Y4K2J0RlJ0ckgrOVlBVG1xczJYSHcrWDFETExhNnM3MGo3cTZvY01VNzJxOFZSU0wxcTNXdmtWU25tbGFzOWNJbk94ZE1uLzFTdUtuTzdYSzU2NXJDTDgyZS9yeXdIemRyb0liaDJITHdxYnhEQUR5eFNFTjlmVU1rRW9zaERBR0hQQ0hvZlh2c3pIRmhWeGhjQnNvZGR0V05HK01VTSthOE5ZQ0RzV2JQd1NmZ0tKWDhyOGJGUkVaajdlVEYvVis4RXc2N1ZCVU9qMXNnSXRJK1hMTVhhRVpKckJtNkhaYzJ2amx6NHZlT2tpWTNrZ3h0bnFicEk3ZkpYTHgzNzE3ZVdMUFloSUFEaHpRaE9Ib2lmanJiNVFZY0xaMm1jWGVQK0pSMnRkOEdhc0RHL3JHbWkwT3hnVUtjdGhQeDNkbHVLSmQyaFI5OWZxUS9QSy8rc1hkWTUxaHk4UG0veDFyYjBYaGVkamJnNk9yVTFUMDRza2k3dW5LbEZvNWQ5em1pWWkxSlE4RUp6eHlKemNPM1ZnSU94aHBwUW1EWFdGdkJjVnByYTR2blZTUnNTTEhtZm1Ba3o1eDNvVytHZGM0T3E4YmFkNkk2aDQ0RE5KVWxGWWlqcHhPKzM4a2ZhUi91QlJwMXJObDVueU1nMWxyYlhKVWxZRVB2blBQMzhyOXBlM1VqeUtoaXpkYjdITzVZUTVyOThjcmRKVkJVSEVpMXlkd242RnNiRWFkZng5S0R6NS9UR212WU5ibjlIOGl2b01kYTAyenVPZWZLalZvNGR0L25qQ1RXb0d0YzNyemRLaHpkUnc3bnI1eU14VHZCeGxpc25WTjFEdS9GUkNLTC8ySWl0R0hybk5ZeWx3ZSt1UVkyYkxIV05KL1Bac0pLc0VudG5GRTIrRFFjYTYxRmJtOGVGRE5PSFp5aitRWTJPeEVIQ216azRGTTcxcENtNEhEeXM4VXFIRzJkODF6VEFlZW5ZS1Bxbk5HMHp6R0VrNlNwUEp6RTJjMkdVOGQxR3BpOGR1Tk9OYzRhR1d0NlIrbG9iWFpCWlNVQlI5UG1VU2ZQeXZQV29VTTdkOHBZWSsyYzFsYTNMeGRzakhWT1haeG56L2JhMVVPRE9OZzVjcCtqalZOVzIrb3F6WVZpeE1HNmg4Tm1WckZpUTRrMXNMSHRpK3pHSmdSOUhUNVBMaDFIYlRPZHgyWm5jYkVheHg3N0hPRkg2YktXYTc0cXNESGVPVTFqZUFhZFlGTThQTmJrUGtjVHB5eGFWdW56ZU5RNHA2bmptL09Mak52TVdBczBLYkZtajhGbldtS3R0aVh1OTNvUngwQ3NuVi9PTVlTK1dhekNvVTRJTEJSclFqdW5wYk9xd011S2s2cFR4M0VXZVBYbTJrVG5ZS3pKd2FjdVRsL2NYK1ZOeFRsTWlyVVJuZ1crTEFZYmFxelovMFYybGxpTDd2ZjRxZ0NISTliY3JqRWNDNEl0YTlVNDl0cm5DRHV0dFZ3S3dwMHF1cDJ6bTNBZ3FIdHByUEVGd1lkQU02Z2pKd1JFbkdnSjJLaHdRSWMrK0t5N24yTkJVTHlGRzhkK0Z4T1JjYUpsWG44QjRrQ3hId2pDOHprV0JHdTNiRkhaeUgyT0pnNThIaXhRb0JUSE0rZjhBajZiTFRMV21IRGc3ay9sWGhXZVdBdS81K1N3dWJsRmpTUDNPWm80a1hpb0ZJb24xc0xUZVJack40Q0dGbXZ5UmZiK3IxRzZRajZ3NFlnMTl3TVpIQmQwZnJaMk05Qnd4Wm85THliU3gxa2R6UTc1K0hDNFhoNmNYTDU1Y3lxT0hIenE0VVFWRzhDQk1vaVRYSG82TTJjK0JUVTFnOUhteG1iRVNkcklmWTRLQnpQTng5TTVENDJCUCtsRmN4YiszbjlQeEpKNWt4NjhpMjR6N1NiUXFEc25GVWUreUE0Ni9UYUJBQWZPNGVtT0dYUE85Snc4VlhNS1pPQk9vbE05UGZNV2phVXVwRytXcCtMYzlzR25pV010Rm04TXFIQ29nOCtTMC9FdkZ2N1dtM0t2TlBpY1hUS0owanRUYm9ETnNGaXo1ejVId09BemRrbjVYb3ZCV0R0ZGN1bm94Wk1hOTYxVk55K2NTZDRRM0NoUHhiSDk0SE1FblFQZjJBMENqcUZZeTh2dWJOTzhrUjNxN0Fla1hhaHoxcnJ5OG5LenhacFo5ems1SzZwQ2ZyK2hXRHRjY2JLVmNJMWs4eHo5Y2NGZHM5WUJ6ckRPa2ZzY1BaeUlHMnlNeEZwbFJXY3I4VU1UZ0VQb0c4QVpiYkhHalJOckR3WHBPTGpQcWR6ZDJVciswQVRnNkk0Rlp0MVFjRERXNU9DVGhGTWZMVkFhaC9XWmsxc0NOTFRiY1p2ZjBQdDU4OW5sZFFaeFJ2WGdNd2EzZ0NNT1pmQ1ptK2dhR2s3MXQxTUpOcFJZa3kreUkwNmtxQlFhaCsyWjQ4bnJiS1YrYUFMcTdEeHRtNGx2S2pZeTFoaHdzSEdDVExFR05DMXMzekpvWHFSalU3NkJnaU5mWkIrS1V4L05SUnhTckhrVE5FdzQxVXMwejJvVDNseTNBWEJTWWszdWMwZzRzVTdsVTdHMFdLdXNxZ1FhMXUvbm5KMmhhOFBRT2JaOGtaMnZjK0NqSUNGcXJGWGxKbW1ZT3Fkbm9hNU5LbzdjNTVCeGNtRGlHU1RGR3VBVUFJMkJHOWxyZWlicjJoaU50ZEY5TVZGOXhOVklqclZTRDlBdzM4Z08xZnlJcGczQXBIYU8zT2RRY1dKeFFxeDV2QUhvR21NZm1xaVo0OVE2cDIxWU5RVEhqSU5QRThaYWZhemQzd2cybWppbC91enVGcVliMlJHblp0NWQyamJEY09RK2grV1owMzA2MUtnUmF5RGo2YWlOc3QzSWpqWm5sMlhxMkNET2FCeDg4cDNXSXJGMlR5TWtXMkFvanM4ZkxJaDM5OVdXR2YzUVJNM0pSelJzUGxKc3pCNXJKdHpucktpUDFiZm4rUnNiZ3dQQkZnaUdBcmtnRTlXK05vcjR6RGwxY3BIR1BFMnhNZG81OG1LaVJJRk9kMGUyeHg5TWxMK3FKTjVlMXRLaWY5OGE0V3VIQkp2Ykgyc1dQRXBENVVSaWtTTDR0b0ZTMTdwWDlQV3RxQ1hmdjZxREF6YVBhTmk4K1JYQUlJNGNmQnJDZ2FxUEpLcytTcnU2V0QvV2FwWThxTGJKK1BSeS9sQWNFd3crTGJYUEdkR043SWhUc3pCRGJlT2N1d3BzVW5Ea1BpZnRON0tyUDBXcDlmdkdPU3MvUDMrVmpMWGI4cUVKN0p6cSt4eWFObEJtaXpYclRBZ29PS3hmMkcyZXFtVXpGMjIwWWsyK3lDN2c2bUpxNS95MmJMem1lNTFmSVE1YjU4aUxpY2lkdzNGYU96VkorMzNvNnlDVEVtdHluNVBtV0ZQajFDelF0SG50Y29yTmFCMTgzb1pZUTV2ZU9UclhDeWcyeEZnejBlRFRvcWMxMnVDemQ0RzJUYWFTYWFnakI1K2ljZWhmMk8zVmU3RnpjbUZoZnI0NVlzM2lMN0lqakxFdjdKNVpscUZuY3lRRnh4U0RUNHMrY3poamJjbFUzYXVHbHVhcmNLRGtoRUIwck9tbFd1OVREcjF5Zm42OUVDcS9rUEdaSXk4bUVudVU3cjJQOUpjS0V6YWdVbWltV0xQb2hNQndyUFZPSXQ1blU1aW9maGs1K1B3Zll3MktUT09ZY2lScG8veGp4c0duamZjNUY4azBqZ21GZ0tNYmEvSkY5alR1YzZCcnlEWHR5cEVCSEpQRm1nMG5CSU02U0VNcTU1ZEhBR2NnMStUZ00vMDR5Y0pBSXh5aXdXWklyTWw5VHBvSG4waERyMmV2SUk3cXRDWmZaQmZkT1VqRFVLOWRYdzgyWmptdFdmOUZkbXFzSVEyMUhydXlmaERIUElOUEM3L0l6aEJyRis5d01OVzBBMGRTY0FyTk5TR3c0b3ZzbE03QnJxR1Y4MWxvbkNFNGNwK1RiaHpzR21yTmhiNFozamxtaURXNzduT1FobDVQS24yRE9IS2ZrOTdUR2dRYWUwMjhEaktxenBIN0hOR3hobDNEWHBtSnZtRjc1c2lMaVVZdytFUWE1c3FBdzRCZTU4Z1gyUVhHR3RLdzF4U3dHY0F4NitEVEhyR0dOTXcyQnc0a2JjdzBJYkRoaSt4dFNNTWNhaDlwNGtESmZZN0lXTU91WVMvbjBnT0lRMzdteUl1Sk9IQ1FocU5ldlRLQVk2NEpnYTMyT1JCb1BQVXcyUFRqbUhOQ1lQRllReHFPbXJaMHZRNk8zT2NJZXVZQURXZDlvdENZOHJSbWszMU8yMzBPM25weS9mRWhPSEtmSTNyd3lkTTFPRklERzhTUit4eGhuY05QZzIrc0h6aE83eHhyeEpycDlqazVHR2g4b2ZhQ1ltT0swNXJ0TGlaQ0dyNmFjT1g0RUJ5VDczT3NkWlRHUU9PczhTOGNQQTVGNkJ3NStPU0lOYVFaYWFnbGNFdzdJYkRtUGdjRGpiOGVmdUhnUVl3MXVjOFJFMnRDYUJ5WlR5czJBenB5bnlNbTFvcUFSa0M5OGs4U3g2d1RBZ3Z1Y3dUUk9DWkFxUFdmQjB3eEliQkRyTFVLb25HTVhRcU5RKzBjZVRFUk8wN1JIUTVSTlZleE9XajIwNXAxQnAvUU5jSnFJb1JhQXNjMEV3S1R6OWJJblZNa2tNYmhmQm9haDlZNThtSWl4czZwQlJxQk5TWFJPQ1kvclZsazhDbVl4akh0YTBYR1ZLYzFxNzdJTG80R2YrSWNHOFNSK3h6T1p3N1NDSzNIL2ptV3hORWZmTXFMaWVpeEJqVENLK05wd0dGNzVzaUxpZlJ4eE5MZ3dQTVlkbzUyck1tTGlXaXhGa1Vha1RYKzVZTkpIRG40NU9zY3BCRmVVeURVQ0RpbXVzSERuUHNjcEJGZG1TOHJOcVRUbXJ5WVNBTW56VFI0aktaMWpqbnZXelBIaENDZE5JNkpUeHhMbEFVbUJDWWNmS2FWeHVIODVLK0VqZWttQkZhSXRYVFI0RFQ2di9iT29MV0pLSWpqczZ3S1lSSEtHb2pSQlpNWXBTRWhXRUlJaHVBbGh4WktiUVVWUk5DYmVCUkU2RVdvV0JYUmp5Q2xJQ25ZcThkYzlDUmVQTzJuMkl1SE5OQkFDMDdXcmpHbUp1bXl1NWw1Tzc5RDZQM0h6SnZNLy9XbGRaTEtrWXZzZzhwQk5TRlRjdjdJSVovbmtMckkvdVVVaEEwV1R1dklqZVE1MHhHUkdtVE5ibzFXRHBNYm43TmJmSDRKdmFGNWhkTmlNNjBSeVhQQ3J4cHZWRU01TktjMXFua09xb21HWkw3bHlaRThaeXF3b1VWRjdZOGN5WE5JVlEyU3FMWThPUVR6SEhLTHo2K29KanF1MjU2Y0tmT2NPRjlreDZxSkVyM2E4dVJJbmtOTERVQTY3OGxobnVkTTJoQXdhMmg5NWdyMmtSekpjMmhWRFdMbFd5ZXNIUFFTdjRlSlVNME1xTG1GdzJsRDREZlBZYWNHdTVwcmh1R0c0S1J0alowYWdKVFgxU1RQb2FZR3RKTFgxU1RQSWFZR3dQQUtSL0ljYW1xOEx6bWpsY1BvQlk5cDVYQlRBNEJkYlV4Ym8vUEdaeEI1RGpNMVlNMjNXOFNudGNBZUptS21CcnVhUFNSbllJZFJualB0S00xTURjNXFyaHhaZk5KVEEyRE10MUVPd3cyQnJ6eUhsWnIrTjlEZmNpVFBJYWNHb0dLM3BhM1JWQU42NmJjY3lYUElxWEdQSEZjT3hUd24rSXZzck5RQTFHMVhqbzg4UjcySGlZaXBjWThjcHRPYXI4VW5KeldnRjFBTytRMUJZTHMxVG1vQWpHcmJiK1dvOURBUlJUVUFtWGxYanVwNXpwL0ZKeU0xL2JpZ2piRE5jMDU2a1oyVEduY2VRR0tjNS93Z3F3YTAya0RPdUl2c3F2N0NMdDJxUWZSYTIvZVp3LzloSXNKVjB5ZFJhaVB4ekhPSXErbW5vS2dtbG90UDhtb0FraWlINjRiQVY1N0Q0YXp4TUZFTzNjVm44RzJOVGRXNGNoUnBhOU51Q0JpcEFVajE1VEROYzN3dFBuazB0REZ5dHFtMHRlRHpIRFpWNDhwQk0yVHluSkF2c24vbXBRYmxjSjNXZkZ4a1o2Ym10NXg0NURuczFFeFJPVXcyQkpQazRHc2IvRUE1TWNoem5qU0JJeWhIK1R6bmUvTTBzTVMwVmM5emNrME5tR0pWMjBybk9UbU9aNDJIc2NZaXovRzUrTXp4bTlEK0psR3paNTduaEhTUmZYM2hFdkJHdTVKWFl2RTVJaWUzY0JIWVU2L3kzQkNNdjhpK2Z1TThLRUNtYW8vS29iSWg4Tm5XSGpWMVVBTEx2WTdMNDcrcHB4dWxtVThCZjJQVWJKWWJndVB6blBWSHVRdWdEbHJhNXJ3aEdKS3pucnVod0JUd04yYkI5bE01OVBLY3gzdVhFNkFZUmluUGNWcjd0M0llcjE4RjlkQ3Y1RzMyZWM3ZVpjWDYyYUN2SGNsaCt5TDdYdk1NS0lwZXMyMWZadzZSaDRuWWIybkdvYVVLTnZWcDdUOFBFNkdhcG5KRHdEQkdaYlJ5WEtqbk9Xb1h6UkZZT242bXRSa3ZQdmVhU3V6UEptSGd3TVpzUTdCM1E2Vk53S1RTNFpUbmZNZ3RLenVlamFLbjUyMDJlWTZ5MzJuK2g0WGpOSXNOUVdNaE51MXNnRm5LMi9UeW5IZkRjaG9MWnhVZm5JOUhyMWZ6bjN4VVRuUVBFelVheTdFMDQ5cEpWeDI2MDFxakViZURaaGdEN1h3aXVTSDQxcmg4RG1KTzM0NGQwclRtZjBQd0xic1lnelhBWkJMcGFwN1d0SmJOWHM2d3ZVd2JlTzBVSElkS252TUt6VndVTXdQMGVzSFpKcEhuWkpmaVBRRWNoMmF1T2M3TWYyRTN1MUNPN2RROERpMVoyM2FjR2Y3Q2JuWnA4Y0ljQ01kanBRdlhuTjNKZVU0WWJlMzkwckkwc3dtdHJmTGcybTdraTgvcyswVnBabE5ncEdvNHRrWDFnZ2U2T2V5dWxzL0xaRGIxVUYyNnR1MUUwZGE2M2U1UzhaSWlGOCtqd2twWDduZTJ0c0w5aGQzdTRjcXlLY2UvcitaV3ViWGIyUWhwV3VzZWJpNFdrMUl4dmpFeTZkTE5yUTRXVUlBYmdvK2IzYzN1NnUwTHNwY0pvSHpTZHpjNkc1MmRuUUR5bk0zTmo0ZUhLOFZ5VXJ3RXhGekNyS3p0Ym5YMjBZM1BQQWZOUEQ4NGVQNTZzVmczWkZvT0dpT1RlbGk2dmJPeHM3Ly80b1M3dFRjSGI5NitXVjB0WHNnWUlJU0ZacVhLNmRMZG15LzJuejdkd1k4eFo4N3J0NzNlVy93NFdGbTVkNlZjVHNvOEZnbHppZk5tdlZLc29DTXNuV2MvaCtqMWVnYzk5UFB5enAzYnhlSnkzVXFjRnkzUm94dEdCcWxmUjY1NDROLzFESExSME9YQW55a2FZbGpKWk5JMHpWUXFoWi80dHpXbmFlSkZFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVNCTXI4QURKdlVaMGJHZ0pRQUFBQUFTVVZPUks1Q1lJST1gO1xuXG5jb25zdCBzZXR1cFdhbGxldFN0YXRlID0gKHBhcmFtcywgbmV0d29yaykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IGtleVN0b3JlID0gbmV3IG5lYXJBUEkua2V5U3RvcmVzLkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZSh3aW5kb3cubG9jYWxTdG9yYWdlLCBcIl9tZXRlb3Jfd2FsbGV0XCIpO1xuICBjb25zdCBuZWFyID0geWllbGQgbmVhckFQSS5jb25uZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAga2V5U3RvcmVcbiAgfSwgbmV0d29yayksIHtcbiAgICBoZWFkZXJzOiB7fVxuICB9KSk7XG4gIGNvbnN0IHdhbGxldCA9IG5ldyBNZXRlb3JXYWxsZXQoe1xuICAgIG5lYXIsXG4gICAgYXBwS2V5UHJlZml4OiBcIm5lYXJfYXBwXCJcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgd2FsbGV0LFxuICAgIGtleVN0b3JlXG4gIH07XG59KTtcbmNvbnN0IGNyZWF0ZU1ldGVvcldhbGxldEluamVjdGVkID0gKHtcbiAgb3B0aW9ucyxcbiAgbG9nZ2VyLFxuICBzdG9yZSxcbiAgcGFyYW1zXG59KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QgX3N0YXRlID0geWllbGQgc2V0dXBXYWxsZXRTdGF0ZShwYXJhbXMsIG9wdGlvbnMubmV0d29yayk7XG4gIGNvbnN0IGdldEFjY291bnRzID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWNjb3VudElkID0gX3N0YXRlLndhbGxldC5nZXRBY2NvdW50SWQoKTtcbiAgICBjb25zdCBhY2NvdW50ID0gX3N0YXRlLndhbGxldC5hY2NvdW50KCk7XG4gICAgaWYgKCFhY2NvdW50SWQgfHwgIWFjY291bnQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgYWNjb3VudC5jb25uZWN0aW9uLnNpZ25lci5nZXRQdWJsaWNLZXkoYWNjb3VudC5hY2NvdW50SWQsIG9wdGlvbnMubmV0d29yay5uZXR3b3JrSWQpO1xuICAgIHJldHVybiBbe1xuICAgICAgYWNjb3VudElkLFxuICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXkgPyBwdWJsaWNLZXkudG9TdHJpbmcoKSA6IFwiXCJcbiAgICB9XTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2lnbkluKHtcbiAgICAgIGNvbnRyYWN0SWQsXG4gICAgICBtZXRob2ROYW1lcyA9IFtdXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIk1ldGVvcldhbGxldDpzaWduSW5cIiwge1xuICAgICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtZXRob2ROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICB5aWVsZCBfc3RhdGUud2FsbGV0LnJlcXVlc3RTaWduSW4oe1xuICAgICAgICAgICAgbWV0aG9kczogbWV0aG9kTmFtZXMsXG4gICAgICAgICAgICB0eXBlOiBFTWV0ZW9yV2FsbGV0U2lnbkluVHlwZS5TRUxFQ1RFRF9NRVRIT0RTLFxuICAgICAgICAgICAgY29udHJhY3RfaWQ6IGNvbnRyYWN0SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBfc3RhdGUud2FsbGV0LnJlcXVlc3RTaWduSW4oe1xuICAgICAgICAgICAgdHlwZTogRU1ldGVvcldhbGxldFNpZ25JblR5cGUuQUxMX01FVEhPRFMsXG4gICAgICAgICAgICBjb250cmFjdF9pZDogY29udHJhY3RJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIk1ldGVvcldhbGxldDpzaWduSW5cIiwge1xuICAgICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXMsXG4gICAgICAgICAgYWNjb3VudDogYWNjb3VudHNbMF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk91dCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChfc3RhdGUud2FsbGV0LmlzU2lnbmVkSW4oKSkge1xuICAgICAgICAgIHlpZWxkIF9zdGF0ZS53YWxsZXQuc2lnbk91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzU2lnbmVkSW4oKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoIV9zdGF0ZS53YWxsZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB2ZXJpZnlPd25lcih7XG4gICAgICBtZXNzYWdlXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIk1ldGVvcldhbGxldDp2ZXJpZnlPd25lclwiLCB7XG4gICAgICAgICAgbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfc3RhdGUud2FsbGV0LnZlcmlmeU93bmVyKHtcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5wYXlsb2FkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgdmVyaWZ5IG93bmVyOiAke3Jlc3BvbnNlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5vbmNlLFxuICAgICAgcmVjaXBpZW50LFxuICAgICAgc3RhdGVcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiTWV0ZW9yV2FsbGV0OnNpZ25NZXNzYWdlXCIsIHtcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWNjb3VudElkID0gX3N0YXRlLndhbGxldC5nZXRBY2NvdW50SWQoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfc3RhdGUud2FsbGV0LnNpZ25NZXNzYWdlKHtcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBheWxvYWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBzaWduIG1lc3NhZ2Ugb3duZXI6ICR7cmVzcG9uc2UubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHNpZ25lcklkLFxuICAgICAgcmVjZWl2ZXJJZCxcbiAgICAgIGFjdGlvbnNcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiTWV0ZW9yV2FsbGV0OnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICAgIHNpZ25lcklkLFxuICAgICAgICAgIHJlY2VpdmVySWQsXG4gICAgICAgICAgYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyYWN0XG4gICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIV9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBzaWduZWQgaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWNlaXZlcklkICYmICFjb250cmFjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY2VpdmVyIGZvdW5kIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfc3RhdGUud2FsbGV0LmFjY291bnQoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRbXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uX2RpcmVjdFwiXSh7XG4gICAgICAgICAgcmVjZWl2ZXJJZDogcmVjZWl2ZXJJZCAhPT0gbnVsbCAmJiByZWNlaXZlcklkICE9PSB2b2lkIDAgPyByZWNlaXZlcklkIDogY29udHJhY3QuY29udHJhY3RJZCxcbiAgICAgICAgICBhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9ucyh7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiTWV0ZW9yV2FsbGV0OnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghX3N0YXRlLndhbGxldC5pc1NpZ25lZEluKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IHNpZ25lZCBpblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N0YXRlLndhbGxldC5yZXF1ZXN0U2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBidWlsZEltcG9ydEFjY291bnRzVXJsKCkge1xuICAgICAgcmV0dXJuIGBodHRwczovL3dhbGxldC5tZXRlb3J3YWxsZXQuYXBwL2JhdGNoLWltcG9ydD9uZXR3b3JrPSR7X3N0YXRlLndhbGxldC5fbmV0d29ya0lkfWA7XG4gICAgfVxuICB9O1xufSk7XG5mdW5jdGlvbiBzZXR1cE1ldGVvcldhbGxldCh7XG4gIGljb25VcmwgPSBpY29uLFxuICBkZXByZWNhdGVkID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJtZXRlb3Itd2FsbGV0XCIsXG4gICAgICB0eXBlOiBcImluamVjdGVkXCIsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgICAgIG5hbWU6IFwiTWV0ZW9yIFdhbGxldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWN1cmVseSBzdG9yZSBhbmQgc3Rha2UgeW91ciBORUFSIHRva2VucyBhbmQgY29tcGF0aWJsZSBhc3NldHMgd2l0aCBNZXRlb3IuXCIsXG4gICAgICAgIGljb25VcmwsXG4gICAgICAgIGRlcHJlY2F0ZWQsXG4gICAgICAgIGRvd25sb2FkVXJsOiBcImh0dHBzOi8vd2FsbGV0Lm1ldGVvcndhbGxldC5hcHBcIixcbiAgICAgICAgdXNlVXJsQWNjb3VudEltcG9ydDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGluaXQ6IG9wdGlvbnMgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWV0ZW9yV2FsbGV0SW5qZWN0ZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgaWNvblVybFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzZXR1cE1ldGVvcldhbGxldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/meteor-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupModal: () => (/* binding */ setupModal)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @near-wallet-selector/core */ \"(ssr)/./node_modules/@near-wallet-selector/core/index.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! copy-to-clipboard */ \"(ssr)/./node_modules/copy-to-clipboard/index.js\");\n\n\n\n\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar fails$h = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$g = fails$h;\n\nvar functionBindNative = !fails$g(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$f = FunctionPrototype$2.call;\nvar uncurryThis$h = NATIVE_BIND$3 && bind$5.bind(call$f, call$f);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? function (fn) {\n  return fn && uncurryThis$h(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$f.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$g = functionUncurryThis;\n\nvar toString$5 = uncurryThis$g({}.toString);\nvar stringSlice$1 = uncurryThis$g(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$1(toString$5(it), 8, -1);\n};\n\nvar uncurryThis$f = functionUncurryThis;\nvar fails$f = fails$h;\nvar classof$6 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$f(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$f(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$6(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$e = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$3 = function (it) {\n  if (it == undefined) throw $TypeError$e(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$2 = indexedObject;\nvar requireObjectCoercible$2 = requireObjectCoercible$3;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject$2(requireObjectCoercible$2(it));\n};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$k =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar shared$3 = {exports: {}};\n\nvar global$j = global$k;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$6(global$j, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$j[key] = value;\n  } return value;\n};\n\nvar global$i = global$k;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$i[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$1 = requireObjectCoercible$3;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function (argument) {\n  return $Object$3(requireObjectCoercible$1(argument));\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar toObject$4 = toObject$5;\n\nvar hasOwnProperty = uncurryThis$e({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$4(it), key);\n};\n\nvar uncurryThis$d = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$4 = uncurryThis$d(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id + postfix, 36);\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$l = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar global$h = global$k;\nvar isCallable$k = isCallable$l;\n\nvar aFunction = function (argument) {\n  return isCallable$k(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];\n};\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$g = global$k;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$g.process;\nvar Deno$1 = global$g.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$e = fails$h;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$e(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$2 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$2\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar global$f = global$k;\nvar shared$2 = shared$3.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL$1 = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$f.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$g = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL$1 && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar isCallable$j = isCallable$l;\n\nvar isObject$8 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$j(it);\n};\n\nvar isObject$7 = isObject$8;\n\nvar $String$3 = String;\nvar $TypeError$d = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$c = function (argument) {\n  if (isObject$7(argument)) return argument;\n  throw $TypeError$d($String$3(argument) + ' is not an object');\n};\n\nvar objectDefineProperties = {};\n\nvar fails$d = fails$h;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$d(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$c = fails$h;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$c(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar objectDefineProperty = {};\n\nvar global$e = global$k;\nvar isObject$6 = isObject$8;\n\nvar document$3 = global$e.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$6(document$3) && isObject$6(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar fails$b = fails$h;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$a && !fails$b(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$e = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$e.bind(call$e) : function () {\n  return call$e.apply(call$e, arguments);\n};\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$c({}.isPrototypeOf);\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$i = isCallable$l;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$i($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$h = isCallable$l;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$c = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$h(argument)) return argument;\n  throw $TypeError$c(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$d = functionCall;\nvar isCallable$g = isCallable$l;\nvar isObject$5 = isObject$8;\n\nvar $TypeError$b = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n  if (isCallable$g(fn = input.valueOf) && !isObject$5(val = call$d(fn, input))) return val;\n  if (pref !== 'string' && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n  throw $TypeError$b(\"Can't convert object to primitive value\");\n};\n\nvar call$c = functionCall;\nvar isObject$4 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$f = wellKnownSymbol$g;\n\nvar $TypeError$a = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$f('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$4(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$c(exoticToPrim, input, pref);\n    if (!isObject$4(result) || isSymbol$1(result)) return result;\n    throw $TypeError$a(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$2 = toPropertyKey$3;\n\nvar $TypeError$9 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$2(P);\n  anObject$b(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$2(P);\n  anObject$b(Attributes);\n  if (IE8_DOM_DEFINE$1) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$9('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$1 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max$1 = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$5 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$5;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$4(O);\n    var index = toAbsoluteIndex$1(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\n\nvar hiddenKeys$4 = {};\n\nvar uncurryThis$b = functionUncurryThis;\nvar hasOwn$a = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar push$1 = uncurryThis$b([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$a(hiddenKeys$3, key) && hasOwn$a(O, key) && push$1(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$a(O, key = names[i++])) {\n    ~indexOf(result, key) || push$1(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$5 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$8 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$a(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$5.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$5 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$5('document', 'documentElement');\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$2[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$9(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$e = wellKnownSymbol$g;\nvar create$1 = objectCreate;\nvar defineProperty$5 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$e('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$1(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar uncurryThis$a = functionUncurryThis;\nvar isCallable$f = isCallable$l;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$a(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$f(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$d = global$k;\nvar isCallable$e = isCallable$l;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$d.WeakMap;\n\nvar nativeWeakMap = isCallable$e(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar createPropertyDescriptor$4 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar definePropertyModule$4 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$4;\n\nvar createNonEnumerableProperty$4 = DESCRIPTORS$7 ? function (object, key, value) {\n  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$c = global$k;\nvar uncurryThis$9 = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$c.TypeError;\nvar WeakMap = global$c.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$9(store.get);\n  var wmhas = uncurryThis$9(store.has);\n  var wmset = uncurryThis$9(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$1[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$9(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$3(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$9(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$9(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar DESCRIPTORS$6 = descriptors;\nvar call$b = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$4;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey$1 = toPropertyKey$3;\nvar hasOwn$8 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$1(O);\n  P = toPropertyKey$1(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$8(O, P)) return createPropertyDescriptor$2(!call$b(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$5 = descriptors;\nvar hasOwn$7 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$5 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$7(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$5 || (DESCRIPTORS$5 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar fails$a = fails$h;\nvar isCallable$d = isCallable$l;\nvar hasOwn$6 = hasOwnProperty_1;\nvar DESCRIPTORS$4 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$4 && !fails$a(function () {\n  return defineProperty$4(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$6(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$4) defineProperty$4(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, 'arity') && value.length !== options.arity) {\n    defineProperty$4(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$6(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$4) defineProperty$4(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$6(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$d(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$c = isCallable$l;\nvar definePropertyModule$3 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$6 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$c(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$3.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$8 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\n\nvar concat$1 = uncurryThis$8([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$2 = objectDefineProperty;\n\nvar copyConstructorProperties$2 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$2.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$9 = fails$h;\nvar isCallable$b = isCallable$l;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$b(detection) ? fails$9(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$b = global$k;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties$1 = copyConstructorProperties$2;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$b;\n  } else if (STATIC) {\n    target = global$b[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$b[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties$1(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$2(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$5(target, key, sourceProperty, options);\n  }\n};\n\nvar fails$8 = fails$h;\n\nvar correctPrototypeGetter = !fails$8(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$a = isCallable$l;\nvar toObject$3 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject$3(O);\n  if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$a(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype : null;\n};\n\nvar fails$7 = fails$h;\nvar isCallable$9 = isCallable$l;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$d = wellKnownSymbol$g;\n\nvar ITERATOR$5 = wellKnownSymbol$d('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$7(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$9(IteratorPrototype$2[ITERATOR$5])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$3 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$g;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$c('toStringTag');\n\nvar setToStringTag$3 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$3(target, TO_STRING_TAG$3)) {\n    defineProperty$3(target, TO_STRING_TAG$3, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$4;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$8 = isCallable$l;\n\nvar $String$1 = String;\nvar $TypeError$8 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$8(argument)) return argument;\n  throw $TypeError$8(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$7 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$7(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$7(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$c = _export;\nvar call$a = functionCall;\nvar FunctionName = functionName;\nvar isCallable$7 = isCallable$l;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$g;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$b('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$4]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$7(CurrentIteratorPrototype[ITERATOR$4])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$a(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$c({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty$2 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$3 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== 'values') try {\n  defineProperty$2(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$a = global$k;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$a = wellKnownSymbol$g;\n\nvar ITERATOR$3 = wellKnownSymbol$a('iterator');\nvar TO_STRING_TAG$2 = wellKnownSymbol$a('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$3] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$2]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$a[COLLECTION_NAME] && global$a[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar DESCRIPTORS$2 = descriptors;\nvar uncurryThis$6 = functionUncurryThis;\nvar call$9 = functionCall;\nvar fails$6 = fails$h;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$2 = toObject$5;\nvar IndexedObject$1 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$1 = Object.defineProperty;\nvar concat = uncurryThis$6([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$6(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$2 && $assign({ b: 1 }, $assign(defineProperty$1({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$1(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$2(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$1(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$2 || call$9(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$b = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$b({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst CloseIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    width: \"24\",\n    fill: \"#C1C1C1\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M0 0h24v24H0z\",\n      fill: \"none\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"\n    })]\n  }));\n};\n\nconst CloseButton = ({\n  onClick\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n    onClick: onClick,\n    className: \"close-button\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseIcon, {})\n  }));\n};\n\nconst ModalHeader = ({\n  title,\n  onCloseModal\n}) => {\n  const additionalClasses = title === \"Get a Wallet\" ? \" -open\" : \"\";\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"nws-modal-header\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n      className: `middleTitle ${additionalClasses}`\n    }, {\n      children: title\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n      onClick: onCloseModal\n    })]\n  }));\n};\n\nconst BackArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"8\",\n    height: \"14\",\n    viewBox: \"0 0 8 14\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M7 13L1 7L7 1\",\n      stroke: \"#6494EE\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst BackArrow = ({\n  onClick\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n    onClick: onClick,\n    className: \"back-button\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrowIcon, {})\n  }));\n};\n\nconst WalletNetworkChanged = ({\n  selector,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: onBack\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: \"You Must Change the Network\",\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"switch-network-message-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          children: [\"We've detected that you need to change your wallet's network to\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", Object.assign({\n            className: \"network-id\"\n          }, {\n            children: ` ${selector.options.network.networkId}`\n          })), \" \", \"for this dApp.\"]\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: \"Some wallets may not support changing networks. If you can not change networks you may consider switching to another wallet.\"\n        })]\n      }))\n    }))]\n  });\n};\n\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\nvar deletePropertyOrThrow$1 = function (O, P) {\n  if (!delete O[P]) throw $TypeError$7('Cannot delete property ' + tryToString$3(P) + ' of ' + tryToString$3(O));\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$g;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$9('toStringTag');\nvar test$1 = {};\n\ntest$1[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test$1) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$6 = isCallable$l;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$8 = wellKnownSymbol$g;\n\nvar TO_STRING_TAG = wellKnownSymbol$8('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$5 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$6(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$4 = classof$5;\n\nvar $String = String;\n\nvar toString$3 = function (argument) {\n  if (classof$4(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$4;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$5;\nvar createProperty = createProperty$1;\n\nvar $Array = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$3(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar fails$5 = fails$h;\n\nvar arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$5(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar firefox = userAgent$4.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent$3 = engineUserAgent;\n\nvar webkit = userAgent$3.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar $$a = _export;\nvar uncurryThis$5 = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar toObject$1 = toObject$5;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$5;\nvar deletePropertyOrThrow = deletePropertyOrThrow$1;\nvar toString$2 = toString$3;\nvar fails$4 = fails$h;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$2;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar test = [];\nvar un$Sort = uncurryThis$5(test.sort);\nvar push = uncurryThis$5(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails$4(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails$4(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD$1 = arrayMethodIsStrict$1('sort');\n\nvar STABLE_SORT = !fails$4(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString$2(x) > toString$2(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$$a({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable$7(comparefn);\n\n    var array = toObject$1(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike$2(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n\nvar $$9 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$3 = fails$h;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$3(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$9({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$2 = isObject$8;\nvar classof$3 = classofRaw$1;\nvar wellKnownSymbol$7 = wellKnownSymbol$g;\n\nvar MATCH$1 = wellKnownSymbol$7('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$2(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$3(it) == 'RegExp');\n};\n\nvar isRegExp = isRegexp;\n\nvar $TypeError$6 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp(it)) {\n    throw $TypeError$6(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar wellKnownSymbol$6 = wellKnownSymbol$g;\n\nvar MATCH = wellKnownSymbol$6('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$8 = _export;\nvar uncurryThis$4 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible = requireObjectCoercible$3;\nvar toString$1 = toString$3;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$4(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$8({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$1(requireObjectCoercible(this)),\n      toString$1(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\nvar aCallable$6 = aCallable$9;\nvar toObject = toObject$5;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$5;\n\nvar $TypeError$5 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$6(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = lengthOfArrayLike$1(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$5('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n\nvar classof$2 = classofRaw$1;\nvar global$9 = global$k;\n\nvar engineIsNode = classof$2(global$9.process) == 'process';\n\nvar $$7 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$2;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE$3 = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE$3 && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$7({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar $$6 = _export;\nvar DESCRIPTORS$1 = descriptors;\nvar global$8 = global$k;\nvar uncurryThis$3 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$l;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar toString = toString$3;\nvar defineProperty = objectDefineProperty.f;\nvar copyConstructorProperties = copyConstructorProperties$2;\n\nvar NativeSymbol = global$8.Symbol;\nvar SymbolPrototype = NativeSymbol && NativeSymbol.prototype;\n\nif (DESCRIPTORS$1 && isCallable$5(NativeSymbol) && (!('description' in SymbolPrototype) ||\n  // Safari 12 bug\n  NativeSymbol().description !== undefined\n)) {\n  var EmptyStringDescriptionStore = {};\n  // wrap Symbol constructor for correct work with undefined description\n  var SymbolWrapper = function Symbol() {\n    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);\n    var result = isPrototypeOf$3(SymbolPrototype, this)\n      ? new NativeSymbol(description)\n      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'\n      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n    if (description === '') EmptyStringDescriptionStore[result] = true;\n    return result;\n  };\n\n  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n  SymbolWrapper.prototype = SymbolPrototype;\n  SymbolPrototype.constructor = SymbolWrapper;\n\n  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';\n  var symbolToString = uncurryThis$3(SymbolPrototype.toString);\n  var symbolValueOf = uncurryThis$3(SymbolPrototype.valueOf);\n  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n  var replace = uncurryThis$3(''.replace);\n  var stringSlice = uncurryThis$3(''.slice);\n\n  defineProperty(SymbolPrototype, 'description', {\n    configurable: true,\n    get: function description() {\n      var symbol = symbolValueOf(this);\n      var string = symbolToString(symbol);\n      if (hasOwn$2(EmptyStringDescriptionStore, symbol)) return '';\n      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');\n      return desc === '' ? undefined : desc;\n    }\n  });\n\n  $$6({ global: true, constructor: true, forced: true }, {\n    Symbol: SymbolWrapper\n  });\n}\n\nconst WarningIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"18\",\n    height: \"18\",\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M4.95215 16.3536L10.2152 5.85657C10.9531 4.38481 13.0538 4.38519 13.7912 5.85723L19.0494 16.3543C19.7156 17.6841 18.7486 19.25 17.2612 19.25H6.74001C5.25228 19.25 4.28535 17.6835 4.95215 16.3536Z\",\n      stroke: \"#E6B73E\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M12 10V12\",\n      stroke: \"#E6B73E\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M12.5 16C12.5 16.2761 12.2761 16.5 12 16.5C11.7239 16.5 11.5 16.2761 11.5 16C11.5 15.7239 11.7239 15.5 12 15.5C12.2761 15.5 12.5 15.7239 12.5 16Z\",\n      stroke: \"#E6B73E\"\n    })]\n  }));\n};\n\nconst WalletOptions = ({\n  selector,\n  handleWalletClick\n}) => {\n  const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [recentModules, setRecentModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [moreModules, setMoreModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [activeWalletId, setActiveWalletId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.store.observable.subscribe(state => {\n      const {\n        selectedWalletId\n      } = selector.store.getState();\n      if (selectedWalletId) {\n        setActiveWalletId(selectedWalletId);\n      }\n      const wallets = state.modules.filter(module => !(module.type === \"instant-link\" && selectedWalletId !== module.id));\n      if (selector.options.optimizeWalletOrder) {\n        state.modules.sort((current, next) => {\n          if (current.metadata.deprecated === next.metadata.deprecated) {\n            return 0;\n          }\n          return current.metadata.deprecated ? 1 : -1;\n        });\n        state.modules.sort((current, next) => {\n          if (next.metadata.available === current.metadata.available) {\n            return 0;\n          }\n          return next.metadata.available ? 1 : -1;\n        });\n        const moreWallets = [];\n        const recentlySignedInWallets = [];\n        wallets.forEach(module => {\n          if (selector.store.getState().recentlySignedInWallets.includes(module.id)) {\n            recentlySignedInWallets.push(module);\n          } else {\n            moreWallets.push(module);\n          }\n        });\n        setRecentModules(recentlySignedInWallets);\n        setMoreModules(moreWallets);\n      }\n      if (selector.options.randomizeWalletOrder) {\n        setModules(wallets.sort(() => Math.random() - 0.5));\n      } else {\n        setModules(wallets);\n      }\n    });\n    return () => subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  function renderOptionsList(modulesToRender) {\n    return modulesToRender.reduce((result, module, index) => {\n      const {\n        selectedWalletId\n      } = selector.store.getState();\n      const {\n        name,\n        description,\n        iconUrl,\n        deprecated\n      } = module.metadata;\n      const selected = module.id === selectedWalletId;\n      result.push((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"li\", Object.assign({\n        tabIndex: 0,\n        className: `single-wallet ${activeWalletId === module.id ? \"selected-wallet\" : \"\"} ${selected ? \"connected-wallet\" : \"\"} ${deprecated ? \"deprecated-wallet\" : \"\"} sidebar ${module.id}`,\n        onClick: () => {\n          if (module.id === modulesToRender[index].id) {\n            setActiveWalletId(module.id);\n          }\n          return handleWalletClick(module);\n        }\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: iconUrl,\n            alt: name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"content\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"title\"\n          }, {\n            children: name\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"description\"\n          }, {\n            children: description\n          }))]\n        })), deprecated && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"warning-triangle\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WarningIcon, {})\n        }))]\n      }), module.id));\n      return result;\n    }, []);\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: selector.options.optimizeWalletOrder && selector.store.getState().recentlySignedInWallets.length > 0 ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"wallet-options-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"options-list-section\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list-section-header\"\n        }, {\n          children: \"Recent\"\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list more-options-list-content\"\n        }, {\n          children: renderOptionsList(recentModules)\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"options-list-section\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list-section-header\"\n        }, {\n          children: \"More\"\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"options-list more-options-list-content\"\n        }, {\n          children: renderOptionsList(moreModules)\n        }))]\n      }))]\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"wallet-options-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"options-list\"\n      }, {\n        children: renderOptionsList(modules)\n      }))\n    }))\n  });\n};\n\nconst ConnectionErrorIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"21\",\n    height: \"20\",\n    viewBox: \"0 0 21 20\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M10.5001 18.3333C15.1025 18.3333 18.8334 14.6023 18.8334 9.99996C18.8334 5.39759 15.1025 1.66663 10.5001 1.66663C5.89771 1.66663 2.16675 5.39759 2.16675 9.99996C2.16675 14.6023 5.89771 18.3333 10.5001 18.3333Z\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M13 7.5L8 12.5\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M8 7.5L13 12.5\",\n      stroke: \"#CE5A6F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })]\n  }));\n};\n\nconst ConnectionSuccessIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"21\",\n    height: \"20\",\n    viewBox: \"0 0 21 20\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M18.8333 9.2333V9.99997C18.8323 11.797 18.2504 13.5455 17.1744 14.9848C16.0984 16.4241 14.586 17.477 12.8628 17.9866C11.1395 18.4961 9.29768 18.4349 7.61202 17.8121C5.92636 17.1894 4.48717 16.0384 3.50909 14.5309C2.53101 13.0233 2.06645 11.24 2.18469 9.4469C2.30293 7.65377 2.99763 5.94691 4.16519 4.58086C5.33275 3.21482 6.91061 2.26279 8.66345 1.86676C10.4163 1.47073 12.2502 1.65192 13.8916 2.3833\",\n      stroke: \"#4FD98F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M18.8333 3.33337L10.5 11.675L8 9.17504\",\n      stroke: \"#4FD98F\",\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })]\n  }));\n};\n\nconst ConnectionResult = ({\n  module,\n  message,\n  err,\n  onRetry\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n    className: \"connection connecting-details\"\n  }, {\n    children: err ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"error-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"error\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionErrorIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionFailed\")]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n        children: message\n      }), (module === null || module === void 0 ? void 0 : module.metadata.available) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: onRetry\n      }, {\n        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.retry\")\n      }))]\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"success\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")]\n    }))\n  }));\n};\n\nconst AlertMessage = ({\n  message,\n  module,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: \"\",\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"alert-message connecting-wrapper connecting-wrapper-err\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n            alt: module === null || module === void 0 ? void 0 : module.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: module === null || module === void 0 ? void 0 : module.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionResult, {\n          module: module,\n          message: message,\n          err: message !== null,\n          onRetry: () => {\n            onBack(true);\n          }\n        })]\n      }))\n    }))]\n  });\n};\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$5 = wellKnownSymbol$g;\nvar DESCRIPTORS = descriptors;\n\nvar SPECIES$2 = wellKnownSymbol$5('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n    defineProperty(Constructor, SPECIES$2, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\n\nvar $TypeError$4 = TypeError;\n\nvar anInstance$1 = function (it, Prototype) {\n  if (isPrototypeOf$2(Prototype, it)) return it;\n  throw $TypeError$4('Incorrect invocation');\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$h;\nvar isCallable$4 = isCallable$l;\nvar classof$1 = classof$5;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$1(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$5;\n\nvar $TypeError$3 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw $TypeError$3(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$g;\n\nvar SPECIES$1 = wellKnownSymbol$4('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$6(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function () {\n  return call$8.apply(apply$1, arguments);\n});\n\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis = functionUncurryThis;\n\nvar arraySlice$1 = uncurryThis([].slice);\n\nvar $TypeError$2 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$2('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$7 = global$k;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$l;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$h;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$7.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$1(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$7.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$3(handler) ? handler : Function$1(handler);\n    var args = arraySlice(arguments, 1);\n    queue$1[++counter] = function () {\n      apply(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$3(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$7.addEventListener &&\n    isCallable$3(global$7.postMessage) &&\n    !global$7.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$1(post)\n  ) {\n    defer = post;\n    global$7.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$k;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$5 = global$k;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$2(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$2(macrotask, global$5);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$4 = global$k;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$4.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$3 = global$k;\n\nvar promiseNativeConstructor = global$3.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$2 = global$k;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$l;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$g;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$k;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$9;\nvar isCallable$1 = isCallable$l;\nvar isObject$1 = isObject$8;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$1('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$7(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$1.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$1 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$7(then, value,\n            bind$1(internalResolve, wrapper, state),\n            bind$1(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance(this, PromisePrototype);\n    aCallable$3(executor);\n    call$7(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$1(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$1(internalResolve, state);\n    this.reject = bind$1(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$2(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$7(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$5({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$2 = wellKnownSymbol$g;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$2 = wellKnownSymbol$2('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\n\nvar classof = classof$5;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$g;\n\nvar ITERATOR$1 = wellKnownSymbol$1('iterator');\n\nvar getIteratorMethod$2 = function (it) {\n  if (it != undefined) return getMethod$1(it, ITERATOR$1)\n    || getMethod$1(it, '@@iterator')\n    || Iterators[classof(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$9;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$5;\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar $TypeError$1 = TypeError;\n\nvar getIterator$1 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n  throw $TypeError$1(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$4(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$5(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$4(innerResult);\n  return value;\n};\n\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$5;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$5;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$4(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol = wellKnownSymbol$g;\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$3($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$l;\nvar defineBuiltIn$1 = defineBuiltIn$6;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$1(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$1(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$2 = anObject$c;\nvar isObject = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$2(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nconst HardwareWalletAccountsForm = ({\n  accounts,\n  onSelectedChanged,\n  onSubmit,\n  onChangeRoute\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"choose-ledger-account-form-wrapper\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n      children: [\"We found \", accounts.length, \" accounts on your device. Select the account(s) you wish to connect.\"]\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"button-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: () => {\n          onChangeRoute(\"SpecifyHDPath\");\n        }\n      }, {\n        children: \"HD.../0\"\n      }))\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"form\", Object.assign({\n      className: \"form\",\n      onSubmit: e => {\n        onSubmit(accounts, e);\n      }\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"nws-form-control\"\n        }, {\n          children: accounts.map((account, index) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"account\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n              onChange: e => {\n                onSelectedChanged(index, e.target.checked);\n              },\n              checked: account.selected,\n              type: \"checkbox\",\n              id: account.accountId,\n              name: account.accountId,\n              value: account.accountId\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"label\", Object.assign({\n              htmlFor: account.accountId\n            }, {\n              children: [\" \", account.accountId]\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {})]\n          }), index))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            type: \"submit\",\n            disabled: !accounts.some(x => x.selected)\n          }, {\n            children: \"Connect\"\n          }))\n        }))]\n      })\n    }))]\n  }));\n};\n\nvar img = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgBpVZ9aJVVGH+e55z33bi7zY9hMz+yMAeNoEIq6A9ZRKQWEsQNFIIpsf5Y9E+GsD9iBEEDMUkDa6ShRKKZYIWiRkaKaUGUGCKOTGMF84PNO99773vOefq9720yK5ZzD/dwPt/nd37P17lEk5Qnuz9roUkKT7T5bNe+QjTNLCHv24h1Xgh+OmtwQYPH2jUXwlnW9NRooqePfLS6MmmQ59cdeEGJlkJZA5MGVecoAwghBYZTVY9ftuaDSy8x8w9fbFl95JZAXuw9dmelkvRAyXxS7wMFryG4bIyWZiqzPgMhaFfGfn3NY3AZG9sPf/Dy8HidZvxkZc/h1pqnPlKey6yspMqUd9jVAEYY6RCGDQTwjGDwGTgAlbwRijV1C9vanz577tT+6r+YrOz5rlXFrQ/qZ+FbDxCfXS5oOgxln4v473f3rbgwdn7FK5/MCaH2eAg6X8g3K2iBMTiBkNJVKbod+ze9mgPZsY/UaicYzCE1HgpZc558olCTjTvWLxv9p1n3bV45iO7T5zq3TU9j9xTOLwQ5D9t48aEYrtGj2P/2BpNS78nZJoRdlDsYd8vphz273lqyhW5Rnlnz3hOe6SEwghvxPUMTVfYe2rpuUOqOkZeIxdSbsSJ8eTIAmXy5tftrMPkzi0C4B2ZDNHp+INvLQURkhYiJ6gDGko376DbEJ8k3mcnYBSeSM2ptL/XGsurNnxfnDIQNwCKADO1845Ef6Tbk0M51g4joMgncDyBmkrtsNEMQovcDxGYsGL2yDNAUxPv0VySs4yxhfeYbabJg0Awg+ILylEB6nKMpSOp0WCR1+QSuD4ELljNDEfyRrdXPCU1BTEgD7pyOzVmC2iBm0KgYAMCEeXovoClIjdKiVdQ3FYbzmatxWRqMPcNsDHyfNWskWk5TkJhNEwVyxA6hLL5clLJsW7voFxa6LiR5CCOeWzo3XFxKtyEdy3tnp7VahAoDp6PEVGvJye09l3P7K9k9WQijXBv4B6WG+0pvD0ybFEBHZ6OPh+/OGaBsIvNRAGp/ZHv1jJeon+omszBkFsr3FhsLB7rev3JLQKVSyfjmaW2BJSavDlqR7c5VrR+4AbLttbkXMehH7gjA8gZiD/tq+Or/ABZ3dUW/J62LcPUGcrW8pKSVFAg6cHz3O0l25qZHa/XGwWPg9aAwwzdZAaDX+7tbNsMYf5+bpaUS0dDQEF8rtsUxCbI5e5KRzGhBMiqNxllKju7d8NOYXjseRBytQngcVDL3wD9H+7vf3YS7mnnzqrZpwSxrwkh04cpM5NTMyJdHbIgaESyxJ6tZ5cDbw3qd0tqVCp25Se/4yYdr5/zm/ehjwvpxZHgN0Wlub0/Yt7awdykqRYFHy6NUQVrBd4o6p6ngrVL2Bo8ksuJqoXzq9Ln9m6rj9U74b6Wjo8OeP082aY5NUxRsYzwDkeFsU+MdUU3U4PG0QtbahqhadDMuHTy4fvS/9EwIUpdeuW/ZiShOipFxURRbNdWETFMRZrCFlEZGkuPHdycTafgLExNiI6YfUpcAAAAASUVORK5CYII=\";\n\nconst WalletConnecting = ({\n  wallet,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: \"\",\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"connecting-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.iconUrl,\n            alt: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"connecting-details\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"spinner\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n              src: img,\n              alt: \"loading-icon\"\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", {\n            children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectingTo\"), \" \", wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name, \"...\"]\n          })]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"connecting-message\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.wallet.connectingMessage.${wallet === null || wallet === void 0 ? void 0 : wallet.type}`)\n          })\n        }))]\n      }))\n    }))]\n  });\n};\n\nconst LedgerDeviceIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n    width: \"317\",\n    height: \"157\",\n    viewBox: \"0 0 317 157\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M249.99 16.0994C270.063 -0.864155 289.788 1.58873 301.497 10.7365C307.402 15.3499 311.278 21.6575 312.267 28.1258C313.247 34.5412 311.413 41.2233 305.692 46.8044C297.366 54.9273 286.343 55.3362 273.015 51.5109C261.654 48.25 249.058 42.0377 235.726 35.4627L235.726 35.4626L235.717 35.458C233.367 34.2992 230.995 33.129 228.602 31.9618C212.742 24.2253 196.067 16.6575 179.842 13.8595C163.538 11.0479 147.552 13.0313 133.266 24.522C128.032 28.732 123.478 35.2086 121.716 44.8205C119.961 54.3947 120.992 66.9771 126.703 83.4311C135.432 108.583 132.899 126.677 123.575 138.063C114.217 149.491 97.5614 154.733 76.7887 153.121C55.0043 151.43 29.0621 142.206 3.29867 125.227L0.887817 127.942C27.2472 145.405 53.9251 154.952 76.5105 156.705C97.9028 158.365 115.96 153.035 126.356 140.341C136.785 127.606 139.045 108.029 130.099 82.2524C124.521 66.1801 123.642 54.2493 125.252 45.4687C126.854 36.7258 130.94 31.006 135.519 27.3232C148.794 16.6458 163.649 14.715 179.231 17.4021C194.891 20.1027 211.146 27.4463 227.026 35.1928C229.381 36.3415 231.729 37.5001 234.066 38.6531L234.073 38.6568C247.382 45.223 260.324 51.608 272.024 54.9662C285.819 58.9258 298.493 58.8501 308.202 49.3776C314.764 42.9759 316.974 35.1288 315.82 27.5826C314.675 20.0893 310.237 13.0029 303.71 7.90363C290.555 -2.37382 268.938 -4.62038 247.67 13.3537L249.99 16.0994Z\",\n      fill: \"url(#paint0_linear_3_672)\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M260.264 17.8767L177.605 89.4649L157.679 73.9664L239.23 3.85423L260.264 17.8767Z\",\n      fill: \"#6A7075\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M205.939 54.4577L199.764 50.2636L233.316 20.9053L239.907 25.8395L205.939 54.4577Z\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M260.264 17.8757L177.605 89.4639L182.033 98.3202L264.323 26.363L260.264 17.8757Z\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M177.236 89.4646L181.295 98.3209L165.059 85.7745L170.963 85.0365L177.236 89.4646Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M93.4708 99.6384L91.9948 110.13L174.653 92.894L164.69 85.7749L93.4708 99.6384Z\",\n      fill: \"#DCDADA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M93.1157 104.323L94.314 100.129L165.613 86.3483L169.208 89.344L93.1157 104.323Z\",\n      fill: \"#C1C1C1\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M94.2086 99.7963L86.0903 101.272L92.3635 110.129L94.2086 99.7963Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M86.0903 100.907L89.0027 74.1304L178.455 55.2416C184.695 53.9962 195.766 54.7675 197.177 63.7058C198.284 70.717 195.506 73.9943 191.628 77.3592C188.495 80.0671 180.152 82.4646 178.343 82.8944C178.293 82.9064 178.241 82.9188 178.186 82.9319C177.38 83.1245 176.007 83.4525 170.644 84.5088C169.085 84.8158 167.382 85.1501 165.557 85.5078L164.933 85.63C146.312 89.2764 115.528 95.2297 93.9844 99.3849C91.1808 99.9257 88.5337 100.436 86.0903 100.907ZM185.076 75.554C190.748 73.3535 193.99 68.0745 192.318 63.7631C190.645 59.4517 184.691 57.7405 179.019 59.941C173.347 62.1416 170.105 67.4206 171.778 71.732C173.45 76.0434 179.404 77.7546 185.076 75.554Z\",\n      fill: \"#F4F1E8\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M199.764 50.3994L196.768 48.3043L232.194 18.0454L233.316 21.6403L199.764 50.3994Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M239.968 25.9943L232.588 20.4592V17.5071L241.813 24.5183L239.968 25.9943Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"182.084\",\n      cy: \"68.0811\",\n      rx: \"10.242\",\n      ry: \"7.46772\",\n      transform: \"rotate(-23.7949 182.084 68.0811)\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"182.084\",\n      cy: \"68.0816\",\n      rx: \"6.68462\",\n      ry: \"4.87394\",\n      transform: \"rotate(-23.7949 182.084 68.0816)\",\n      fill: \"#494E52\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M238.725 2.93094L260.368 17.2564L264.865 26.4556L181.615 99.0341L175.16 94.311L92.0028 110.947L85.3267 101.399L88.3269 73.8157L178.118 54.8553L238.725 2.93094ZM178.599 56.2622L89.6786 75.0388L86.9321 100.29C89.0979 99.8725 91.4124 99.4263 93.8446 98.9572C115.388 94.8019 146.171 88.8488 164.791 85.2026L165.415 85.0804C167.24 84.7228 168.943 84.3885 170.501 84.0816C175.853 83.0275 177.219 82.701 178.015 82.5107C178.07 82.4976 178.122 82.4852 178.173 82.4732C179.048 82.2652 181.558 81.5669 184.235 80.5851C186.742 79.6655 189.286 78.5354 190.802 77.3758L191.151 77.0922L191.644 76.6595C193.341 75.147 194.723 73.6739 195.61 71.871C196.571 69.916 196.982 67.5029 196.448 64.1178C195.8 60.0131 192.959 57.7574 189.408 56.6566C185.833 55.5483 181.637 55.6566 178.603 56.2615C178.601 56.2617 178.6 56.262 178.599 56.2622ZM192.631 77.7565L259.555 18.9531L263.042 26.0869L181.808 96.9078L178.132 89.5713L191.724 78.529C191.859 78.4249 191.988 78.32 192.11 78.2144L192.111 78.2136C192.286 78.0617 192.46 77.9094 192.631 77.7565ZM185.491 81.6908C185.24 81.7868 184.99 81.8802 184.743 81.9709C182.013 82.9723 179.447 83.6875 178.514 83.9093C178.463 83.9213 178.411 83.9338 178.356 83.9468C177.635 84.1192 176.472 84.3971 172.491 85.1919L177.172 88.4492L185.491 81.6908ZM176.631 89.8707L170.479 85.5903C169.306 85.8213 168.054 86.0673 166.731 86.3265L175.769 92.9276L179.548 95.6924L176.631 89.8707ZM164.758 86.7132C146.252 90.3362 116.027 96.1817 94.6324 100.308L93.2258 109.197L173.543 93.1293L164.758 86.7132ZM91.888 108.207L93.0909 100.606C91.0848 100.993 89.1642 101.363 87.3471 101.713L91.888 108.207ZM258.581 17.8436L197.306 71.6841C198.142 69.5779 198.41 67.0795 197.906 63.8876C197.143 59.0539 193.743 56.4549 189.845 55.2467C186.921 54.3402 183.662 54.1916 180.861 54.449L238.84 4.77668L258.581 17.8436ZM232.505 16.82L243.089 24.5643L205.915 56.5106L196.042 48.0665L232.505 16.82ZM232.118 19.096L198.312 48.0654L199.744 49.29L232.584 20.9424L232.118 19.096ZM233.456 22.1396L200.878 50.2604L205.913 54.5664L239.041 26.0969L233.456 22.1396ZM240.195 25.1054L240.717 24.6571L233.759 19.5663L234.06 20.7586L240.195 25.1054Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M190.194 69.9744C191.32 68.1409 191.576 66.2271 190.942 64.5937C190.308 62.9603 188.829 61.7198 186.761 61.1254C184.691 60.5307 182.116 60.6196 179.553 61.6139C176.991 62.6081 175.029 64.2794 173.902 66.1141C172.776 67.9477 172.52 69.8614 173.154 71.4948C173.788 73.1282 175.267 74.3687 177.335 74.9631C179.405 75.5578 181.98 75.4689 184.543 74.4746C187.105 73.4804 189.067 71.8091 190.194 69.9744ZM185.077 75.8508C190.749 73.6502 193.991 68.3712 192.318 64.0598C190.645 59.7484 184.691 58.0372 179.019 60.2378C173.347 62.4383 170.105 67.7173 171.778 72.0287C173.451 76.3401 179.405 78.0513 185.077 75.8508Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M187.391 69.169C188.127 67.9713 188.266 66.7721 187.881 65.7812C187.497 64.7903 186.586 63.9984 185.235 63.6102C183.883 63.2216 182.173 63.2741 180.456 63.9404C178.738 64.6068 177.441 65.7208 176.705 66.9196C175.969 68.1172 175.83 69.3165 176.215 70.3074C176.599 71.2983 177.511 72.0901 178.861 72.4783C180.214 72.8669 181.923 72.8144 183.64 72.1481C185.358 71.4818 186.655 70.3678 187.391 69.169ZM184.174 73.5242C188.156 71.9795 190.432 68.2738 189.257 65.2473C188.083 62.2208 183.904 61.0196 179.922 62.5643C175.94 64.1091 173.665 67.8148 174.839 70.8412C176.013 73.8677 180.193 75.0689 184.174 73.5242Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M240.499 41.2441C239.744 40.3649 239.844 39.04 240.724 38.285L249.781 30.5067C250.66 29.7516 251.985 29.8523 252.74 30.7315V30.7315C253.495 31.6108 253.395 32.9356 252.516 33.6907L243.458 41.469C242.579 42.224 241.254 42.1234 240.499 41.2441V41.2441Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M250.743 31.6265L241.685 39.4048C241.424 39.6287 241.395 40.0217 241.619 40.2825C241.842 40.5433 242.235 40.5731 242.496 40.3492L251.554 32.5709C251.815 32.3469 251.845 31.954 251.621 31.6932C251.397 31.4324 251.004 31.4025 250.743 31.6265ZM240.724 38.285C239.844 39.04 239.744 40.3649 240.499 41.2441C241.254 42.1234 242.579 42.224 243.458 41.469L252.516 33.6907C253.395 32.9356 253.495 31.6108 252.74 30.7315C251.985 29.8523 250.66 29.7516 249.781 30.5067L240.724 38.285Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M205.779 71.4647C205.005 70.5642 205.108 69.2073 206.009 68.4339L214.989 60.7218C215.89 59.9485 217.247 60.0516 218.02 60.9521V60.9521C218.793 61.8526 218.69 63.2095 217.79 63.9829L208.809 71.695C207.909 72.4683 206.552 72.3652 205.779 71.4647V71.4647Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M215.951 61.8416L206.97 69.5537C206.688 69.796 206.656 70.221 206.898 70.5031C207.141 70.7851 207.566 70.8174 207.848 70.5752L216.828 62.863C217.11 62.6208 217.143 62.1958 216.9 61.9137C216.658 61.6317 216.233 61.5994 215.951 61.8416ZM206.009 68.4339C205.108 69.2073 205.005 70.5642 205.779 71.4647C206.552 72.3652 207.909 72.4683 208.809 71.695L217.79 63.9829C218.69 63.2095 218.793 61.8526 218.02 60.9521C217.247 60.0516 215.89 59.9485 214.989 60.7218L206.009 68.4339Z\",\n      fill: \"black\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n      cx: \"141.356\",\n      cy: \"19.525\",\n      r: \"10.1855\",\n      fill: \"#FE89B4\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"139.062\",\n      cy: \"14.7094\",\n      rx: \"2.42519\",\n      ry: \"1.94015\",\n      transform: \"rotate(-34.544 139.062 14.7094)\",\n      fill: \"#FDF7FF\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n      cx: \"252.489\",\n      cy: \"79.7577\",\n      r: \"7.78893\",\n      fill: \"#EC5236\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n      cx: \"250.434\",\n      cy: \"76.3701\",\n      rx: \"2.61272\",\n      ry: \"2.09018\",\n      transform: \"rotate(-34.544 250.434 76.3701)\",\n      fill: \"#EDB69D\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M100.436 79.9254C100.461 79.6567 100.732 79.3897 101.042 79.329L106.657 78.2299C107.587 78.0478 108.281 78.5536 108.207 79.3596L107.759 84.2243C107.734 84.493 107.463 84.76 107.153 84.8207L100.416 86.1396C100.106 86.2003 99.8742 86.0317 99.899 85.7631L100.436 79.9254Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.8553 81.7775C95.9294 80.9715 96.7437 80.1704 97.6739 79.9883L98.7968 79.7685C99.1069 79.7078 99.3382 79.8764 99.3135 80.1451L99.1344 82.091C99.1096 82.3597 98.8382 82.6267 98.5282 82.6874L96.2824 83.127C95.9723 83.1877 95.741 83.0191 95.7657 82.7505L95.8553 81.7775Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.5865 84.6965C95.6112 84.4278 95.8826 84.1608 96.1927 84.1001L98.4385 83.6605C98.7486 83.5998 98.9799 83.7684 98.9552 84.037L98.7761 85.9829C98.7513 86.2516 98.4799 86.5186 98.1699 86.5793L95.9241 87.019C95.614 87.0797 95.3827 86.9111 95.4074 86.6424L95.5865 84.6965Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M95.2282 88.5884C95.2529 88.3197 95.5244 88.0527 95.8344 87.992L98.0802 87.5524C98.3903 87.4917 98.6216 87.6603 98.5969 87.929L98.4178 89.8749C98.3931 90.1435 98.1216 90.4105 97.8116 90.4712L96.6887 90.6911C95.7584 90.8732 95.0645 90.3674 95.1387 89.5614L95.2282 88.5884Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M99.7197 87.709C99.7444 87.4403 100.016 87.1733 100.326 87.1126L102.572 86.673C102.882 86.6123 103.113 86.7809 103.088 87.0496L102.909 88.9955C102.885 89.2641 102.613 89.5312 102.303 89.5919L100.057 90.0315C99.7472 90.0922 99.5159 89.9236 99.5406 89.6549L99.7197 87.709Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M104.211 86.8298C104.236 86.5611 104.507 86.2941 104.817 86.2334L107.063 85.7938C107.373 85.7331 107.605 85.9017 107.58 86.1704L107.49 87.1433C107.416 87.9493 106.602 88.7504 105.672 88.9325L104.549 89.1523C104.239 89.213 104.007 89.0444 104.032 88.7757L104.211 86.8298Z\",\n      fill: \"#B3AAAA\"\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"linearGradient\", Object.assign({\n        id: \"paint0_linear_3_672\",\n        x1: \"-44.5195\",\n        y1: \"122.42\",\n        x2: \"263.357\",\n        y2: \"-8.65023\",\n        gradientUnits: \"userSpaceOnUse\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n          offset: \"0.110697\",\n          stopColor: \"#232323\"\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n          offset: \"1\",\n          stopColor: \"#3D3D3D\"\n        })]\n      }))\n    })]\n  }));\n};\n\nconst UpArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"10\",\n    height: \"7\",\n    viewBox: \"0 0 10 7\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M9 5.4762L5 1.4762L1 5.4762\",\n      stroke: \"#4F7CD1\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst DownArrowIcon = () => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n    width: \"10\",\n    height: \"7\",\n    viewBox: \"0 0 10 7\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, {\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M1 1.52382L5 5.52382L9 1.52382\",\n      stroke: \"#4F7CD1\",\n      strokeWidth: \"1.5\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    })\n  }));\n};\n\nconst DEFAULT_DERIVATION_PATH = \"44'/397'/0'/0'/1'\";\nconst DerivationPath = ({\n  selector,\n  options,\n  onBack,\n  onConnected,\n  params,\n  onError,\n  onCloseModal\n}) => {\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"EnterDerivationPath\");\n  const [derivationPath, setDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(DEFAULT_DERIVATION_PATH);\n  const [customDerivationPath, setCustomDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1);\n  const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [selectedAccounts, setSelectedAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [hardwareWallet, setHardwareWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  const [customAccountId, setCustomAccountId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n  const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n  const initalHeaderTitle = (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\");\n  const [headerTitle, setHeaderTitle] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(initalHeaderTitle);\n  const getAccountIds = publicKey => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield fetch(`${selector.options.network.indexerUrl}/publicKey/ed25519:${publicKey}/accounts`);\n    if (!response.ok) {\n      throw new Error(\"Failed to get account id from public key\");\n    }\n    const accountIds = yield response.json();\n    if (!Array.isArray(accountIds) || !accountIds.length) {\n      return [];\n    }\n    return accountIds;\n  });\n  const resolveAccounts = wallet => __awaiter(void 0, void 0, void 0, function* () {\n    const publicKey = yield wallet.getPublicKey(derivationPath);\n    try {\n      const accountIds = yield getAccountIds(publicKey);\n      return accountIds.map((accountId, index) => {\n        return {\n          derivationPath,\n          publicKey,\n          accountId,\n          selected: index === 0\n        };\n      });\n    } catch (e) {\n      return null;\n    }\n  });\n  const handleValidateAccount = () => __awaiter(void 0, void 0, void 0, function* () {\n    const wallet = yield selector.wallet(params.walletId);\n    if (wallet.type !== \"hardware\") {\n      return;\n    }\n    setConnecting(true);\n    setHardwareWallet(wallet);\n    try {\n      const resolvedAccounts = yield resolveAccounts(wallet);\n      if (!resolvedAccounts) {\n        setRoute(\"AddCustomAccountId\");\n        return;\n      }\n      const noAccounts = resolvedAccounts.length === 0;\n      const multipleAccounts = resolvedAccounts.length > 1;\n      if (noAccounts) {\n        setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.noAccountsFound\"));\n        setRoute(\"NoAccountsFound\");\n        return;\n      }\n      setAccounts(resolvedAccounts);\n      if (!multipleAccounts) {\n        setSelectedAccounts(resolvedAccounts);\n        setRoute(\"OverviewAccounts\");\n      } else {\n        setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n        setRoute(\"ChooseAccount\");\n      }\n    } catch (err) {\n      setConnecting(false);\n      const message = err instanceof Error ? err.message : \"Something went wrong\";\n      onError(message, wallet);\n    } finally {\n      setConnecting(false);\n    }\n  });\n  const handleAddCustomAccountId = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n      setConnecting(true);\n      const publicKey = yield hardwareWallet.getPublicKey(derivationPath);\n      const accountList = [{\n        derivationPath: derivationPath,\n        publicKey,\n        accountId: customAccountId,\n        selected: true\n      }];\n      setAccounts(accountList);\n      setSelectedAccounts(accountList);\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting1Account\"));\n      setRoute(\"OverviewAccounts\");\n    } catch (err) {\n      setConnecting(false);\n      const message = err instanceof Error ? err.message : \"Something went wrong\";\n      onError(message, hardwareWallet);\n    } finally {\n      setConnecting(false);\n    }\n  });\n  const handleSignIn = () => {\n    const mapAccounts = selectedAccounts.map(account => {\n      return {\n        derivationPath: account.derivationPath,\n        publicKey: account.publicKey,\n        accountId: account.accountId\n      };\n    });\n    return hardwareWallet.signIn({\n      contractId: options.contractId,\n      methodNames: options.methodNames,\n      accounts: mapAccounts\n    }).then(() => onConnected()).catch(err => {\n      onError(`Error: ${err.message}`, hardwareWallet);\n    });\n  };\n  const handleOnBackButtonClick = () => {\n    if (route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\") {\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\"));\n      setRoute(\"EnterDerivationPath\");\n    }\n    if (route === \"OverviewAccounts\") {\n      setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n      setRoute(\"ChooseAccount\");\n    }\n  };\n  if (connecting) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"derivation-path-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n        wallet: hardwareWallet,\n        onBack: () => {\n          setConnecting(false);\n        },\n        onCloseModal: onCloseModal\n      })\n    }));\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\" || route === \"OverviewAccounts\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: handleOnBackButtonClick\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: headerTitle,\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"derivation-path-wrapper\"\n    }, {\n      children: [route === \"EnterDerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"enter-derivation-path\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"ledger-image\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LedgerDeviceIcon, {})\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"ledger-description\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.makeSureYourLedger\")\n          }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n            className: \"specify-path\",\n            onClick: () => {\n              setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n              setRoute(\"SpecifyHDPath\");\n            }\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\")\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleValidateAccount\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.continue\")\n          }))\n        }))]\n      })), route === \"SpecifyHDPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"specify-path-wrapper\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"change-path-wrapper\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"display-path\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n              children: derivationPath.slice(0, -2)\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"change-path\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"path-value\"\n            }, {\n              children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                children: customDerivationPath\n              })\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n              className: \"buttons-wrapper\"\n            }, {\n              children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                onClick: () => {\n                  const newValue = customDerivationPath + 1;\n                  const path = derivationPath.slice(0, -2);\n                  setDerivationPath(`${path}${newValue}'`);\n                  setCustomDerivationPath(newValue);\n                }\n              }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UpArrowIcon, {})\n              })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                onClick: () => {\n                  const newValue = customDerivationPath - 1;\n                  if (newValue < 0) {\n                    return;\n                  }\n                  const path = derivationPath.slice(0, -2);\n                  setDerivationPath(`${path}${newValue}'`);\n                  setCustomDerivationPath(newValue);\n                }\n              }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DownArrowIcon, {})\n              }))]\n            }))]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n          className: \"path-description\"\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.enterYourPreferredHDPath\")\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n          className: \"what-link\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n            href: \"https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets\",\n            target: \"_blank\"\n          }, {\n            children: \"What's this?\"\n          }))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleValidateAccount\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.scan\")\n          }))\n        }))]\n      })), route === \"NoAccountsFound\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"no-accounts-found-wrapper\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n          children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.cantFindAnyAccount\"), \" \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n            href: `https://${selector.options.network.networkId === \"testnet\" ? \"testnet\" : \"app\"}.mynearwallet.com/create`,\n            target: \"_blank\"\n          }, {\n            children: \"MyNearWallet\"\n          })), \" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.orConnectAnAnotherLedger\")]\n        })\n      })), route === \"ChooseAccount\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardwareWalletAccountsForm, {\n        accounts: accounts,\n        onSelectedChanged: (index, selected) => {\n          setAccounts(prevAccounts => {\n            const updateAccounts = prevAccounts.map((account, idx) => {\n              const selectedValue = index === idx ? selected : account.selected;\n              return Object.assign(Object.assign({}, account), {\n                selected: selectedValue\n              });\n            });\n            return [...updateAccounts];\n          });\n        },\n        onSubmit: (acc, e) => {\n          e.preventDefault();\n          const selectedAcc = acc.filter(account => account.selected);\n          setSelectedAccounts(selectedAcc);\n          const numberOfAccounts = selectedAcc.length;\n          setHeaderTitle(`${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting\")} ${numberOfAccounts} ${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.ofAccounts\")}`);\n          setRoute(\"OverviewAccounts\");\n        },\n        onChangeRoute: newRoute => {\n          if (newRoute === \"SpecifyHDPath\") {\n            setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n          }\n          setRoute(newRoute);\n        }\n      }), route === \"AddCustomAccountId\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"enter-custom-account\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.failedToAutomatically\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"input-wrapper\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n            type: \"text\",\n            placeholder: \"Account ID\",\n            value: customAccountId,\n            onChange: e => {\n              setCustomAccountId(e.target.value);\n            }\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleAddCustomAccountId\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"ledger.Continue\")\n          }))\n        }))]\n      })), route === \"OverviewAccounts\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"overview-wrapper\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.overviewTheListOfAuthorized\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"accounts\"\n        }, {\n          children: selectedAccounts.map((account, index) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"account\"\n            }, {\n              children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                children: account.accountId\n              })\n            }))\n          }, account.accountId))\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"action-buttons\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n            className: \"middleButton\",\n            onClick: handleSignIn,\n            disabled: accounts.length === 0\n          }, {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.finish\")\n          }))\n        }))]\n      }))]\n    }))]\n  });\n};\n\nconst WalletNotInstalled = ({\n  module,\n  onBack,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: onBack\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: \"\",\n        onCloseModal: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"wallet-not-installed-wrapper\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"wallet-data\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: `wallet-icon-box ${module.id}`\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module.metadata.iconUrl,\n            alt: module.metadata.name\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: module.metadata.name\n        })]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n        children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.youllNeedToInstall\"), \" \", module.metadata.name, \" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.toContinueAfterInstalling\"), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", Object.assign({\n          className: \"refresh-link\",\n          onClick: () => window.location.reload()\n        }, {\n          children: [\" \", (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.refreshThePage\")]\n        }))]\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"action-buttons\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            if (module.type !== \"injected\") {\n              return;\n            }\n            window.open(module.metadata.downloadUrl, \"_blank\");\n          }\n        }, {\n          children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.open\"), \" \", module.metadata.name]\n        }))\n      }))]\n    }))]\n  });\n};\n\nconst QRIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"18\",\n  height: \"16\",\n  viewBox: \"0 0 18 16\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22224 1.33334H1.44446V6.66668H7.22224V1.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M15.8889 1.33334H10.1111V6.66668H15.8889V1.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22224 9.33334H1.44446V14.6667H7.22224V9.33334Z\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M10.1111 13.1429V14.6667H15.8889M10.1111 9.33334V10.8572H12.5873V9.33334H15.8889V12.381\",\n    stroke: \"#4C5155\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"3.61108\",\n    y: \"3.33334\",\n    width: \"1.44444\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"3.61108\",\n    y: \"11.3333\",\n    width: \"1.44444\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n    x: \"12.2778\",\n    y: \"3.33334\",\n    width: \"1.44445\",\n    height: \"1.33333\",\n    fill: \"#4C5155\"\n  })]\n}));\n\nconst LinkIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"18\",\n  height: \"16\",\n  viewBox: \"0 0 18 16\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M13 8.66667V12.6667C13 13.0203 12.8478 13.3594 12.577 13.6095C12.3061 13.8595 11.9387 14 11.5556 14H3.61113C3.22804 14 2.86064 13.8595 2.58975 13.6095C2.31887 13.3594 2.16669 13.0203 2.16669 12.6667V5.33333C2.16669 4.97971 2.31887 4.64057 2.58975 4.39052C2.86064 4.14048 3.22804 4 3.61113 4H7.94447\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M10.8333 2H15.1666V6\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M7.22223 9.33333L15.1667 2\",\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nconst KeyIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n  width: \"40\",\n  height: \"40\",\n  viewBox: \"0 0 40 40\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })\n}));\n\nconst FolderIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: \"40\",\n  height: \"41\",\n  viewBox: \"0 0 40 41\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n    cx: \"28.3333\",\n    cy: \"23.8333\",\n    r: \"1.66667\",\n    fill: \"currentColor\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334\",\n    stroke: \"currentColor\",\n    strokeWidth: \"3\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nconst WalletHome = ({\n  selector,\n  onCloseModal\n}) => {\n  const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"WalletInfo\");\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.store.observable.subscribe(state => {\n      const filterByType = item => {\n        return item.type !== \"bridge\" && item.type !== \"hardware\" && item.type !== \"instant-link\";\n      };\n      const filteredModules = state.modules.filter(filterByType);\n      setModules(filteredModules);\n    });\n    return () => subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const getWalletUrl = module => {\n    let url = \"\";\n    if (module.type === \"injected\") {\n      url = module.metadata.downloadUrl;\n    }\n    if (module.type === \"browser\") {\n      url = module.metadata.walletUrl;\n    }\n    return url;\n  };\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: \"wallet-home-wrapper\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header-wrapper\"\n    }, {\n      children: [route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n        onClick: () => {\n          setRoute(\"WalletInfo\");\n        }\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n        title: route === \"GetWallets\" ? (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\") : (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.whatIsAWallet\"),\n        onCloseModal: onCloseModal\n      })]\n    })), route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"get-wallet-wrapper\"\n    }, {\n      children: modules.map(module => {\n        const {\n          iconUrl,\n          name\n        } = module.metadata;\n        const qrIcon = [\"nearfi\", \"here-wallet\"].includes(module.id);\n        const hereWalletType = module.id === \"here-wallet\" ? \"mobile\" : \"\";\n        const walletUrl = getWalletUrl(module);\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          tabIndex: 0,\n          className: `single-wallet-get ${module.id}`,\n          onClick: () => {\n            if (walletUrl) {\n              window.open(walletUrl, \"_blank\");\n            }\n          }\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"small-icon\"\n          }, {\n            children: [qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QRIcon, {}), !qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinkIcon, {})]\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n              src: iconUrl,\n              alt: name\n            })\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"title\"\n            }, {\n              children: name\n            })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n              className: \"type\"\n            }, {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.walletTypes.${hereWalletType || module.type}`)\n            }))]\n          }))]\n        }), module.id);\n      })\n    })), route === \"WalletInfo\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"wallet-info-wrapper what-wallet-hide\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-what\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon-side\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeyIcon, {})\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content-side\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.secureAndManage\")\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.safelyStore\")\n            })]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-what\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"icon-side\"\n          }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FolderIcon, {})\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"content-side\"\n          }, {\n            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.logInToAny\")\n            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n              children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.noNeedToCreate\")\n            })]\n          }))]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n          className: \"button-spacing\"\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            setRoute(\"GetWallets\");\n          }\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"what-wallet-mobile\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.useAWallet\")\n        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n          className: \"middleButton\",\n          onClick: () => {\n            setRoute(\"GetWallets\");\n          }\n        }, {\n          children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n        }))]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"lang-selector-wrapper\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"select\", Object.assign({\n          className: \"lang-selector\",\n          name: \"lang\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n            value: \"en\"\n          }, {\n            children: \"English\"\n          })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n            value: \"es\"\n          }, {\n            children: \"Spanish\"\n          }))]\n        }))\n      }))]\n    })]\n  }));\n};\n\nconst WalletConnected = ({\n  module,\n  onCloseModal\n}) => {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal-header\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n        className: \"middleTitle\"\n      }, {\n        children: ``\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n        onClick: onCloseModal\n      })]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n      className: \"connecting-wrapper\"\n    }, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"content\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"icon\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            className: \"green-dot\"\n          }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n            src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n            alt: module === null || module === void 0 ? void 0 : module.metadata.name\n          })]\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n          className: \"connecting-name\"\n        }, {\n          children: module === null || module === void 0 ? void 0 : module.metadata.name\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"wallet-connected-success\"\n        }, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")\n          })]\n        }))]\n      }))\n    }))]\n  });\n};\n\nvar anObject$1 = anObject$c;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString$3;\nvar fails = fails$h;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nconst CopyIcon = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, {\n  children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M6.5 15.25a1.75 1.75 0 0 1-1.75-1.75V6.75a2 2 0 0 1 2-2h6.75c.966 0 1.75.784 1.75 1.75\",\n    stroke: \"#4F7CD1\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n    d: \"M8.75 10.75a2 2 0 0 1 2-2h6.5a2 2 0 0 1 2 2v6.5a2 2 0 0 1-2 2h-6.5a2 2 0 0 1-2-2v-6.5Z\",\n    stroke: \"#4F7CD1\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  })]\n}));\n\nfunction formatQRCodeImage(data) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield qrcode__WEBPACK_IMPORTED_MODULE_4__.toString(data, {\n      margin: 0,\n      type: \"svg\"\n    });\n  });\n}\nconst ScanQRCode = ({\n  wallet,\n  uri,\n  onCloseModal,\n  handleOpenDefaultModal\n}) => {\n  const [notification, setNotification] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n  const [svg, setSvg] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n  const copyToClipboard = () => {\n    if (!uri) {\n      return;\n    }\n    const success = copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__(uri);\n    if (success) {\n      setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copiedToClipboard\"));\n      setTimeout(() => setNotification(\"\"), 1200);\n    } else {\n      setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.failedToCopy\"));\n      setTimeout(() => setNotification(\"\"), 1200);\n    }\n  };\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    (() => __awaiter(void 0, void 0, void 0, function* () {\n      if (uri) {\n        setSvg(yield formatQRCodeImage(uri));\n      }\n    }))();\n  }, [uri]);\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n    className: \"scan-qr-code\"\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n      title: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.scanWithYourMobile\"),\n      onCloseModal: onCloseModal\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n      className: \"qr-code\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        dangerouslySetInnerHTML: {\n          __html: svg\n        }\n      }), notification ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"notification\"\n      }, {\n        children: notification\n      })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"copy-btn\",\n        onClick: copyToClipboard\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CopyIcon, {}), (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copyToClipboard\")]\n      }))]\n    })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"footer\", Object.assign({\n      className: \"footer\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n        children: [(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.preferTheOfficial\"), \" \", wallet.metadata.name, \"?\"]\n      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        className: \"btn\",\n        onClick: handleOpenDefaultModal\n      }, {\n        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.open\")\n      }))]\n    }))]\n  }));\n};\n\nconst getThemeClass = theme => {\n  switch (theme) {\n    case \"dark\":\n      return \"dark-theme\";\n    case \"light\":\n      return \"light-theme\";\n    default:\n      return \"\";\n  }\n};\nconst Modal = ({\n  selector,\n  options,\n  visible,\n  hide,\n  emitter\n}) => {\n  var _a, _b, _c;\n  const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n    name: \"WalletHome\"\n  });\n  const [alertMessage, setAlertMessage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n  const [selectedWallet, setSelectedWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  const [bridgeWalletUri, setBridgeWalletUri] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    setRoute({\n      name: \"WalletHome\"\n    });\n    (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.allowOnlyLanguage)(selector.options.languageCode);\n    const {\n      selectedWalletId,\n      modules\n    } = selector.store.getState();\n    if (selectedWalletId) {\n      const module = modules.find(m => m.id === selectedWalletId);\n      setSelectedWallet(module);\n      setRoute({\n        name: \"WalletConnected\",\n        params: {\n          module\n        }\n      });\n    }\n    setBridgeWalletUri(\"\");\n    // eslint-disable-next-line\n  }, [visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const subscription = selector.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      // Switched back to the correct network.\n      if (networkId === selector.options.network.networkId) {\n        return handleDismissClick({});\n      }\n      setRoute({\n        name: \"WalletNetworkChanged\"\n      });\n    });\n    return () => subscription.remove();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const handleDismissClick = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(({\n    hideReason\n  }) => {\n    setAlertMessage(null);\n    setRoute({\n      name: \"WalletHome\"\n    });\n    if (hideReason === \"user-triggered\") {\n      emitter.emit(\"onHide\", {\n        hideReason\n      });\n    }\n    if (hideReason === \"wallet-navigation\") {\n      emitter.emit(\"onHide\", {\n        hideReason\n      });\n    }\n    hide();\n  }, [hide, emitter]);\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const close = e => {\n      if (e.key === \"Escape\") {\n        handleDismissClick({\n          hideReason: \"user-triggered\"\n        });\n      }\n    };\n    window.addEventListener(\"keydown\", close);\n    return () => window.removeEventListener(\"keydown\", close);\n  }, [handleDismissClick]);\n  const handleWalletClick = (module, qrCodeModal) => __awaiter(void 0, void 0, void 0, function* () {\n    setSelectedWallet(module);\n    const {\n      selectedWalletId\n    } = selector.store.getState();\n    if (selectedWalletId === module.id) {\n      setRoute({\n        name: \"WalletConnected\",\n        params: {\n          module\n        }\n      });\n      return;\n    }\n    try {\n      const {\n        deprecated,\n        available\n      } = module.metadata;\n      if (module.type === \"injected\" && !available) {\n        setRoute({\n          name: \"WalletNotInstalled\",\n          params: {\n            module: module\n          }\n        });\n        return;\n      }\n      const wallet = yield module.wallet();\n      if (deprecated) {\n        setAlertMessage(`${module.metadata.name} is deprecated. Please select another wallet.`);\n        setRoute({\n          name: \"AlertMessage\",\n          params: {\n            module: module\n          }\n        });\n        return;\n      }\n      if (wallet.type === \"hardware\") {\n        setRoute({\n          name: \"DerivationPath\",\n          params: {\n            walletId: wallet.id || \"ledger\"\n          }\n        });\n        return;\n      }\n      setRoute({\n        name: \"WalletConnecting\",\n        params: {\n          wallet: wallet\n        }\n      });\n      if (wallet.type === \"bridge\") {\n        const subscription = selector.on(\"uriChanged\", ({\n          uri\n        }) => {\n          setBridgeWalletUri(uri);\n          setRoute({\n            name: \"ScanQRCode\",\n            params: {\n              uri,\n              wallet\n            }\n          });\n        });\n        yield wallet.signIn({\n          contractId: options.contractId,\n          methodNames: options.methodNames,\n          qrCodeModal\n        });\n        subscription.remove();\n        handleDismissClick({\n          hideReason: \"wallet-navigation\"\n        });\n        return;\n      }\n      if (wallet.type === \"browser\") {\n        yield wallet.signIn({\n          contractId: options.contractId,\n          methodNames: options.methodNames,\n          successUrl: wallet.metadata.successUrl,\n          failureUrl: wallet.metadata.failureUrl\n        });\n        handleDismissClick({\n          hideReason: \"wallet-navigation\"\n        });\n        return;\n      }\n      yield wallet.signIn({\n        contractId: options.contractId,\n        methodNames: options.methodNames\n      });\n      handleDismissClick({\n        hideReason: \"wallet-navigation\"\n      });\n    } catch (err) {\n      const {\n        name\n      } = module.metadata;\n      const message = err instanceof Error ? err.message : \"Something went wrong\";\n      setAlertMessage(`Failed to sign in with ${name}: ${message}`);\n      setRoute({\n        name: \"AlertMessage\",\n        params: {\n          module: module\n        }\n      });\n    }\n  });\n  if (!visible) {\n    return null;\n  }\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n    className: `nws-modal-wrapper ${getThemeClass(options === null || options === void 0 ? void 0 : options.theme)} ${visible ? \"open\" : \"\"}`\n  }, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      className: \"nws-modal-overlay\",\n      onClick: () => {\n        handleDismissClick({\n          hideReason: \"user-triggered\"\n        });\n      }\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n      className: \"nws-modal\"\n    }, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"modal-left\"\n      }, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n          className: \"modal-left-title\"\n        }, {\n          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n            children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectYourWallet\")\n          })\n        })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletOptions, {\n          handleWalletClick: module => {\n            handleWalletClick(module, false);\n          },\n          selector: selector\n        })]\n      })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"modal-right\"\n      }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n          className: \"nws-modal-body\"\n        }, {\n          children: [route.name === \"AlertMessage\" && alertMessage && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AlertMessage, {\n            message: alertMessage,\n            module: (_a = route.params) === null || _a === void 0 ? void 0 : _a.module,\n            onBack: retry => {\n              if (retry) {\n                handleWalletClick(selectedWallet, false);\n              }\n              setAlertMessage(null);\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"DerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DerivationPath, {\n            selector: selector,\n            options: options,\n            onConnected: () => {\n              handleDismissClick({\n                hideReason: \"wallet-navigation\"\n              });\n            },\n            params: route.params,\n            onBack: () => setRoute({\n              name: \"WalletHome\"\n            }),\n            onError: (message, wallet) => {\n              const {\n                modules\n              } = selector.store.getState();\n              const findModule = modules.find(module => module.id === wallet.id);\n              setAlertMessage(message);\n              setRoute({\n                name: \"AlertMessage\",\n                params: {\n                  module: findModule\n                }\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletNetworkChanged\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNetworkChanged, {\n            selector: selector,\n            onBack: () => setRoute({\n              name: \"WalletHome\"\n            }),\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletNotInstalled\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNotInstalled, {\n            module: (_b = route.params) === null || _b === void 0 ? void 0 : _b.module,\n            onBack: () => {\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletConnecting\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n            wallet: (_c = route.params) === null || _c === void 0 ? void 0 : _c.wallet,\n            onBack: () => {\n              setRoute({\n                name: \"WalletHome\"\n              });\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletHome\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletHome, {\n            selector: selector,\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"WalletConnected\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnected, {\n            module: selectedWallet,\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            })\n          }), route.name === \"ScanQRCode\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ScanQRCode, {\n            handleOpenDefaultModal: () => {\n              handleWalletClick(selectedWallet, true);\n            },\n            onCloseModal: () => handleDismissClick({\n              hideReason: \"user-triggered\"\n            }),\n            uri: bridgeWalletUri,\n            wallet: selectedWallet\n          })]\n        }))\n      }))]\n    }))]\n  }));\n};\n\nconst MODAL_ELEMENT_ID = \"near-wallet-selector-modal\";\nlet modalInstance = null;\nlet root = null;\n/**\r\n * Initiates a modal instance\r\n * @param {WalletSelector} selector Selector\r\n * @param {ModalOptions} options Modal options\r\n * @returns {WalletSelectorModal} Returns a WalletSelectorModal object\r\n */\nconst setupModal = (selector, options) => {\n  if (!root) {\n    const body = document.body;\n    const container = document.createElement(\"div\");\n    container.id = MODAL_ELEMENT_ID;\n    body.appendChild(container);\n    root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(container);\n  }\n  const emitter = new _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n  const render = (visible = false) => {\n    root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Modal, {\n      selector: selector,\n      options: options,\n      visible: visible,\n      hide: () => render(false),\n      emitter: emitter\n    }));\n  };\n  if (!modalInstance) {\n    modalInstance = {\n      show: () => {\n        render(true);\n      },\n      hide: () => {\n        render(false);\n      },\n      on: (eventName, callback) => {\n        return emitter.on(eventName, callback);\n      },\n      off: (eventName, callback) => {\n        emitter.off(eventName, callback);\n      }\n    };\n  }\n  return modalInstance;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0U7QUFDeEI7QUFDNEI7QUFDYztBQUM1RDtBQUNTOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQixnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzQixxRUFBUyxtQ0FBbUMsNERBQTREO0FBQzlILFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLHVEQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNEQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRyxzREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0EsS0FBSyxHQUFHLHNEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7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Q0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxrQ0FBa0Msc0RBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsdUNBQXVDLHNEQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXLGtDQUFrQyxzREFBRztBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsY0FBYztBQUN6QixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVU7QUFDckI7QUFDQSxzQkFBc0Isb0VBQVk7QUFDbEM7QUFDQSxnQkFBZ0Isc0RBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRiYXNlbWludC8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3IvbW9kYWwtdWkvaW5kZXguanM/ODk3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3hzLCBqc3gsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVSb290IH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XG5pbXBvcnQgUmVhY3QsIHsgRnJhZ21lbnQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBhbGxvd09ubHlMYW5ndWFnZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUnO1xuaW1wb3J0IFFSQ29kZSBmcm9tICdxcmNvZGUnO1xuaW1wb3J0IGNvcHkgZnJvbSAnY29weS10by1jbGlwYm9hcmQnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGZhaWxzJGggPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJGcgPSBmYWlscyRoO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJGcoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQkNSA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZDtcbnZhciBjYWxsJGYgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkaCA9IE5BVElWRV9CSU5EJDMgJiYgYmluZCQ1LmJpbmQoY2FsbCRmLCBjYWxsJGYpO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDMgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJGgoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGYuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQ1ID0gdW5jdXJyeVRoaXMkZyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJGcoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSQxKHRvU3RyaW5nJDUoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkZiA9IGZhaWxzJGg7XG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZlJhdyQxO1xuXG52YXIgJE9iamVjdCQ0ID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkZignJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJGYoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkNihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQ0KGl0KTtcbn0gOiAkT2JqZWN0JDQ7XG5cbnZhciAkVHlwZUVycm9yJGUgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyAkVHlwZUVycm9yJGUoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0JDIgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMztcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0JDIocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKGl0KSk7XG59O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJGsgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIHNoYXJlZCQzID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCRqID0gZ2xvYmFsJGs7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JDYoZ2xvYmFsJGosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJGpba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRrO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDIgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUkMyA9IGdsb2JhbCRpW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkkMihTSEFSRUQsIHt9KTtcblxudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcblxuKHNoYXJlZCQzLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjIzLjMnLFxuICBtb2RlOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjMuMy9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMztcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3RcbnZhciB0b09iamVjdCQ1ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0JDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkNCA9IHRvT2JqZWN0JDU7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJGUoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDQoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDQgPSB1bmN1cnJ5VGhpcyRkKDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQ0KCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJGwgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGdsb2JhbCRoID0gZ2xvYmFsJGs7XG52YXIgaXNDYWxsYWJsZSRrID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGsoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkaFtuYW1lc3BhY2VdKSA6IGdsb2JhbCRoW25hbWVzcGFjZV0gJiYgZ2xvYmFsJGhbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkaztcbnZhciB1c2VyQWdlbnQkNSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRnLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJGcuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkNSkge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkZSA9IGZhaWxzJGg7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQyID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDJcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCRrO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDIoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJGYuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQxO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGcgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRiKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MJDEgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MJDEgJiYgaGFzT3duJGIoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEJDEgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGlzQ2FsbGFibGUkaiA9IGlzQ2FsbGFibGUkbDtcblxudmFyIGlzT2JqZWN0JDggPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRqKGl0KTtcbn07XG5cbnZhciBpc09iamVjdCQ3ID0gaXNPYmplY3QkODtcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGQgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRjID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ3KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGQoJFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIGZhaWxzJGQgPSBmYWlscyRoO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGMgPSBmYWlscyRoO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGIgJiYgZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIGdsb2JhbCRlID0gZ2xvYmFsJGs7XG52YXIgaXNPYmplY3QkNiA9IGlzT2JqZWN0JDg7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJGUuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JDYoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkNihkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRiID0gZmFpbHMkaDtcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGEgJiYgIWZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRlID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRlLmJpbmQoY2FsbCRlKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZS5hcHBseShjYWxsJGUsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkYyh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJGkgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNQcm90b3R5cGVPZiQ0ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMiA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDQoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMihpdCkpO1xufTtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQyKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJGw7XG52YXIgdHJ5VG9TdHJpbmckNCA9IHRyeVRvU3RyaW5nJDU7XG5cbnZhciAkVHlwZUVycm9yJGMgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDkgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkaChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciRjKHRyeVRvU3RyaW5nJDQoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ4ID0gYUNhbGxhYmxlJDk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkMyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ4KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkZCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JDg7XG5cbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJGQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGcoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJGQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGcoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDUodmFsID0gY2FsbCRkKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJGIoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgY2FsbCRjID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCQ4O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDM7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZiA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgJFR5cGVFcnJvciRhID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRmKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQ0KGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDIoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkYyhleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDQocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciRhKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGM7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQzO1xuXG52YXIgJFR5cGVFcnJvciQ5ID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ5ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYihBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkOSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciQxIDogY2VpbCkobik7XG59O1xuXG52YXIgdHJ1bmMgPSBtYXRoVHJ1bmM7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWF4JDEgPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDIgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heCQxKGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ0ID0gbGVuZ3RoT2ZBcnJheUxpa2UkNTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkNCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDQoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDEoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQxKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQxKGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMkNCA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJGEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBwdXNoJDEgPSB1bmN1cnJ5VGhpcyRiKFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMyhvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093biRhKGhpZGRlbktleXMkMywga2V5KSAmJiBoYXNPd24kYShPLCBrZXkpICYmIHB1c2gkMShyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kYShPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCBwdXNoJDEocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgZW51bUJ1Z0tleXMkMik7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRjO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQyO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxub2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkOCAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCRhKE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkMihQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDEoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kODtcblxudmFyIGh0bWwkMiA9IGdldEJ1aWx0SW4kNSgnZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbnZhciBzaGFyZWQkMSA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgdWlkID0gdWlkJDI7XG5cbnZhciBrZXlzID0gc2hhcmVkJDEoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xuXG52YXIgYW5PYmplY3QkOSA9IGFuT2JqZWN0JGM7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyQyID0gaGlkZGVuS2V5cyQ0O1xudmFyIGh0bWwkMSA9IGh0bWwkMjtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDIoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwkMS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cyQxLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXMkMVtsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5cyQyW0lFX1BST1RPJDFdID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QkOShPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgY3JlYXRlJDEgPSBvYmplY3RDcmVhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCRlKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eSQ1KEFycmF5UHJvdG90eXBlJDEsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUkMShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGw7XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGEoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkZihzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkNCA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCRkID0gZ2xvYmFsJGs7XG52YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRsO1xudmFyIGluc3BlY3RTb3VyY2UkMyA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCRkLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSRlKFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMyhXZWFrTWFwJDEpKTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IERFU0NSSVBUT1JTJDcgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkaztcbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkODtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQzO1xudmFyIGhpZGRlbktleXMkMSA9IGhpZGRlbktleXMkNDtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCRjLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsJGMuV2Vha01hcDtcbnZhciBzZXQkMSwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldCQxKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDMoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQyKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkOShzdG9yZS5nZXQpO1xuICB2YXIgd21oYXMgPSB1bmN1cnJ5VGhpcyQ5KHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJDkoc3RvcmUuc2V0KTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQxW1NUQVRFXSA9IHRydWU7XG4gIHNldCQxID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kOShpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDIoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzKGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ5KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ5KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQxLFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDM7XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJDYgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQxKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biQ4KE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoIWNhbGwkYihwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDUgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ3KEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDUgfHwgKERFU0NSSVBUT1JTJDUgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgZmFpbHMkYSA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSRkID0gaXNDYWxsYWJsZSRsO1xudmFyIGhhc093biQ2ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkNCAmJiAhZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQ0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ2KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDQpIGRlZmluZVByb3BlcnR5JDQodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kNihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ0KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ2KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQ0KSBkZWZpbmVQcm9wZXJ0eSQ0KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093biQ2KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRkKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkMSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJGw7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ2ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGModmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kODtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQ4ID0gYW5PYmplY3QkYztcblxudmFyIGNvbmNhdCQxID0gdW5jdXJyeVRoaXMkOChbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyQxID0gZ2V0QnVpbHRJbiQ0KCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JDgoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDUodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNShleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRoO1xudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkbDtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkYihkZXRlY3Rpb24pID8gZmFpbHMkOShkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRrO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciBkZWZpbmVCdWlsdEluJDUgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMjtcbnZhciBpc0ZvcmNlZCQxID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCRiO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCRiW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCRiW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQkMShHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMihzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbiQ1KHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBmYWlscyQ4ID0gZmFpbHMkaDtcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGw7XG52YXIgdG9PYmplY3QkMyA9IHRvT2JqZWN0JDU7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDM7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0JDEucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdCQxLmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDMoTyk7XG4gIGlmIChoYXNPd24kNChvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkYShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0JDEgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcblxudmFyIGZhaWxzJDcgPSBmYWlscyRoO1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkbDtcbnZhciBnZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sJGQoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQyLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkMShnZXRQcm90b3R5cGVPZiQxKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQyID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMiA9PSB1bmRlZmluZWQgfHwgZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ1XS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSQyID0ge307XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZSQ5KEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkNV0pKSB7XG4gIGRlZmluZUJ1aWx0SW4kNChJdGVyYXRvclByb3RvdHlwZSQyLCBJVEVSQVRPUiQ1LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDIsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGMoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyQzID0gZnVuY3Rpb24gKHRhcmdldCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xuICBpZiAodGFyZ2V0ICYmICFoYXNPd24kMyh0YXJnZXQsIFRPX1NUUklOR19UQUckMykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQzKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQzLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0O1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyQyKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcbiAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbDtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDggPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkOChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ4KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JDcgPSBhbk9iamVjdCRjO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyQ3KE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCQ3KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciAkJGMgPSBfZXhwb3J0O1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRsO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDE7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciBkZWZpbmVCdWlsdEluJDMgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkZztcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJGIoJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBkZWZpbmVJdGVyYXRvciQxID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YkMSkge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUkNyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkNF0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkNCwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSQxICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmIChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoSXRlcmFibGVQcm90b3R5cGUsICduYW1lJywgVkFMVUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIGNhbGwkYShuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkJGMoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmIChJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ0XSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQ0LCBkZWZhdWx0SXRlcmF0b3IsIHsgbmFtZTogREVGQVVMVCB9KTtcbiAgfVxuICBJdGVyYXRvcnMkM1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDE7XG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcbnZhciB2YWx1ZXMgPSBJdGVyYXRvcnMkMi5Bcmd1bWVudHMgPSBJdGVyYXRvcnMkMi5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQzICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkkMih2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCRhID0gZ2xvYmFsJGs7XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJGEoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGEoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkM10gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SJDMsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQzXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBRyQyXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUckMiwgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWwkYVtDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbCRhW0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG5cbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJDYgPSBmYWlscyRoO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDI7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JDU7XG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzJDYoW10uY29uY2F0KTtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG52YXIgb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyQyICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkkMSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5JDEodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXN5bWJvbCAtLSBzYWZlXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkMih0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QkMShhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyQyIHx8IGNhbGwkOShwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBhc3NpZ24gPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCRiKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBDbG9zZUljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICB3aWR0aDogXCIyNFwiLFxuICAgIGZpbGw6IFwiI0MxQzFDMVwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMCAwaDI0djI0SDB6XCIsXG4gICAgICBmaWxsOiBcIm5vbmVcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBDbG9zZUJ1dHRvbiA9ICh7XG4gIG9uQ2xpY2tcbn0pID0+IHtcbiAgcmV0dXJuIGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIGNsYXNzTmFtZTogXCJjbG9zZS1idXR0b25cIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IGpzeChDbG9zZUljb24sIHt9KVxuICB9KSk7XG59O1xuXG5jb25zdCBNb2RhbEhlYWRlciA9ICh7XG4gIHRpdGxlLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgY29uc3QgYWRkaXRpb25hbENsYXNzZXMgPSB0aXRsZSA9PT0gXCJHZXQgYSBXYWxsZXRcIiA/IFwiIC1vcGVuXCIgOiBcIlwiO1xuICByZXR1cm4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlclwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcImgzXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBgbWlkZGxlVGl0bGUgJHthZGRpdGlvbmFsQ2xhc3Nlc31gXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IHRpdGxlXG4gICAgfSkpLCBqc3goQ2xvc2VCdXR0b24sIHtcbiAgICAgIG9uQ2xpY2s6IG9uQ2xvc2VNb2RhbFxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBCYWNrQXJyb3dJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHdpZHRoOiBcIjhcIixcbiAgICBoZWlnaHQ6IFwiMTRcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA4IDE0XCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNNyAxM0wxIDdMNyAxXCIsXG4gICAgICBzdHJva2U6IFwiIzY0OTRFRVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSlcbiAgfSkpO1xufTtcblxuY29uc3QgQmFja0Fycm93ID0gKHtcbiAgb25DbGlja1xufSkgPT4ge1xuICByZXR1cm4ganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgY2xhc3NOYW1lOiBcImJhY2stYnV0dG9uXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBqc3goQmFja0Fycm93SWNvbiwge30pXG4gIH0pKTtcbn07XG5cbmNvbnN0IFdhbGxldE5ldHdvcmtDaGFuZ2VkID0gKHtcbiAgc2VsZWN0b3IsXG4gIG9uQmFjayxcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1oZWFkZXItd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goQmFja0Fycm93LCB7XG4gICAgICAgIG9uQ2xpY2s6IG9uQmFja1xuICAgICAgfSksIGpzeChNb2RhbEhlYWRlciwge1xuICAgICAgICB0aXRsZTogXCJZb3UgTXVzdCBDaGFuZ2UgdGhlIE5ldHdvcmtcIixcbiAgICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXVxuICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcInN3aXRjaC1uZXR3b3JrLW1lc3NhZ2Utd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3hzKFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcIldlJ3ZlIGRldGVjdGVkIHRoYXQgeW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgd2FsbGV0J3MgbmV0d29yayB0b1wiLCBqc3goXCJzdHJvbmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibmV0d29yay1pZFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGAgJHtzZWxlY3Rvci5vcHRpb25zLm5ldHdvcmsubmV0d29ya0lkfWBcbiAgICAgICAgICB9KSksIFwiIFwiLCBcImZvciB0aGlzIGRBcHAuXCJdXG4gICAgICAgIH0pLCBqc3goXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJTb21lIHdhbGxldHMgbWF5IG5vdCBzdXBwb3J0IGNoYW5naW5nIG5ldHdvcmtzLiBJZiB5b3UgY2FuIG5vdCBjaGFuZ2UgbmV0d29ya3MgeW91IG1heSBjb25zaWRlciBzd2l0Y2hpbmcgdG8gYW5vdGhlciB3YWxsZXQuXCJcbiAgICAgICAgfSldXG4gICAgICB9KSlcbiAgICB9KSldXG4gIH0pO1xufTtcblxudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuXG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93JDEgPSBmdW5jdGlvbiAoTywgUCkge1xuICBpZiAoIWRlbGV0ZSBPW1BdKSB0aHJvdyAkVHlwZUVycm9yJDcoJ0Nhbm5vdCBkZWxldGUgcHJvcGVydHkgJyArIHRyeVRvU3RyaW5nJDMoUCkgKyAnIG9mICcgKyB0cnlUb1N0cmluZyQzKE8pKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDkoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCQxID0ge307XG5cbnRlc3QkMVtUT19TVFJJTkdfVEFHJDFdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QkMSkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJGw7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQ4KCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQ1ID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJDYoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZiQ1O1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nJDMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YkNChhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkNTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5JDE7XG5cbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkobWF4KGZpbiAtIGssIDApKTtcbiAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICByZXN1bHQubGVuZ3RoID0gbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpO1xuICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShcbiAgICBhcnJheSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQyKGFycmF5LCAwLCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgY29tcGFyZWZuXG4gICk7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcblxuICB3aGlsZSAobGluZGV4IDwgbGxlbmd0aCB8fCByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IChsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGgpXG4gICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5U29ydCA9IG1lcmdlU29ydDtcblxudmFyIGZhaWxzJDUgPSBmYWlscyRoO1xuXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQyID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0sIDEpO1xuICB9KTtcbn07XG5cbnZhciB1c2VyQWdlbnQkNCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQkNC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxudmFyIGVuZ2luZUZmVmVyc2lvbiA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcblxudmFyIFVBID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJZU9yRWRnZSA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG52YXIgdXNlckFnZW50JDMgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQkMy5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxudmFyIGVuZ2luZVdlYmtpdFZlcnNpb24gPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG52YXIgJCRhID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNyA9IGFDYWxsYWJsZSQ5O1xudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyA9IGRlbGV0ZVByb3BlcnR5T3JUaHJvdyQxO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQzO1xudmFyIGZhaWxzJDQgPSBmYWlscyRoO1xudmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDI7XG52YXIgRkYgPSBlbmdpbmVGZlZlcnNpb247XG52YXIgSUVfT1JfRURHRSA9IGVuZ2luZUlzSWVPckVkZ2U7XG52YXIgVjggPSBlbmdpbmVWOFZlcnNpb247XG52YXIgV0VCS0lUID0gZW5naW5lV2Via2l0VmVyc2lvbjtcblxudmFyIHRlc3QgPSBbXTtcbnZhciB1biRTb3J0ID0gdW5jdXJyeVRoaXMkNSh0ZXN0LnNvcnQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyQ1KHRlc3QucHVzaCk7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KTtcbi8vIFY4IGJ1Z1xudmFyIEZBSUxTX09OX05VTEwgPSBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7XG4vLyBPbGQgV2ViS2l0XG52YXIgU1RSSUNUX01FVEhPRCQxID0gYXJyYXlNZXRob2RJc1N0cmljdCQxKCdzb3J0Jyk7XG5cbnZhciBTVEFCTEVfU09SVCA9ICFmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzA7XG4gIGlmIChGRiAmJiBGRiA+IDMpIHJldHVybjtcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAzO1xuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNvZGUsIGNociwgdmFsdWUsIGluZGV4O1xuXG4gIC8vIGdlbmVyYXRlIGFuIGFycmF5IHdpdGggbW9yZSA1MTIgZWxlbWVudHMgKENoYWtyYSBhbmQgb2xkIFY4IGZhaWxzIG9ubHkgaW4gdGhpcyBjYXNlKVxuICBmb3IgKGNvZGUgPSA2NTsgY29kZSA8IDc2OyBjb2RlKyspIHtcbiAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIDY2OiBjYXNlIDY5OiBjYXNlIDcwOiBjYXNlIDcyOiB2YWx1ZSA9IDM7IGJyZWFrO1xuICAgICAgY2FzZSA2ODogY2FzZSA3MTogdmFsdWUgPSA0OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHZhbHVlID0gMjtcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0NzsgaW5kZXgrKykge1xuICAgICAgdGVzdC5wdXNoKHsgazogY2hyICsgaW5kZXgsIHY6IHZhbHVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRlc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi52IC0gYS52OyB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHRlc3RbaW5kZXhdLmsuY2hhckF0KDApO1xuICAgIGlmIChyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSAhPT0gY2hyKSByZXN1bHQgKz0gY2hyO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gJ0RHQkVGSEFDSUpLJztcbn0pO1xuXG52YXIgRk9SQ0VEID0gRkFJTFNfT05fVU5ERUZJTkVEIHx8ICFGQUlMU19PTl9OVUxMIHx8ICFTVFJJQ1RfTUVUSE9EJDEgfHwgIVNUQUJMRV9TT1JUO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgcmV0dXJuIHRvU3RyaW5nJDIoeCkgPiB0b1N0cmluZyQyKHkpID8gMSA6IC0xO1xuICB9O1xufTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiQkYSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZSQ3KGNvbXBhcmVmbik7XG5cbiAgICB2YXIgYXJyYXkgPSB0b09iamVjdCQxKHRoaXMpO1xuXG4gICAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyB1biRTb3J0KGFycmF5KSA6IHVuJFNvcnQoYXJyYXksIGNvbXBhcmVmbik7XG5cbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgYXJyYXlMZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQyKGFycmF5KTtcbiAgICB2YXIgaXRlbXNMZW5ndGgsIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChpbmRleCBpbiBhcnJheSkgcHVzaChpdGVtcywgYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuXG4gICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgaXRlbXNMZW5ndGgpIGFycmF5W2luZGV4XSA9IGl0ZW1zW2luZGV4KytdO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGVQcm9wZXJ0eU9yVGhyb3coYXJyYXksIGluZGV4KyspO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59KTtcblxudmFyICQkOSA9IF9leHBvcnQ7XG52YXIgJGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcy5pbmNsdWRlcztcbnZhciBmYWlscyQzID0gZmFpbHMkaDtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gYWRkVG9VbnNjb3BhYmxlcyQyO1xuXG4vLyBGRjk5KyBidWdcbnZhciBCUk9LRU5fT05fU1BBUlNFID0gZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kJDkoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJST0tFTl9PTl9TUEFSU0UgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcblxudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCQ4O1xudmFyIGNsYXNzb2YkMyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgTUFUQ0gkMSA9IHdlbGxLbm93blN5bWJvbCQ3KCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0JDIoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSCQxXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mJDMoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cbnZhciBpc1JlZ0V4cCA9IGlzUmVnZXhwO1xuXG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuXG52YXIgbm90QVJlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQ2KFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2wkNignbWF0Y2gnKTtcblxudmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgJCQ4ID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBub3RBUmVnRXhwID0gbm90QVJlZ2V4cDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzO1xudmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQzO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gY29ycmVjdElzUmVnZXhwTG9naWM7XG5cbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMkNCgnJy5pbmRleE9mKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG4kJDgoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfnN0cmluZ0luZGV4T2YoXG4gICAgICB0b1N0cmluZyQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpLFxuICAgICAgdG9TdHJpbmckMShub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDk7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQ1O1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xuXG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgYUNhbGxhYmxlJDYoY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgJFR5cGVFcnJvciQ1KCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZWR1Y2UgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJGs7XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDIoZ2xvYmFsJDkucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQyO1xudmFyIENIUk9NRV9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIElTX05PREUkMyA9IGVuZ2luZUlzTm9kZTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbi8vIENocm9tZSA4MC04MiBoYXMgYSBjcml0aWNhbCBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcbnZhciBDSFJPTUVfQlVHID0gIUlTX05PREUkMyAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuJCQ3KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB8fCBDSFJPTUVfQlVHIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkaztcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRsO1xudmFyIGlzUHJvdG90eXBlT2YkMyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyQzO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQyO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsJDguU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuXG5pZiAoREVTQ1JJUFRPUlMkMSAmJiBpc0NhbGxhYmxlJDUoTmF0aXZlU3ltYm9sKSAmJiAoISgnZGVzY3JpcHRpb24nIGluIFN5bWJvbFByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJlc3VsdCA9IGlzUHJvdG90eXBlT2YkMyhTeW1ib2xQcm90b3R5cGUsIHRoaXMpXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IFN5bWJvbFByb3RvdHlwZTtcbiAgU3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgTkFUSVZFX1NZTUJPTCA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHVuY3VycnlUaGlzJDMoU3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgdmFyIHN5bWJvbFZhbHVlT2YgPSB1bmN1cnJ5VGhpcyQzKFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mKTtcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIHZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkMygnJy5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMkMygnJy5zbGljZSk7XG5cbiAgZGVmaW5lUHJvcGVydHkoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgc3ltYm9sID0gc3ltYm9sVmFsdWVPZih0aGlzKTtcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xUb1N0cmluZyhzeW1ib2wpO1xuICAgICAgaWYgKGhhc093biQyKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBOQVRJVkVfU1lNQk9MID8gc3RyaW5nU2xpY2Uoc3RyaW5nLCA3LCAtMSkgOiByZXBsYWNlKHN0cmluZywgcmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkJDYoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cblxuY29uc3QgV2FybmluZ0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHdpZHRoOiBcIjE4XCIsXG4gICAgaGVpZ2h0OiBcIjE4XCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNNC45NTIxNSAxNi4zNTM2TDEwLjIxNTIgNS44NTY1N0MxMC45NTMxIDQuMzg0ODEgMTMuMDUzOCA0LjM4NTE5IDEzLjc5MTIgNS44NTcyM0wxOS4wNDk0IDE2LjM1NDNDMTkuNzE1NiAxNy42ODQxIDE4Ljc0ODYgMTkuMjUgMTcuMjYxMiAxOS4yNUg2Ljc0MDAxQzUuMjUyMjggMTkuMjUgNC4yODUzNSAxNy42ODM1IDQuOTUyMTUgMTYuMzUzNlpcIixcbiAgICAgIHN0cm9rZTogXCIjRTZCNzNFXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xMiAxMFYxMlwiLFxuICAgICAgc3Ryb2tlOiBcIiNFNkI3M0VcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xMi41IDE2QzEyLjUgMTYuMjc2MSAxMi4yNzYxIDE2LjUgMTIgMTYuNUMxMS43MjM5IDE2LjUgMTEuNSAxNi4yNzYxIDExLjUgMTZDMTEuNSAxNS43MjM5IDExLjcyMzkgMTUuNSAxMiAxNS41QzEyLjI3NjEgMTUuNSAxMi41IDE1LjcyMzkgMTIuNSAxNlpcIixcbiAgICAgIHN0cm9rZTogXCIjRTZCNzNFXCJcbiAgICB9KV1cbiAgfSkpO1xufTtcblxuY29uc3QgV2FsbGV0T3B0aW9ucyA9ICh7XG4gIHNlbGVjdG9yLFxuICBoYW5kbGVXYWxsZXRDbGlja1xufSkgPT4ge1xuICBjb25zdCBbbW9kdWxlcywgc2V0TW9kdWxlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtyZWNlbnRNb2R1bGVzLCBzZXRSZWNlbnRNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW21vcmVNb2R1bGVzLCBzZXRNb3JlTW9kdWxlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFthY3RpdmVXYWxsZXRJZCwgc2V0QWN0aXZlV2FsbGV0SWRdID0gdXNlU3RhdGUoXCJcIik7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Iuc3RvcmUub2JzZXJ2YWJsZS5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gc2VsZWN0b3Iuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgIHNldEFjdGl2ZVdhbGxldElkKHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FsbGV0cyA9IHN0YXRlLm1vZHVsZXMuZmlsdGVyKG1vZHVsZSA9PiAhKG1vZHVsZS50eXBlID09PSBcImluc3RhbnQtbGlua1wiICYmIHNlbGVjdGVkV2FsbGV0SWQgIT09IG1vZHVsZS5pZCkpO1xuICAgICAgaWYgKHNlbGVjdG9yLm9wdGlvbnMub3B0aW1pemVXYWxsZXRPcmRlcikge1xuICAgICAgICBzdGF0ZS5tb2R1bGVzLnNvcnQoKGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudC5tZXRhZGF0YS5kZXByZWNhdGVkID09PSBuZXh0Lm1ldGFkYXRhLmRlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3VycmVudC5tZXRhZGF0YS5kZXByZWNhdGVkID8gMSA6IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUubW9kdWxlcy5zb3J0KChjdXJyZW50LCBuZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKG5leHQubWV0YWRhdGEuYXZhaWxhYmxlID09PSBjdXJyZW50Lm1ldGFkYXRhLmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXh0Lm1ldGFkYXRhLmF2YWlsYWJsZSA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vcmVXYWxsZXRzID0gW107XG4gICAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0gW107XG4gICAgICAgIHdhbGxldHMuZm9yRWFjaChtb2R1bGUgPT4ge1xuICAgICAgICAgIGlmIChzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpLnJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLmluY2x1ZGVzKG1vZHVsZS5pZCkpIHtcbiAgICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9yZVdhbGxldHMucHVzaChtb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldFJlY2VudE1vZHVsZXMocmVjZW50bHlTaWduZWRJbldhbGxldHMpO1xuICAgICAgICBzZXRNb3JlTW9kdWxlcyhtb3JlV2FsbGV0cyk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0b3Iub3B0aW9ucy5yYW5kb21pemVXYWxsZXRPcmRlcikge1xuICAgICAgICBzZXRNb2R1bGVzKHdhbGxldHMuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNb2R1bGVzKHdhbGxldHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgZnVuY3Rpb24gcmVuZGVyT3B0aW9uc0xpc3QobW9kdWxlc1RvUmVuZGVyKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNUb1JlbmRlci5yZWR1Y2UoKHJlc3VsdCwgbW9kdWxlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gc2VsZWN0b3Iuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGljb25VcmwsXG4gICAgICAgIGRlcHJlY2F0ZWRcbiAgICAgIH0gPSBtb2R1bGUubWV0YWRhdGE7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IG1vZHVsZS5pZCA9PT0gc2VsZWN0ZWRXYWxsZXRJZDtcbiAgICAgIHJlc3VsdC5wdXNoKGpzeHMoXCJsaVwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIGNsYXNzTmFtZTogYHNpbmdsZS13YWxsZXQgJHthY3RpdmVXYWxsZXRJZCA9PT0gbW9kdWxlLmlkID8gXCJzZWxlY3RlZC13YWxsZXRcIiA6IFwiXCJ9ICR7c2VsZWN0ZWQgPyBcImNvbm5lY3RlZC13YWxsZXRcIiA6IFwiXCJ9ICR7ZGVwcmVjYXRlZCA/IFwiZGVwcmVjYXRlZC13YWxsZXRcIiA6IFwiXCJ9IHNpZGViYXIgJHttb2R1bGUuaWR9YCxcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIGlmIChtb2R1bGUuaWQgPT09IG1vZHVsZXNUb1JlbmRlcltpbmRleF0uaWQpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZVdhbGxldElkKG1vZHVsZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoYW5kbGVXYWxsZXRDbGljayhtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgc3JjOiBpY29uVXJsLFxuICAgICAgICAgICAgYWx0OiBuYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRpdGxlXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmFtZVxuICAgICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImRlc2NyaXB0aW9uXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogZGVzY3JpcHRpb25cbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKSwgZGVwcmVjYXRlZCAmJiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIndhcm5pbmctdHJpYW5nbGVcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChXYXJuaW5nSWNvbiwge30pXG4gICAgICAgIH0pKV1cbiAgICAgIH0pLCBtb2R1bGUuaWQpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG4gIHJldHVybiBqc3goXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiBzZWxlY3Rvci5vcHRpb25zLm9wdGltaXplV2FsbGV0T3JkZXIgJiYgc2VsZWN0b3Iuc3RvcmUuZ2V0U3RhdGUoKS5yZWNlbnRseVNpZ25lZEluV2FsbGV0cy5sZW5ndGggPiAwID8ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtb3B0aW9ucy13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJvcHRpb25zLWxpc3Qtc2VjdGlvblwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJvcHRpb25zLWxpc3Qtc2VjdGlvbi1oZWFkZXJcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiUmVjZW50XCJcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdCBtb3JlLW9wdGlvbnMtbGlzdC1jb250ZW50XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiByZW5kZXJPcHRpb25zTGlzdChyZWNlbnRNb2R1bGVzKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJvcHRpb25zLWxpc3Qtc2VjdGlvblwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJvcHRpb25zLWxpc3Qtc2VjdGlvbi1oZWFkZXJcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiTW9yZVwiXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJvcHRpb25zLWxpc3QgbW9yZS1vcHRpb25zLWxpc3QtY29udGVudFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogcmVuZGVyT3B0aW9uc0xpc3QobW9yZU1vZHVsZXMpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKV1cbiAgICB9KSkgOiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwid2FsbGV0LW9wdGlvbnMtd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJPcHRpb25zTGlzdChtb2R1bGVzKVxuICAgICAgfSkpXG4gICAgfSkpXG4gIH0pO1xufTtcblxuY29uc3QgQ29ubmVjdGlvbkVycm9ySWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMjFcIixcbiAgICBoZWlnaHQ6IFwiMjBcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyMSAyMFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xMC41MDAxIDE4LjMzMzNDMTUuMTAyNSAxOC4zMzMzIDE4LjgzMzQgMTQuNjAyMyAxOC44MzM0IDkuOTk5OTZDMTguODMzNCA1LjM5NzU5IDE1LjEwMjUgMS42NjY2MyAxMC41MDAxIDEuNjY2NjNDNS44OTc3MSAxLjY2NjYzIDIuMTY2NzUgNS4zOTc1OSAyLjE2Njc1IDkuOTk5OTZDMi4xNjY3NSAxNC42MDIzIDUuODk3NzEgMTguMzMzMyAxMC41MDAxIDE4LjMzMzNaXCIsXG4gICAgICBzdHJva2U6IFwiI0NFNUE2RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEzIDcuNUw4IDEyLjVcIixcbiAgICAgIHN0cm9rZTogXCIjQ0U1QTZGXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNOCA3LjVMMTMgMTIuNVwiLFxuICAgICAgc3Ryb2tlOiBcIiNDRTVBNkZcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KV1cbiAgfSkpO1xufTtcblxuY29uc3QgQ29ubmVjdGlvblN1Y2Nlc3NJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIyMVwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDIxIDIwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE4LjgzMzMgOS4yMzMzVjkuOTk5OTdDMTguODMyMyAxMS43OTcgMTguMjUwNCAxMy41NDU1IDE3LjE3NDQgMTQuOTg0OEMxNi4wOTg0IDE2LjQyNDEgMTQuNTg2IDE3LjQ3NyAxMi44NjI4IDE3Ljk4NjZDMTEuMTM5NSAxOC40OTYxIDkuMjk3NjggMTguNDM0OSA3LjYxMjAyIDE3LjgxMjFDNS45MjYzNiAxNy4xODk0IDQuNDg3MTcgMTYuMDM4NCAzLjUwOTA5IDE0LjUzMDlDMi41MzEwMSAxMy4wMjMzIDIuMDY2NDUgMTEuMjQgMi4xODQ2OSA5LjQ0NjlDMi4zMDI5MyA3LjY1Mzc3IDIuOTk3NjMgNS45NDY5MSA0LjE2NTE5IDQuNTgwODZDNS4zMzI3NSAzLjIxNDgyIDYuOTEwNjEgMi4yNjI3OSA4LjY2MzQ1IDEuODY2NzZDMTAuNDE2MyAxLjQ3MDczIDEyLjI1MDIgMS42NTE5MiAxMy44OTE2IDIuMzgzM1wiLFxuICAgICAgc3Ryb2tlOiBcIiM0RkQ5OEZcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xOC44MzMzIDMuMzMzMzdMMTAuNSAxMS42NzVMOCA5LjE3NTA0XCIsXG4gICAgICBzdHJva2U6IFwiIzRGRDk4RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBDb25uZWN0aW9uUmVzdWx0ID0gKHtcbiAgbW9kdWxlLFxuICBtZXNzYWdlLFxuICBlcnIsXG4gIG9uUmV0cnlcbn0pID0+IHtcbiAgcmV0dXJuIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IFwiY29ubmVjdGlvbiBjb25uZWN0aW5nLWRldGFpbHNcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IGVyciA/IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZXJyb3Itd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiZXJyb3JcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChDb25uZWN0aW9uRXJyb3JJY29uLCB7fSksIHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW9uRmFpbGVkXCIpXVxuICAgICAgfSkpLCBqc3goXCJwXCIsIHtcbiAgICAgICAgY2hpbGRyZW46IG1lc3NhZ2VcbiAgICAgIH0pLCAobW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLmF2YWlsYWJsZSkgJiYganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBvbkNsaWNrOiBvblJldHJ5XG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIucmV0cnlcIilcbiAgICAgIH0pKV1cbiAgICB9KSkgOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcInN1Y2Nlc3NcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4KENvbm5lY3Rpb25TdWNjZXNzSWNvbiwge30pLCB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuY29ubmVjdGlvblN1Y2Nlc3NmdWxcIildXG4gICAgfSkpXG4gIH0pKTtcbn07XG5cbmNvbnN0IEFsZXJ0TWVzc2FnZSA9ICh7XG4gIG1lc3NhZ2UsXG4gIG1vZHVsZSxcbiAgb25CYWNrLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeChNb2RhbEhlYWRlciwge1xuICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgIH0pLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiYWxlcnQtbWVzc2FnZSBjb25uZWN0aW5nLXdyYXBwZXIgY29ubmVjdGluZy13cmFwcGVyLWVyclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5pY29uVXJsLFxuICAgICAgICAgICAgYWx0OiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbmFtZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLm5hbWVcbiAgICAgICAgfSkpLCBqc3goQ29ubmVjdGlvblJlc3VsdCwge1xuICAgICAgICAgIG1vZHVsZTogbW9kdWxlLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgZXJyOiBtZXNzYWdlICE9PSBudWxsLFxuICAgICAgICAgIG9uUmV0cnk6ICgpID0+IHtcbiAgICAgICAgICAgIG9uQmFjayh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXVxuICAgICAgfSkpXG4gICAgfSkpXVxuICB9KTtcbn07XG5cbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG5cbnZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkNSgnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQzKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFUyQyXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTJDIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMSA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDIoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ0KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDIgPSBmYWlscyRoO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbDtcbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDU7XG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDIoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyQyKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ0KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ0KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YkMShhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UkMShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDEgPSAhY29uc3RydWN0IHx8IGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgaXNDb25zdHJ1Y3RvciA9IGlzQ29uc3RydWN0b3IkMTtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQzKHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRjO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkNCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkNihPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdCQ2KEMpW1NQRUNJRVMkMV0pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvcihTKTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkkMSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwkOCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXJlZmxlY3QgLS0gc2FmZVxudmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQxID8gY2FsbCQ4LmJpbmQoYXBwbHkkMSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJDguYXBwbHkoYXBwbHkkMSwgYXJndW1lbnRzKTtcbn0pO1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDUgPSBhQ2FsbGFibGUkOTtcbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGJpbmQkNCA9IHVuY3VycnlUaGlzJDEodW5jdXJyeVRoaXMkMS5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUkNShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZCQ0KGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgYXJyYXlTbGljZSQxID0gdW5jdXJyeVRoaXMoW10uc2xpY2UpO1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMSA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgJFR5cGVFcnJvciQyKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJb3MgPSAvKD86aXBhZHxpcGhvbmV8aXBvZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkNyA9IGdsb2JhbCRrO1xudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDMgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkbDtcbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZmFpbHMkMSA9IGZhaWxzJGg7XG52YXIgaHRtbCA9IGh0bWwkMjtcbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZSQxO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDE7XG52YXIgSVNfSU9TJDEgPSBlbmdpbmVJc0lvcztcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBzZXQgPSBnbG9iYWwkNy5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkNy5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkNy5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJDcuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCQ3LkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJDcuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkNy5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJDcubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQxKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJDcucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoaGFuZGxlcikge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkMyhoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgIHZhciBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHF1ZXVlJDFbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5KGZuLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSQyKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MkMi5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgLy8gZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82MjRcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TJDEpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQkMyhwb3J0LnBvc3RNZXNzYWdlLCBwb3J0KTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsJDcuYWRkRXZlbnRMaXN0ZW5lciAmJlxuICAgIGlzQ2FsbGFibGUkMyhnbG9iYWwkNy5wb3N0TWVzc2FnZSkgJiZcbiAgICAhZ2xvYmFsJDcuaW1wb3J0U2NyaXB0cyAmJlxuICAgIGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgIWZhaWxzJDEocG9zdClcbiAgKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbCQ3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkaztcblxudmFyIGVuZ2luZUlzSW9zUGViYmxlID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCQxKSAmJiBnbG9iYWwkNi5QZWJibGUgIT09IHVuZGVmaW5lZDtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzV2Vib3NXZWJraXQgPSAvd2ViMHMoPyEuKmNocm9tZSkvaS50ZXN0KHVzZXJBZ2VudCk7XG5cbnZhciBnbG9iYWwkNSA9IGdsb2JhbCRrO1xudmFyIGJpbmQkMiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgbWFjcm90YXNrID0gdGFzayQxLnNldDtcbnZhciBJU19JT1MgPSBlbmdpbmVJc0lvcztcbnZhciBJU19JT1NfUEVCQkxFID0gZW5naW5lSXNJb3NQZWJibGU7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gZW5naW5lSXNXZWJvc1dlYmtpdDtcbnZhciBJU19OT0RFJDEgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsJDUuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwkNS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGRvY3VtZW50JDIgPSBnbG9iYWwkNS5kb2N1bWVudDtcbnZhciBwcm9jZXNzJDEgPSBnbG9iYWwkNS5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IGdsb2JhbCQ1LlByb21pc2U7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCQ1LCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5JDEsIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUkMSAmJiAocGFyZW50ID0gcHJvY2VzcyQxLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSQxKCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUkMSAmJiAhSVNfV0VCT1NfV0VCS0lUICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgZG9jdW1lbnQkMikge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50JDIuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmICghSVNfSU9TX1BFQkJMRSAmJiBQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIC8vIHdvcmthcm91bmQgb2YgV2ViS2l0IH4gaU9TIFNhZmFyaSAxMC4xIGJ1Z1xuICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlJDE7XG4gICAgdGhlbiA9IGJpbmQkMihwcm9taXNlLnRoZW4sIHByb21pc2UpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSQxKSB7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmJpbmQoZ2xvYmFsKVxuICAgIG1hY3JvdGFzayA9IGJpbmQkMihtYWNyb3Rhc2ssIGdsb2JhbCQ1KTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hY3JvdGFzayhmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWljcm90YXNrJDEgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkkMSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcblxudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJGs7XG5cbnZhciBob3N0UmVwb3J0RXJyb3JzJDEgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbCQ0LmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcblxudmFyIHBlcmZvcm0kMyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuXG52YXIgUXVldWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbn07XG5cblF1ZXVlJDEucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGVudHJ5ID0geyBpdGVtOiBpdGVtLCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMuaGVhZCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXh0O1xuICAgICAgaWYgKHRoaXMudGFpbCA9PT0gZW50cnkpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICByZXR1cm4gZW50cnkuaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSA9IFF1ZXVlJDE7XG5cbnZhciBnbG9iYWwkMyA9IGdsb2JhbCRrO1xuXG52YXIgcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJDMuUHJvbWlzZTtcblxudmFyIGVuZ2luZUlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIERlbm8gIT0gJ29iamVjdCc7XG5cbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRrO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkbDtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIElTX0JST1dTRVIgPSBlbmdpbmVJc0Jyb3dzZXI7XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcblxuTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMucHJvdG90eXBlO1xudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2wkMygnc3BlY2llcycpO1xudmFyIFNVQkNMQVNTSU5HID0gZmFsc2U7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEgPSBpc0NhbGxhYmxlJDIoZ2xvYmFsJDIuUHJvbWlzZVJlamVjdGlvbkV2ZW50KTtcblxudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUgPSBpc0ZvcmNlZCgnUHJvbWlzZScsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFID0gaW5zcGVjdFNvdXJjZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIC8vIFY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gIC8vIFdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gIGlmICghR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBWOF9WRVJTSU9OID09PSA2NikgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBuZXcgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSgxKTsgfSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiAgU1VCQ0xBU1NJTkcgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICBpZiAoIVNVQkNMQVNTSU5HKSByZXR1cm4gdHJ1ZTtcbiAgLy8gVW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICByZXR1cm4gIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgSVNfQlJPV1NFUiAmJiAhTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDE7XG59KTtcblxudmFyIHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHtcbiAgQ09OU1RSVUNUT1I6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUsXG4gIFJFSkVDVElPTl9FVkVOVDogTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEsXG4gIFNVQkNMQVNTSU5HOiBTVUJDTEFTU0lOR1xufTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDIgPSB7fTtcblxudmFyIGFDYWxsYWJsZSQ0ID0gYUNhbGxhYmxlJDk7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUkNChyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhQ2FsbGFibGUkNChyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm5ld1Byb21pc2VDYXBhYmlsaXR5JDIuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgJCQ1ID0gX2V4cG9ydDtcbnZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xudmFyIGdsb2JhbCQxID0gZ2xvYmFsJGs7XG52YXIgY2FsbCQ3ID0gZnVuY3Rpb25DYWxsO1xudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciBzZXRQcm90b3R5cGVPZiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckMztcbnZhciBzZXRTcGVjaWVzID0gc2V0U3BlY2llcyQxO1xudmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDk7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRsO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCQ4O1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDE7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDE7XG52YXIgdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgbWljcm90YXNrID0gbWljcm90YXNrJDE7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IGhvc3RSZXBvcnRFcnJvcnMkMTtcbnZhciBwZXJmb3JtJDIgPSBwZXJmb3JtJDM7XG52YXIgUXVldWUgPSBxdWV1ZTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlJFSkVDVElPTl9FVkVOVDtcbnZhciBOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5TVUJDTEFTU0lORztcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFBST01JU0UpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMi5wcm90b3R5cGU7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDI7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMTtcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQxLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJDEuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCQxLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCQxICYmIGRvY3VtZW50JDEuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsJDEuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0JDEoaXQpICYmIGlzQ2FsbGFibGUkMSh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgY2FsbFJlYWN0aW9uID0gZnVuY3Rpb24gKHJlYWN0aW9uLCBzdGF0ZSkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChUeXBlRXJyb3IkMSgnUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsJDcodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbCQxLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsJDFbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCQ3KHRhc2ssIGdsb2JhbCQxLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0kMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJDcodGFzaywgZ2xvYmFsJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCQxID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvciQxKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgICBpZiAodGhlbikge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbCQ3KHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZCQxKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZCQxKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgYUNhbGxhYmxlJDMoZXhlY3V0b3IpO1xuICAgIGNhbGwkNyhJbnRlcm5hbCwgdGhpcyk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGJpbmQkMShpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZCQxKGludGVybmFsUmVqZWN0LCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdChzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBQcm9taXNlUHJvdG90eXBlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgIHR5cGU6IFBST01JU0UsXG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgICAgIHBhcmVudDogZmFsc2UsXG4gICAgICByZWFjdGlvbnM6IG5ldyBRdWV1ZSgpLFxuICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgICAgIHN0YXRlOiBQRU5ESU5HLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gIEludGVybmFsLnByb3RvdHlwZSA9IGRlZmluZUJ1aWx0SW4kMihQcm9taXNlUHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQxKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQxKG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBQRU5ESU5HKSBzdGF0ZS5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICBlbHNlIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQkMShpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQkMShpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuICB9O1xuXG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQxKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLnRoZW47XG5cbiAgICBpZiAoIU5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HKSB7XG4gICAgICAvLyBtYWtlIGBQcm9taXNlI3RoZW5gIHJldHVybiBhIHBvbHlmaWxsZWQgYFByb21pc2VgIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgICBkZWZpbmVCdWlsdEluJDIoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY2FsbCQ3KG5hdGl2ZVRoZW4sIHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY0MFxuICAgICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBgLmNvbnN0cnVjdG9yID09PSBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEuY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgLy8gbWFrZSBgaW5zdGFuY2VvZiBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBzZXRQcm90b3R5cGVPZihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJDUoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIEl0ZXJhdG9ycyQxID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCQyKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycyQxLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUiQyXSA9PT0gaXQpO1xufTtcblxudmFyIGNsYXNzb2YgPSBjbGFzc29mJDU7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkMztcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgnaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZCQxKGl0LCBJVEVSQVRPUiQxKVxuICAgIHx8IGdldE1ldGhvZCQxKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkOTtcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQxKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ1KGNhbGwkNihpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGM7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG5cbnZhciBpdGVyYXRvckNsb3NlJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkNChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ1KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkNChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGM7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkNTtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDModmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJDQobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbnZhciBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiA9IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEuYWxsKGl0ZXJhYmxlKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkOTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtJDEgPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UuYWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiQkNCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0kMShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDEoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZSQxKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBjYWxsJDMoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkbDtcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDY7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJDMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQxKE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ5O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJDIoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkMigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkMSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkMShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRjO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkODtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSQxID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QkMihDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG5cbmNvbnN0IEhhcmR3YXJlV2FsbGV0QWNjb3VudHNGb3JtID0gKHtcbiAgYWNjb3VudHMsXG4gIG9uU2VsZWN0ZWRDaGFuZ2VkLFxuICBvblN1Ym1pdCxcbiAgb25DaGFuZ2VSb3V0ZVxufSkgPT4ge1xuICByZXR1cm4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IFwiY2hvb3NlLWxlZGdlci1hY2NvdW50LWZvcm0td3JhcHBlclwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJwXCIsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJXZSBmb3VuZCBcIiwgYWNjb3VudHMubGVuZ3RoLCBcIiBhY2NvdW50cyBvbiB5b3VyIGRldmljZS4gU2VsZWN0IHRoZSBhY2NvdW50KHMpIHlvdSB3aXNoIHRvIGNvbm5lY3QuXCJdXG4gICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJidXR0b24td3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlUm91dGUoXCJTcGVjaWZ5SERQYXRoXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkhELi4uLzBcIlxuICAgICAgfSkpXG4gICAgfSkpLCBqc3goXCJmb3JtXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImZvcm1cIixcbiAgICAgIG9uU3VibWl0OiBlID0+IHtcbiAgICAgICAgb25TdWJtaXQoYWNjb3VudHMsIGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm53cy1mb3JtLWNvbnRyb2xcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGFjY291bnRzLm1hcCgoYWNjb3VudCwgaW5kZXgpID0+IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiYWNjb3VudFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiBlID0+IHtcbiAgICAgICAgICAgICAgICBvblNlbGVjdGVkQ2hhbmdlZChpbmRleCwgZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoZWNrZWQ6IGFjY291bnQuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgaWQ6IGFjY291bnQuYWNjb3VudElkLFxuICAgICAgICAgICAgICBuYW1lOiBhY2NvdW50LmFjY291bnRJZCxcbiAgICAgICAgICAgICAgdmFsdWU6IGFjY291bnQuYWNjb3VudElkXG4gICAgICAgICAgICB9KSwganN4cyhcImxhYmVsXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBodG1sRm9yOiBhY2NvdW50LmFjY291bnRJZFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW1wiIFwiLCBhY2NvdW50LmFjY291bnRJZF1cbiAgICAgICAgICAgIH0pKSwganN4KFwiYnJcIiwge30pXVxuICAgICAgICAgIH0pLCBpbmRleCkpXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgICAgICAgIGRpc2FibGVkOiAhYWNjb3VudHMuc29tZSh4ID0+IHguc2VsZWN0ZWQpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29ubmVjdFwiXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pXG4gICAgfSkpXVxuICB9KSk7XG59O1xuXG52YXIgaW1nID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpDQVlBQUFERTZZVmpBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBUjNTVVJCVkhnQnBWWjlhSlZWR0grZTU1ejMzYmk3elk5aE16K3lNQWVOb0VJcTZBOVpSS1FXRXNRTkZJSXBzZjVZOUUrR3NEOWlCRUVETVVrRGE2U2hSS0taWUlXaVJrYUthVUdVR0NLT1RHTUY4NFBOTzk5Nzczdk9lZnE5NzIweUs1WnpEL2R3UHQvbmQzN1AxN2xFazVRbnV6OXJvVWtLVDdUNWJOZStRalROTENIdjI0aDFYZ2grT210d1FZUEgyalVYd2xuVzlOUm9vcWVQZkxTNk1tbVE1OWNkZUVHSmxrSlpBNU1HVmVjb0F3Z2hCWVpUVlk5ZnR1YURTeTh4OHc5ZmJGbDk1SlpBWHV3OWRtZWxrdlJBeVh4Uzd3TUZyeUc0Ykl5V1ppcXpQZ01oYUZmR2ZuM05ZM0FaRzlzUGYvRHk4SGlkWnZ4a1pjL2gxcHFuUGxLZXk2eXNwTXFVZDlqVkFFWVk2UkNHRFFUd2pHRHdHVGdBbGJ3UmlqVjFDOXZhbno1Nzd0VCs2citZck96NXJsWEZyUS9xWitGYkR4Q2ZYUzVvT2d4bG40djQ3M2YzcmJnd2RuN0ZLNS9NQ2FIMmVBZzZYOGczSzJpQk1UaUJrTkpWS2JvZCt6ZTltZ1Bac1kvVWFpY1l6Q0UxSGdwWmM1NThvbENUalR2V0x4djlwMW4zYlY0NWlPN1Q1enEzVFU5ajl4VE9Md1E1RDl0NDhhRVlydEdqMlAvMkJwTlM3OG5aSm9SZGxEc1lkOHZwaHoyNzNscXloVzVSbmxuejNoT2U2U0V3Z2h2eFBVTVRWZlllMnJwdVVPcU9rWmVJeGRTYnNTSjhlVElBbVh5NXRmdHJNUGt6aTBDNEIyWkROSHArSU52TFFVUmtoWWlKNmdER2tvMzc2RGJFSjhrM21jbllCU2VTTTJwdEwvWEdzdXJObnhmbkRJUU53Q0tBRE8xODQ1RWY2VGJrME01MWc0am9NZ25jRHlCbWtydHNORU1Rb3ZjRHhHWXNHTDJ5RE5BVXhQdjBWeVNzNHl4aGZlWWJhYkpnMEF3ZytJTHlsRUI2bktNcFNPcDBXQ1IxK1FTdUQ0RUxsak5ERWZ5UnJkWFBDVTFCVEVnRDdweU96Vm1DMmlCbTBLZ1lBTUNFZVhvdm9DbElqZEtpVmRRM0ZZYnptYXR4V1JxTVBjTnNESHlmTldza1drNVRrSmhORXdWeXhBNmhMTDVjbExKc1c3dm9GeGE2TGlSNUNDT2VXem8zWEZ4S3R5RWR5M3RucDdWYWhBb0RwNlBFVkd2SnllMDlsM1A3SzlrOVdRaWpYQnY0QjZXRyswcHZEMHliRkVCSFo2T1BoKy9PR2FCc0l2TlJBR3AvWkh2MWpKZW9uK29tc3pCa0ZzcjNGaHNMQjdyZXYzSkxRS1ZTeWZqbWFXMkJKU2F2RGxxUjdjNVZyUis0QWJMdHRia1hNZWhIN2dqQThnWmlEL3RxK09yL0FCWjNkVVcvSjYyTGNQVUdjclc4cEtTVkZBZzZjSHozTzBsMjVxWkhhL1hHd1dQZzlhQXd3emRaQWFEWCs3dGJOc01ZZjUrYnBhVVMwZERRRUY4cnRzVXhDYkk1ZTVLUnpHaEJNaXFOeGxsS2p1N2Q4Tk9ZWGpzZVJCeXRRbmdjVkRMM3dEOUgrN3ZmM1lTN21ubnpxclpwd1N4cndraDA0Y3BNNU5UTXlKZEhiSWdhRVN5eEo2dFo1Y0RidzNxZDB0cVZDcDI1U2UvNHlZZHI1L3ptL2Voand2cHhaSGdOMFdsdWIwL1l0N2F3ZHlrcVJZRkh5Nk5VUVZyQmQ0bzZwNm5nclZMMkJvOGtzdUpxb1h6cTlMbjltNnJqOVU3NGI2V2pvOE9lUDA4MmFZNU5VeFJzWXp3RGtlRnNVK01kVVUzVTRQRzBRdGJhaHFoYWRETXVIVHk0ZnZTLzlFd0lVcGRldVcvWmlTaE9pcEZ4VVJSYk5kV0VURk1SWnJDRmxFWkdrdVBIZHljVGFmZ0xFeE5pSTZZZlVwY0FBQUFBU1VWT1JLNUNZSUk9XCI7XG5cbmNvbnN0IFdhbGxldENvbm5lY3RpbmcgPSAoe1xuICB3YWxsZXQsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICB0aXRsZTogXCJcIixcbiAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiY29udGVudFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgc3JjOiB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubWV0YWRhdGEuaWNvblVybCxcbiAgICAgICAgICAgIGFsdDogd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0Lm1ldGFkYXRhLm5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KSksIGpzeChcImgzXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLW5hbWVcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5tZXRhZGF0YS5uYW1lXG4gICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiY29ubmVjdGluZy1kZXRhaWxzXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNwaW5uZXJcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgICBzcmM6IGltZyxcbiAgICAgICAgICAgICAgYWx0OiBcImxvYWRpbmctaWNvblwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKSwganN4cyhcInNwYW5cIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFt0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuY29ubmVjdGluZ1RvXCIpLCBcIiBcIiwgd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0Lm1ldGFkYXRhLm5hbWUsIFwiLi4uXCJdXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLW1lc3NhZ2VcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShgbW9kYWwud2FsbGV0LmNvbm5lY3RpbmdNZXNzYWdlLiR7d2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LnR5cGV9YClcbiAgICAgICAgICB9KVxuICAgICAgICB9KSldXG4gICAgICB9KSlcbiAgICB9KSldXG4gIH0pO1xufTtcblxuY29uc3QgTGVkZ2VyRGV2aWNlSWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMzE3XCIsXG4gICAgaGVpZ2h0OiBcIjE1N1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDMxNyAxNTdcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMjQ5Ljk5IDE2LjA5OTRDMjcwLjA2MyAtMC44NjQxNTUgMjg5Ljc4OCAxLjU4ODczIDMwMS40OTcgMTAuNzM2NUMzMDcuNDAyIDE1LjM0OTkgMzExLjI3OCAyMS42NTc1IDMxMi4yNjcgMjguMTI1OEMzMTMuMjQ3IDM0LjU0MTIgMzExLjQxMyA0MS4yMjMzIDMwNS42OTIgNDYuODA0NEMyOTcuMzY2IDU0LjkyNzMgMjg2LjM0MyA1NS4zMzYyIDI3My4wMTUgNTEuNTEwOUMyNjEuNjU0IDQ4LjI1IDI0OS4wNTggNDIuMDM3NyAyMzUuNzI2IDM1LjQ2MjdMMjM1LjcyNiAzNS40NjI2TDIzNS43MTcgMzUuNDU4QzIzMy4zNjcgMzQuMjk5MiAyMzAuOTk1IDMzLjEyOSAyMjguNjAyIDMxLjk2MThDMjEyLjc0MiAyNC4yMjUzIDE5Ni4wNjcgMTYuNjU3NSAxNzkuODQyIDEzLjg1OTVDMTYzLjUzOCAxMS4wNDc5IDE0Ny41NTIgMTMuMDMxMyAxMzMuMjY2IDI0LjUyMkMxMjguMDMyIDI4LjczMiAxMjMuNDc4IDM1LjIwODYgMTIxLjcxNiA0NC44MjA1QzExOS45NjEgNTQuMzk0NyAxMjAuOTkyIDY2Ljk3NzEgMTI2LjcwMyA4My40MzExQzEzNS40MzIgMTA4LjU4MyAxMzIuODk5IDEyNi42NzcgMTIzLjU3NSAxMzguMDYzQzExNC4yMTcgMTQ5LjQ5MSA5Ny41NjE0IDE1NC43MzMgNzYuNzg4NyAxNTMuMTIxQzU1LjAwNDMgMTUxLjQzIDI5LjA2MjEgMTQyLjIwNiAzLjI5ODY3IDEyNS4yMjdMMC44ODc4MTcgMTI3Ljk0MkMyNy4yNDcyIDE0NS40MDUgNTMuOTI1MSAxNTQuOTUyIDc2LjUxMDUgMTU2LjcwNUM5Ny45MDI4IDE1OC4zNjUgMTE1Ljk2IDE1My4wMzUgMTI2LjM1NiAxNDAuMzQxQzEzNi43ODUgMTI3LjYwNiAxMzkuMDQ1IDEwOC4wMjkgMTMwLjA5OSA4Mi4yNTI0QzEyNC41MjEgNjYuMTgwMSAxMjMuNjQyIDU0LjI0OTMgMTI1LjI1MiA0NS40Njg3QzEyNi44NTQgMzYuNzI1OCAxMzAuOTQgMzEuMDA2IDEzNS41MTkgMjcuMzIzMkMxNDguNzk0IDE2LjY0NTggMTYzLjY0OSAxNC43MTUgMTc5LjIzMSAxNy40MDIxQzE5NC44OTEgMjAuMTAyNyAyMTEuMTQ2IDI3LjQ0NjMgMjI3LjAyNiAzNS4xOTI4QzIyOS4zODEgMzYuMzQxNSAyMzEuNzI5IDM3LjUwMDEgMjM0LjA2NiAzOC42NTMxTDIzNC4wNzMgMzguNjU2OEMyNDcuMzgyIDQ1LjIyMyAyNjAuMzI0IDUxLjYwOCAyNzIuMDI0IDU0Ljk2NjJDMjg1LjgxOSA1OC45MjU4IDI5OC40OTMgNTguODUwMSAzMDguMjAyIDQ5LjM3NzZDMzE0Ljc2NCA0Mi45NzU5IDMxNi45NzQgMzUuMTI4OCAzMTUuODIgMjcuNTgyNkMzMTQuNjc1IDIwLjA4OTMgMzEwLjIzNyAxMy4wMDI5IDMwMy43MSA3LjkwMzYzQzI5MC41NTUgLTIuMzczODIgMjY4LjkzOCAtNC42MjAzOCAyNDcuNjcgMTMuMzUzN0wyNDkuOTkgMTYuMDk5NFpcIixcbiAgICAgIGZpbGw6IFwidXJsKCNwYWludDBfbGluZWFyXzNfNjcyKVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMjYwLjI2NCAxNy44NzY3TDE3Ny42MDUgODkuNDY0OUwxNTcuNjc5IDczLjk2NjRMMjM5LjIzIDMuODU0MjNMMjYwLjI2NCAxNy44NzY3WlwiLFxuICAgICAgZmlsbDogXCIjNkE3MDc1XCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yMDUuOTM5IDU0LjQ1NzdMMTk5Ljc2NCA1MC4yNjM2TDIzMy4zMTYgMjAuOTA1M0wyMzkuOTA3IDI1LjgzOTVMMjA1LjkzOSA1NC40NTc3WlwiLFxuICAgICAgZmlsbDogXCIjNDk0RTUyXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yNjAuMjY0IDE3Ljg3NTdMMTc3LjYwNSA4OS40NjM5TDE4Mi4wMzMgOTguMzIwMkwyNjQuMzIzIDI2LjM2M0wyNjAuMjY0IDE3Ljg3NTdaXCIsXG4gICAgICBmaWxsOiBcIiM0OTRFNTJcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE3Ny4yMzYgODkuNDY0NkwxODEuMjk1IDk4LjMyMDlMMTY1LjA1OSA4NS43NzQ1TDE3MC45NjMgODUuMDM2NUwxNzcuMjM2IDg5LjQ2NDZaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk05My40NzA4IDk5LjYzODRMOTEuOTk0OCAxMTAuMTNMMTc0LjY1MyA5Mi44OTRMMTY0LjY5IDg1Ljc3NDlMOTMuNDcwOCA5OS42Mzg0WlwiLFxuICAgICAgZmlsbDogXCIjRENEQURBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk05My4xMTU3IDEwNC4zMjNMOTQuMzE0IDEwMC4xMjlMMTY1LjYxMyA4Ni4zNDgzTDE2OS4yMDggODkuMzQ0TDkzLjExNTcgMTA0LjMyM1pcIixcbiAgICAgIGZpbGw6IFwiI0MxQzFDMVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNOTQuMjA4NiA5OS43OTYzTDg2LjA5MDMgMTAxLjI3Mkw5Mi4zNjM1IDExMC4xMjlMOTQuMjA4NiA5OS43OTYzWlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk04Ni4wOTAzIDEwMC45MDdMODkuMDAyNyA3NC4xMzA0TDE3OC40NTUgNTUuMjQxNkMxODQuNjk1IDUzLjk5NjIgMTk1Ljc2NiA1NC43Njc1IDE5Ny4xNzcgNjMuNzA1OEMxOTguMjg0IDcwLjcxNyAxOTUuNTA2IDczLjk5NDMgMTkxLjYyOCA3Ny4zNTkyQzE4OC40OTUgODAuMDY3MSAxODAuMTUyIDgyLjQ2NDYgMTc4LjM0MyA4Mi44OTQ0QzE3OC4yOTMgODIuOTA2NCAxNzguMjQxIDgyLjkxODggMTc4LjE4NiA4Mi45MzE5QzE3Ny4zOCA4My4xMjQ1IDE3Ni4wMDcgODMuNDUyNSAxNzAuNjQ0IDg0LjUwODhDMTY5LjA4NSA4NC44MTU4IDE2Ny4zODIgODUuMTUwMSAxNjUuNTU3IDg1LjUwNzhMMTY0LjkzMyA4NS42M0MxNDYuMzEyIDg5LjI3NjQgMTE1LjUyOCA5NS4yMjk3IDkzLjk4NDQgOTkuMzg0OUM5MS4xODA4IDk5LjkyNTcgODguNTMzNyAxMDAuNDM2IDg2LjA5MDMgMTAwLjkwN1pNMTg1LjA3NiA3NS41NTRDMTkwLjc0OCA3My4zNTM1IDE5My45OSA2OC4wNzQ1IDE5Mi4zMTggNjMuNzYzMUMxOTAuNjQ1IDU5LjQ1MTcgMTg0LjY5MSA1Ny43NDA1IDE3OS4wMTkgNTkuOTQxQzE3My4zNDcgNjIuMTQxNiAxNzAuMTA1IDY3LjQyMDYgMTcxLjc3OCA3MS43MzJDMTczLjQ1IDc2LjA0MzQgMTc5LjQwNCA3Ny43NTQ2IDE4NS4wNzYgNzUuNTU0WlwiLFxuICAgICAgZmlsbDogXCIjRjRGMUU4XCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xOTkuNzY0IDUwLjM5OTRMMTk2Ljc2OCA0OC4zMDQzTDIzMi4xOTQgMTguMDQ1NEwyMzMuMzE2IDIxLjY0MDNMMTk5Ljc2NCA1MC4zOTk0WlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMjM5Ljk2OCAyNS45OTQzTDIzMi41ODggMjAuNDU5MlYxNy41MDcxTDI0MS44MTMgMjQuNTE4M0wyMzkuOTY4IDI1Ljk5NDNaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwiZWxsaXBzZVwiLCB7XG4gICAgICBjeDogXCIxODIuMDg0XCIsXG4gICAgICBjeTogXCI2OC4wODExXCIsXG4gICAgICByeDogXCIxMC4yNDJcIixcbiAgICAgIHJ5OiBcIjcuNDY3NzJcIixcbiAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoLTIzLjc5NDkgMTgyLjA4NCA2OC4wODExKVwiLFxuICAgICAgZmlsbDogXCIjNDk0RTUyXCJcbiAgICB9KSwganN4KFwiZWxsaXBzZVwiLCB7XG4gICAgICBjeDogXCIxODIuMDg0XCIsXG4gICAgICBjeTogXCI2OC4wODE2XCIsXG4gICAgICByeDogXCI2LjY4NDYyXCIsXG4gICAgICByeTogXCI0Ljg3Mzk0XCIsXG4gICAgICB0cmFuc2Zvcm06IFwicm90YXRlKC0yMy43OTQ5IDE4Mi4wODQgNjguMDgxNilcIixcbiAgICAgIGZpbGw6IFwiIzQ5NEU1MlwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMjM4LjcyNSAyLjkzMDk0TDI2MC4zNjggMTcuMjU2NEwyNjQuODY1IDI2LjQ1NTZMMTgxLjYxNSA5OS4wMzQxTDE3NS4xNiA5NC4zMTFMOTIuMDAyOCAxMTAuOTQ3TDg1LjMyNjcgMTAxLjM5OUw4OC4zMjY5IDczLjgxNTdMMTc4LjExOCA1NC44NTUzTDIzOC43MjUgMi45MzA5NFpNMTc4LjU5OSA1Ni4yNjIyTDg5LjY3ODYgNzUuMDM4OEw4Ni45MzIxIDEwMC4yOUM4OS4wOTc5IDk5Ljg3MjUgOTEuNDEyNCA5OS40MjYzIDkzLjg0NDYgOTguOTU3MkMxMTUuMzg4IDk0LjgwMTkgMTQ2LjE3MSA4OC44NDg4IDE2NC43OTEgODUuMjAyNkwxNjUuNDE1IDg1LjA4MDRDMTY3LjI0IDg0LjcyMjggMTY4Ljk0MyA4NC4zODg1IDE3MC41MDEgODQuMDgxNkMxNzUuODUzIDgzLjAyNzUgMTc3LjIxOSA4Mi43MDEgMTc4LjAxNSA4Mi41MTA3QzE3OC4wNyA4Mi40OTc2IDE3OC4xMjIgODIuNDg1MiAxNzguMTczIDgyLjQ3MzJDMTc5LjA0OCA4Mi4yNjUyIDE4MS41NTggODEuNTY2OSAxODQuMjM1IDgwLjU4NTFDMTg2Ljc0MiA3OS42NjU1IDE4OS4yODYgNzguNTM1NCAxOTAuODAyIDc3LjM3NThMMTkxLjE1MSA3Ny4wOTIyTDE5MS42NDQgNzYuNjU5NUMxOTMuMzQxIDc1LjE0NyAxOTQuNzIzIDczLjY3MzkgMTk1LjYxIDcxLjg3MUMxOTYuNTcxIDY5LjkxNiAxOTYuOTgyIDY3LjUwMjkgMTk2LjQ0OCA2NC4xMTc4QzE5NS44IDYwLjAxMzEgMTkyLjk1OSA1Ny43NTc0IDE4OS40MDggNTYuNjU2NkMxODUuODMzIDU1LjU0ODMgMTgxLjYzNyA1NS42NTY2IDE3OC42MDMgNTYuMjYxNUMxNzguNjAxIDU2LjI2MTcgMTc4LjYgNTYuMjYyIDE3OC41OTkgNTYuMjYyMlpNMTkyLjYzMSA3Ny43NTY1TDI1OS41NTUgMTguOTUzMUwyNjMuMDQyIDI2LjA4NjlMMTgxLjgwOCA5Ni45MDc4TDE3OC4xMzIgODkuNTcxM0wxOTEuNzI0IDc4LjUyOUMxOTEuODU5IDc4LjQyNDkgMTkxLjk4OCA3OC4zMiAxOTIuMTEgNzguMjE0NEwxOTIuMTExIDc4LjIxMzZDMTkyLjI4NiA3OC4wNjE3IDE5Mi40NiA3Ny45MDk0IDE5Mi42MzEgNzcuNzU2NVpNMTg1LjQ5MSA4MS42OTA4QzE4NS4yNCA4MS43ODY4IDE4NC45OSA4MS44ODAyIDE4NC43NDMgODEuOTcwOUMxODIuMDEzIDgyLjk3MjMgMTc5LjQ0NyA4My42ODc1IDE3OC41MTQgODMuOTA5M0MxNzguNDYzIDgzLjkyMTMgMTc4LjQxMSA4My45MzM4IDE3OC4zNTYgODMuOTQ2OEMxNzcuNjM1IDg0LjExOTIgMTc2LjQ3MiA4NC4zOTcxIDE3Mi40OTEgODUuMTkxOUwxNzcuMTcyIDg4LjQ0OTJMMTg1LjQ5MSA4MS42OTA4Wk0xNzYuNjMxIDg5Ljg3MDdMMTcwLjQ3OSA4NS41OTAzQzE2OS4zMDYgODUuODIxMyAxNjguMDU0IDg2LjA2NzMgMTY2LjczMSA4Ni4zMjY1TDE3NS43NjkgOTIuOTI3NkwxNzkuNTQ4IDk1LjY5MjRMMTc2LjYzMSA4OS44NzA3Wk0xNjQuNzU4IDg2LjcxMzJDMTQ2LjI1MiA5MC4zMzYyIDExNi4wMjcgOTYuMTgxNyA5NC42MzI0IDEwMC4zMDhMOTMuMjI1OCAxMDkuMTk3TDE3My41NDMgOTMuMTI5M0wxNjQuNzU4IDg2LjcxMzJaTTkxLjg4OCAxMDguMjA3TDkzLjA5MDkgMTAwLjYwNkM5MS4wODQ4IDEwMC45OTMgODkuMTY0MiAxMDEuMzYzIDg3LjM0NzEgMTAxLjcxM0w5MS44ODggMTA4LjIwN1pNMjU4LjU4MSAxNy44NDM2TDE5Ny4zMDYgNzEuNjg0MUMxOTguMTQyIDY5LjU3NzkgMTk4LjQxIDY3LjA3OTUgMTk3LjkwNiA2My44ODc2QzE5Ny4xNDMgNTkuMDUzOSAxOTMuNzQzIDU2LjQ1NDkgMTg5Ljg0NSA1NS4yNDY3QzE4Ni45MjEgNTQuMzQwMiAxODMuNjYyIDU0LjE5MTYgMTgwLjg2MSA1NC40NDlMMjM4Ljg0IDQuNzc2NjhMMjU4LjU4MSAxNy44NDM2Wk0yMzIuNTA1IDE2LjgyTDI0My4wODkgMjQuNTY0M0wyMDUuOTE1IDU2LjUxMDZMMTk2LjA0MiA0OC4wNjY1TDIzMi41MDUgMTYuODJaTTIzMi4xMTggMTkuMDk2TDE5OC4zMTIgNDguMDY1NEwxOTkuNzQ0IDQ5LjI5TDIzMi41ODQgMjAuOTQyNEwyMzIuMTE4IDE5LjA5NlpNMjMzLjQ1NiAyMi4xMzk2TDIwMC44NzggNTAuMjYwNEwyMDUuOTEzIDU0LjU2NjRMMjM5LjA0MSAyNi4wOTY5TDIzMy40NTYgMjIuMTM5NlpNMjQwLjE5NSAyNS4xMDU0TDI0MC43MTcgMjQuNjU3MUwyMzMuNzU5IDE5LjU2NjNMMjM0LjA2IDIwLjc1ODZMMjQwLjE5NSAyNS4xMDU0WlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTkwLjE5NCA2OS45NzQ0QzE5MS4zMiA2OC4xNDA5IDE5MS41NzYgNjYuMjI3MSAxOTAuOTQyIDY0LjU5MzdDMTkwLjMwOCA2Mi45NjAzIDE4OC44MjkgNjEuNzE5OCAxODYuNzYxIDYxLjEyNTRDMTg0LjY5MSA2MC41MzA3IDE4Mi4xMTYgNjAuNjE5NiAxNzkuNTUzIDYxLjYxMzlDMTc2Ljk5MSA2Mi42MDgxIDE3NS4wMjkgNjQuMjc5NCAxNzMuOTAyIDY2LjExNDFDMTcyLjc3NiA2Ny45NDc3IDE3Mi41MiA2OS44NjE0IDE3My4xNTQgNzEuNDk0OEMxNzMuNzg4IDczLjEyODIgMTc1LjI2NyA3NC4zNjg3IDE3Ny4zMzUgNzQuOTYzMUMxNzkuNDA1IDc1LjU1NzggMTgxLjk4IDc1LjQ2ODkgMTg0LjU0MyA3NC40NzQ2QzE4Ny4xMDUgNzMuNDgwNCAxODkuMDY3IDcxLjgwOTEgMTkwLjE5NCA2OS45NzQ0Wk0xODUuMDc3IDc1Ljg1MDhDMTkwLjc0OSA3My42NTAyIDE5My45OTEgNjguMzcxMiAxOTIuMzE4IDY0LjA1OThDMTkwLjY0NSA1OS43NDg0IDE4NC42OTEgNTguMDM3MiAxNzkuMDE5IDYwLjIzNzhDMTczLjM0NyA2Mi40MzgzIDE3MC4xMDUgNjcuNzE3MyAxNzEuNzc4IDcyLjAyODdDMTczLjQ1MSA3Ni4zNDAxIDE3OS40MDUgNzguMDUxMyAxODUuMDc3IDc1Ljg1MDhaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xODcuMzkxIDY5LjE2OUMxODguMTI3IDY3Ljk3MTMgMTg4LjI2NiA2Ni43NzIxIDE4Ny44ODEgNjUuNzgxMkMxODcuNDk3IDY0Ljc5MDMgMTg2LjU4NiA2My45OTg0IDE4NS4yMzUgNjMuNjEwMkMxODMuODgzIDYzLjIyMTYgMTgyLjE3MyA2My4yNzQxIDE4MC40NTYgNjMuOTQwNEMxNzguNzM4IDY0LjYwNjggMTc3LjQ0MSA2NS43MjA4IDE3Ni43MDUgNjYuOTE5NkMxNzUuOTY5IDY4LjExNzIgMTc1LjgzIDY5LjMxNjUgMTc2LjIxNSA3MC4zMDc0QzE3Ni41OTkgNzEuMjk4MyAxNzcuNTExIDcyLjA5MDEgMTc4Ljg2MSA3Mi40NzgzQzE4MC4yMTQgNzIuODY2OSAxODEuOTIzIDcyLjgxNDQgMTgzLjY0IDcyLjE0ODFDMTg1LjM1OCA3MS40ODE4IDE4Ni42NTUgNzAuMzY3OCAxODcuMzkxIDY5LjE2OVpNMTg0LjE3NCA3My41MjQyQzE4OC4xNTYgNzEuOTc5NSAxOTAuNDMyIDY4LjI3MzggMTg5LjI1NyA2NS4yNDczQzE4OC4wODMgNjIuMjIwOCAxODMuOTA0IDYxLjAxOTYgMTc5LjkyMiA2Mi41NjQzQzE3NS45NCA2NC4xMDkxIDE3My42NjUgNjcuODE0OCAxNzQuODM5IDcwLjg0MTJDMTc2LjAxMyA3My44Njc3IDE4MC4xOTMgNzUuMDY4OSAxODQuMTc0IDczLjUyNDJaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yNDAuNDk5IDQxLjI0NDFDMjM5Ljc0NCA0MC4zNjQ5IDIzOS44NDQgMzkuMDQgMjQwLjcyNCAzOC4yODVMMjQ5Ljc4MSAzMC41MDY3QzI1MC42NiAyOS43NTE2IDI1MS45ODUgMjkuODUyMyAyNTIuNzQgMzAuNzMxNVYzMC43MzE1QzI1My40OTUgMzEuNjEwOCAyNTMuMzk1IDMyLjkzNTYgMjUyLjUxNiAzMy42OTA3TDI0My40NTggNDEuNDY5QzI0Mi41NzkgNDIuMjI0IDI0MS4yNTQgNDIuMTIzNCAyNDAuNDk5IDQxLjI0NDFWNDEuMjQ0MVpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTI1MC43NDMgMzEuNjI2NUwyNDEuNjg1IDM5LjQwNDhDMjQxLjQyNCAzOS42Mjg3IDI0MS4zOTUgNDAuMDIxNyAyNDEuNjE5IDQwLjI4MjVDMjQxLjg0MiA0MC41NDMzIDI0Mi4yMzUgNDAuNTczMSAyNDIuNDk2IDQwLjM0OTJMMjUxLjU1NCAzMi41NzA5QzI1MS44MTUgMzIuMzQ2OSAyNTEuODQ1IDMxLjk1NCAyNTEuNjIxIDMxLjY5MzJDMjUxLjM5NyAzMS40MzI0IDI1MS4wMDQgMzEuNDAyNSAyNTAuNzQzIDMxLjYyNjVaTTI0MC43MjQgMzguMjg1QzIzOS44NDQgMzkuMDQgMjM5Ljc0NCA0MC4zNjQ5IDI0MC40OTkgNDEuMjQ0MUMyNDEuMjU0IDQyLjEyMzQgMjQyLjU3OSA0Mi4yMjQgMjQzLjQ1OCA0MS40NjlMMjUyLjUxNiAzMy42OTA3QzI1My4zOTUgMzIuOTM1NiAyNTMuNDk1IDMxLjYxMDggMjUyLjc0IDMwLjczMTVDMjUxLjk4NSAyOS44NTIzIDI1MC42NiAyOS43NTE2IDI0OS43ODEgMzAuNTA2N0wyNDAuNzI0IDM4LjI4NVpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTIwNS43NzkgNzEuNDY0N0MyMDUuMDA1IDcwLjU2NDIgMjA1LjEwOCA2OS4yMDczIDIwNi4wMDkgNjguNDMzOUwyMTQuOTg5IDYwLjcyMThDMjE1Ljg5IDU5Ljk0ODUgMjE3LjI0NyA2MC4wNTE2IDIxOC4wMiA2MC45NTIxVjYwLjk1MjFDMjE4Ljc5MyA2MS44NTI2IDIxOC42OSA2My4yMDk1IDIxNy43OSA2My45ODI5TDIwOC44MDkgNzEuNjk1QzIwNy45MDkgNzIuNDY4MyAyMDYuNTUyIDcyLjM2NTIgMjA1Ljc3OSA3MS40NjQ3VjcxLjQ2NDdaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0yMTUuOTUxIDYxLjg0MTZMMjA2Ljk3IDY5LjU1MzdDMjA2LjY4OCA2OS43OTYgMjA2LjY1NiA3MC4yMjEgMjA2Ljg5OCA3MC41MDMxQzIwNy4xNDEgNzAuNzg1MSAyMDcuNTY2IDcwLjgxNzQgMjA3Ljg0OCA3MC41NzUyTDIxNi44MjggNjIuODYzQzIxNy4xMSA2Mi42MjA4IDIxNy4xNDMgNjIuMTk1OCAyMTYuOSA2MS45MTM3QzIxNi42NTggNjEuNjMxNyAyMTYuMjMzIDYxLjU5OTQgMjE1Ljk1MSA2MS44NDE2Wk0yMDYuMDA5IDY4LjQzMzlDMjA1LjEwOCA2OS4yMDczIDIwNS4wMDUgNzAuNTY0MiAyMDUuNzc5IDcxLjQ2NDdDMjA2LjU1MiA3Mi4zNjUyIDIwNy45MDkgNzIuNDY4MyAyMDguODA5IDcxLjY5NUwyMTcuNzkgNjMuOTgyOUMyMTguNjkgNjMuMjA5NSAyMTguNzkzIDYxLjg1MjYgMjE4LjAyIDYwLjk1MjFDMjE3LjI0NyA2MC4wNTE2IDIxNS44OSA1OS45NDg1IDIxNC45ODkgNjAuNzIxOEwyMDYuMDA5IDY4LjQzMzlaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwiY2lyY2xlXCIsIHtcbiAgICAgIGN4OiBcIjE0MS4zNTZcIixcbiAgICAgIGN5OiBcIjE5LjUyNVwiLFxuICAgICAgcjogXCIxMC4xODU1XCIsXG4gICAgICBmaWxsOiBcIiNGRTg5QjRcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjEzOS4wNjJcIixcbiAgICAgIGN5OiBcIjE0LjcwOTRcIixcbiAgICAgIHJ4OiBcIjIuNDI1MTlcIixcbiAgICAgIHJ5OiBcIjEuOTQwMTVcIixcbiAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoLTM0LjU0NCAxMzkuMDYyIDE0LjcwOTQpXCIsXG4gICAgICBmaWxsOiBcIiNGREY3RkZcIlxuICAgIH0pLCBqc3goXCJjaXJjbGVcIiwge1xuICAgICAgY3g6IFwiMjUyLjQ4OVwiLFxuICAgICAgY3k6IFwiNzkuNzU3N1wiLFxuICAgICAgcjogXCI3Ljc4ODkzXCIsXG4gICAgICBmaWxsOiBcIiNFQzUyMzZcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjI1MC40MzRcIixcbiAgICAgIGN5OiBcIjc2LjM3MDFcIixcbiAgICAgIHJ4OiBcIjIuNjEyNzJcIixcbiAgICAgIHJ5OiBcIjIuMDkwMThcIixcbiAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoLTM0LjU0NCAyNTAuNDM0IDc2LjM3MDEpXCIsXG4gICAgICBmaWxsOiBcIiNFREI2OURcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTEwMC40MzYgNzkuOTI1NEMxMDAuNDYxIDc5LjY1NjcgMTAwLjczMiA3OS4zODk3IDEwMS4wNDIgNzkuMzI5TDEwNi42NTcgNzguMjI5OUMxMDcuNTg3IDc4LjA0NzggMTA4LjI4MSA3OC41NTM2IDEwOC4yMDcgNzkuMzU5NkwxMDcuNzU5IDg0LjIyNDNDMTA3LjczNCA4NC40OTMgMTA3LjQ2MyA4NC43NiAxMDcuMTUzIDg0LjgyMDdMMTAwLjQxNiA4Ni4xMzk2QzEwMC4xMDYgODYuMjAwMyA5OS44NzQyIDg2LjAzMTcgOTkuODk5IDg1Ljc2MzFMMTAwLjQzNiA3OS45MjU0WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk05NS44NTUzIDgxLjc3NzVDOTUuOTI5NCA4MC45NzE1IDk2Ljc0MzcgODAuMTcwNCA5Ny42NzM5IDc5Ljk4ODNMOTguNzk2OCA3OS43Njg1Qzk5LjEwNjkgNzkuNzA3OCA5OS4zMzgyIDc5Ljg3NjQgOTkuMzEzNSA4MC4xNDUxTDk5LjEzNDQgODIuMDkxQzk5LjEwOTYgODIuMzU5NyA5OC44MzgyIDgyLjYyNjcgOTguNTI4MiA4Mi42ODc0TDk2LjI4MjQgODMuMTI3Qzk1Ljk3MjMgODMuMTg3NyA5NS43NDEgODMuMDE5MSA5NS43NjU3IDgyLjc1MDVMOTUuODU1MyA4MS43Nzc1WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk05NS41ODY1IDg0LjY5NjVDOTUuNjExMiA4NC40Mjc4IDk1Ljg4MjYgODQuMTYwOCA5Ni4xOTI3IDg0LjEwMDFMOTguNDM4NSA4My42NjA1Qzk4Ljc0ODYgODMuNTk5OCA5OC45Nzk5IDgzLjc2ODQgOTguOTU1MiA4NC4wMzdMOTguNzc2MSA4NS45ODI5Qzk4Ljc1MTMgODYuMjUxNiA5OC40Nzk5IDg2LjUxODYgOTguMTY5OSA4Ni41NzkzTDk1LjkyNDEgODcuMDE5Qzk1LjYxNCA4Ny4wNzk3IDk1LjM4MjcgODYuOTExMSA5NS40MDc0IDg2LjY0MjRMOTUuNTg2NSA4NC42OTY1WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk05NS4yMjgyIDg4LjU4ODRDOTUuMjUyOSA4OC4zMTk3IDk1LjUyNDQgODguMDUyNyA5NS44MzQ0IDg3Ljk5Mkw5OC4wODAyIDg3LjU1MjRDOTguMzkwMyA4Ny40OTE3IDk4LjYyMTYgODcuNjYwMyA5OC41OTY5IDg3LjkyOUw5OC40MTc4IDg5Ljg3NDlDOTguMzkzMSA5MC4xNDM1IDk4LjEyMTYgOTAuNDEwNSA5Ny44MTE2IDkwLjQ3MTJMOTYuNjg4NyA5MC42OTExQzk1Ljc1ODQgOTAuODczMiA5NS4wNjQ1IDkwLjM2NzQgOTUuMTM4NyA4OS41NjE0TDk1LjIyODIgODguNTg4NFpcIixcbiAgICAgIGZpbGw6IFwiI0IzQUFBQVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNOTkuNzE5NyA4Ny43MDlDOTkuNzQ0NCA4Ny40NDAzIDEwMC4wMTYgODcuMTczMyAxMDAuMzI2IDg3LjExMjZMMTAyLjU3MiA4Ni42NzNDMTAyLjg4MiA4Ni42MTIzIDEwMy4xMTMgODYuNzgwOSAxMDMuMDg4IDg3LjA0OTZMMTAyLjkwOSA4OC45OTU1QzEwMi44ODUgODkuMjY0MSAxMDIuNjEzIDg5LjUzMTIgMTAyLjMwMyA4OS41OTE5TDEwMC4wNTcgOTAuMDMxNUM5OS43NDcyIDkwLjA5MjIgOTkuNTE1OSA4OS45MjM2IDk5LjU0MDYgODkuNjU0OUw5OS43MTk3IDg3LjcwOVpcIixcbiAgICAgIGZpbGw6IFwiI0IzQUFBQVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTA0LjIxMSA4Ni44Mjk4QzEwNC4yMzYgODYuNTYxMSAxMDQuNTA3IDg2LjI5NDEgMTA0LjgxNyA4Ni4yMzM0TDEwNy4wNjMgODUuNzkzOEMxMDcuMzczIDg1LjczMzEgMTA3LjYwNSA4NS45MDE3IDEwNy41OCA4Ni4xNzA0TDEwNy40OSA4Ny4xNDMzQzEwNy40MTYgODcuOTQ5MyAxMDYuNjAyIDg4Ljc1MDQgMTA1LjY3MiA4OC45MzI1TDEwNC41NDkgODkuMTUyM0MxMDQuMjM5IDg5LjIxMyAxMDQuMDA3IDg5LjA0NDQgMTA0LjAzMiA4OC43NzU3TDEwNC4yMTEgODYuODI5OFpcIixcbiAgICAgIGZpbGw6IFwiI0IzQUFBQVwiXG4gICAgfSksIGpzeChcImRlZnNcIiwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJsaW5lYXJHcmFkaWVudFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaWQ6IFwicGFpbnQwX2xpbmVhcl8zXzY3MlwiLFxuICAgICAgICB4MTogXCItNDQuNTE5NVwiLFxuICAgICAgICB5MTogXCIxMjIuNDJcIixcbiAgICAgICAgeDI6IFwiMjYzLjM1N1wiLFxuICAgICAgICB5MjogXCItOC42NTAyM1wiLFxuICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJzdG9wXCIsIHtcbiAgICAgICAgICBvZmZzZXQ6IFwiMC4xMTA2OTdcIixcbiAgICAgICAgICBzdG9wQ29sb3I6IFwiIzIzMjMyM1wiXG4gICAgICAgIH0pLCBqc3goXCJzdG9wXCIsIHtcbiAgICAgICAgICBvZmZzZXQ6IFwiMVwiLFxuICAgICAgICAgIHN0b3BDb2xvcjogXCIjM0QzRDNEXCJcbiAgICAgICAgfSldXG4gICAgICB9KSlcbiAgICB9KV1cbiAgfSkpO1xufTtcblxuY29uc3QgVXBBcnJvd0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMTBcIixcbiAgICBoZWlnaHQ6IFwiN1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDEwIDdcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk05IDUuNDc2Mkw1IDEuNDc2MkwxIDUuNDc2MlwiLFxuICAgICAgc3Ryb2tlOiBcIiM0RjdDRDFcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pXG4gIH0pKTtcbn07XG5cbmNvbnN0IERvd25BcnJvd0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMTBcIixcbiAgICBoZWlnaHQ6IFwiN1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDEwIDdcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xIDEuNTIzODJMNSA1LjUyMzgyTDkgMS41MjM4MlwiLFxuICAgICAgc3Ryb2tlOiBcIiM0RjdDRDFcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pXG4gIH0pKTtcbn07XG5cbmNvbnN0IERFRkFVTFRfREVSSVZBVElPTl9QQVRIID0gXCI0NCcvMzk3Jy8wJy8wJy8xJ1wiO1xuY29uc3QgRGVyaXZhdGlvblBhdGggPSAoe1xuICBzZWxlY3RvcixcbiAgb3B0aW9ucyxcbiAgb25CYWNrLFxuICBvbkNvbm5lY3RlZCxcbiAgcGFyYW1zLFxuICBvbkVycm9yLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgY29uc3QgW3JvdXRlLCBzZXRSb3V0ZV0gPSB1c2VTdGF0ZShcIkVudGVyRGVyaXZhdGlvblBhdGhcIik7XG4gIGNvbnN0IFtkZXJpdmF0aW9uUGF0aCwgc2V0RGVyaXZhdGlvblBhdGhdID0gdXNlU3RhdGUoREVGQVVMVF9ERVJJVkFUSU9OX1BBVEgpO1xuICBjb25zdCBbY3VzdG9tRGVyaXZhdGlvblBhdGgsIHNldEN1c3RvbURlcml2YXRpb25QYXRoXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbYWNjb3VudHMsIHNldEFjY291bnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3NlbGVjdGVkQWNjb3VudHMsIHNldFNlbGVjdGVkQWNjb3VudHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaGFyZHdhcmVXYWxsZXQsIHNldEhhcmR3YXJlV2FsbGV0XSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IFtjdXN0b21BY2NvdW50SWQsIHNldEN1c3RvbUFjY291bnRJZF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2Nvbm5lY3RpbmcsIHNldENvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBpbml0YWxIZWFkZXJUaXRsZSA9IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5jb25uZWN0V2l0aExlZGdlclwiKTtcbiAgY29uc3QgW2hlYWRlclRpdGxlLCBzZXRIZWFkZXJUaXRsZV0gPSB1c2VTdGF0ZShpbml0YWxIZWFkZXJUaXRsZSk7XG4gIGNvbnN0IGdldEFjY291bnRJZHMgPSBwdWJsaWNLZXkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChgJHtzZWxlY3Rvci5vcHRpb25zLm5ldHdvcmsuaW5kZXhlclVybH0vcHVibGljS2V5L2VkMjU1MTk6JHtwdWJsaWNLZXl9L2FjY291bnRzYCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBhY2NvdW50IGlkIGZyb20gcHVibGljIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudElkcyA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWNjb3VudElkcykgfHwgIWFjY291bnRJZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50SWRzO1xuICB9KTtcbiAgY29uc3QgcmVzb2x2ZUFjY291bnRzID0gd2FsbGV0ID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIHdhbGxldC5nZXRQdWJsaWNLZXkoZGVyaXZhdGlvblBhdGgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY2NvdW50SWRzID0geWllbGQgZ2V0QWNjb3VudElkcyhwdWJsaWNLZXkpO1xuICAgICAgcmV0dXJuIGFjY291bnRJZHMubWFwKChhY2NvdW50SWQsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVyaXZhdGlvblBhdGgsXG4gICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICBzZWxlY3RlZDogaW5kZXggPT09IDBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVZhbGlkYXRlQWNjb3VudCA9ICgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHNlbGVjdG9yLndhbGxldChwYXJhbXMud2FsbGV0SWQpO1xuICAgIGlmICh3YWxsZXQudHlwZSAhPT0gXCJoYXJkd2FyZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldENvbm5lY3RpbmcodHJ1ZSk7XG4gICAgc2V0SGFyZHdhcmVXYWxsZXQod2FsbGV0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRBY2NvdW50cyA9IHlpZWxkIHJlc29sdmVBY2NvdW50cyh3YWxsZXQpO1xuICAgICAgaWYgKCFyZXNvbHZlZEFjY291bnRzKSB7XG4gICAgICAgIHNldFJvdXRlKFwiQWRkQ3VzdG9tQWNjb3VudElkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub0FjY291bnRzID0gcmVzb2x2ZWRBY2NvdW50cy5sZW5ndGggPT09IDA7XG4gICAgICBjb25zdCBtdWx0aXBsZUFjY291bnRzID0gcmVzb2x2ZWRBY2NvdW50cy5sZW5ndGggPiAxO1xuICAgICAgaWYgKG5vQWNjb3VudHMpIHtcbiAgICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLm5vQWNjb3VudHNGb3VuZFwiKSk7XG4gICAgICAgIHNldFJvdXRlKFwiTm9BY2NvdW50c0ZvdW5kXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRBY2NvdW50cyhyZXNvbHZlZEFjY291bnRzKTtcbiAgICAgIGlmICghbXVsdGlwbGVBY2NvdW50cykge1xuICAgICAgICBzZXRTZWxlY3RlZEFjY291bnRzKHJlc29sdmVkQWNjb3VudHMpO1xuICAgICAgICBzZXRSb3V0ZShcIk92ZXJ2aWV3QWNjb3VudHNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc2VsZWN0WW91ckFjY291bnRzXCIpKTtcbiAgICAgICAgc2V0Um91dGUoXCJDaG9vc2VBY2NvdW50XCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjtcbiAgICAgIG9uRXJyb3IobWVzc2FnZSwgd2FsbGV0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFuZGxlQWRkQ3VzdG9tQWNjb3VudElkID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNldENvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSB5aWVsZCBoYXJkd2FyZVdhbGxldC5nZXRQdWJsaWNLZXkoZGVyaXZhdGlvblBhdGgpO1xuICAgICAgY29uc3QgYWNjb3VudExpc3QgPSBbe1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgYWNjb3VudElkOiBjdXN0b21BY2NvdW50SWQsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XTtcbiAgICAgIHNldEFjY291bnRzKGFjY291bnRMaXN0KTtcbiAgICAgIHNldFNlbGVjdGVkQWNjb3VudHMoYWNjb3VudExpc3QpO1xuICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RpbmcxQWNjb3VudFwiKSk7XG4gICAgICBzZXRSb3V0ZShcIk92ZXJ2aWV3QWNjb3VudHNcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJTb21ldGhpbmcgd2VudCB3cm9uZ1wiO1xuICAgICAgb25FcnJvcihtZXNzYWdlLCBoYXJkd2FyZVdhbGxldCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldENvbm5lY3RpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVNpZ25JbiA9ICgpID0+IHtcbiAgICBjb25zdCBtYXBBY2NvdW50cyA9IHNlbGVjdGVkQWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVyaXZhdGlvblBhdGg6IGFjY291bnQuZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIHB1YmxpY0tleTogYWNjb3VudC5wdWJsaWNLZXksXG4gICAgICAgIGFjY291bnRJZDogYWNjb3VudC5hY2NvdW50SWRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhcmR3YXJlV2FsbGV0LnNpZ25Jbih7XG4gICAgICBjb250cmFjdElkOiBvcHRpb25zLmNvbnRyYWN0SWQsXG4gICAgICBtZXRob2ROYW1lczogb3B0aW9ucy5tZXRob2ROYW1lcyxcbiAgICAgIGFjY291bnRzOiBtYXBBY2NvdW50c1xuICAgIH0pLnRoZW4oKCkgPT4gb25Db25uZWN0ZWQoKSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIG9uRXJyb3IoYEVycm9yOiAke2Vyci5tZXNzYWdlfWAsIGhhcmR3YXJlV2FsbGV0KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlT25CYWNrQnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgaWYgKHJvdXRlID09PSBcIlNwZWNpZnlIRFBhdGhcIiB8fCByb3V0ZSA9PT0gXCJOb0FjY291bnRzRm91bmRcIiB8fCByb3V0ZSA9PT0gXCJDaG9vc2VBY2NvdW50XCIpIHtcbiAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5jb25uZWN0V2l0aExlZGdlclwiKSk7XG4gICAgICBzZXRSb3V0ZShcIkVudGVyRGVyaXZhdGlvblBhdGhcIik7XG4gICAgfVxuICAgIGlmIChyb3V0ZSA9PT0gXCJPdmVydmlld0FjY291bnRzXCIpIHtcbiAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zZWxlY3RZb3VyQWNjb3VudHNcIikpO1xuICAgICAgc2V0Um91dGUoXCJDaG9vc2VBY2NvdW50XCIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICByZXR1cm4ganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImRlcml2YXRpb24tcGF0aC13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4KFdhbGxldENvbm5lY3RpbmcsIHtcbiAgICAgICAgd2FsbGV0OiBoYXJkd2FyZVdhbGxldCxcbiAgICAgICAgb25CYWNrOiAoKSA9PiB7XG4gICAgICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgICB9KVxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbKHJvdXRlID09PSBcIlNwZWNpZnlIRFBhdGhcIiB8fCByb3V0ZSA9PT0gXCJOb0FjY291bnRzRm91bmRcIiB8fCByb3V0ZSA9PT0gXCJDaG9vc2VBY2NvdW50XCIgfHwgcm91dGUgPT09IFwiT3ZlcnZpZXdBY2NvdW50c1wiKSAmJiBqc3goQmFja0Fycm93LCB7XG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZU9uQmFja0J1dHRvbkNsaWNrXG4gICAgICB9KSwganN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICAgIHRpdGxlOiBoZWFkZXJUaXRsZSxcbiAgICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXVxuICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJkZXJpdmF0aW9uLXBhdGgtd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtyb3V0ZSA9PT0gXCJFbnRlckRlcml2YXRpb25QYXRoXCIgJiYganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImVudGVyLWRlcml2YXRpb24tcGF0aFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJsZWRnZXItaW1hZ2VcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChMZWRnZXJEZXZpY2VJY29uLCB7fSlcbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJsZWRnZXItZGVzY3JpcHRpb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJwXCIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIubWFrZVN1cmVZb3VyTGVkZ2VyXCIpXG4gICAgICAgICAgfSksIGpzeChcInBcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3BlY2lmeS1wYXRoXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zcGVjaWZ5SERQYXRoXCIpKTtcbiAgICAgICAgICAgICAgc2V0Um91dGUoXCJTcGVjaWZ5SERQYXRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc3BlY2lmeUhEUGF0aFwiKVxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVWYWxpZGF0ZUFjY291bnRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbnRpbnVlXCIpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwgcm91dGUgPT09IFwiU3BlY2lmeUhEUGF0aFwiICYmIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzcGVjaWZ5LXBhdGgtd3JhcHBlclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiY2hhbmdlLXBhdGgtd3JhcHBlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJkaXNwbGF5LXBhdGhcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGRlcml2YXRpb25QYXRoLnNsaWNlKDAsIC0yKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hhbmdlLXBhdGhcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwicGF0aC12YWx1ZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogY3VzdG9tRGVyaXZhdGlvblBhdGhcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJ1dHRvbnMtd3JhcHBlclwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY3VzdG9tRGVyaXZhdGlvblBhdGggKyAxO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlcml2YXRpb25QYXRoLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgICAgICAgIHNldERlcml2YXRpb25QYXRoKGAke3BhdGh9JHtuZXdWYWx1ZX0nYCk7XG4gICAgICAgICAgICAgICAgICBzZXRDdXN0b21EZXJpdmF0aW9uUGF0aChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGpzeChVcEFycm93SWNvbiwge30pXG4gICAgICAgICAgICAgIH0pKSwganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY3VzdG9tRGVyaXZhdGlvblBhdGggLSAxO1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVyaXZhdGlvblBhdGguc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgICAgc2V0RGVyaXZhdGlvblBhdGgoYCR7cGF0aH0ke25ld1ZhbHVlfSdgKTtcbiAgICAgICAgICAgICAgICAgIHNldEN1c3RvbURlcml2YXRpb25QYXRoKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjoganN4KERvd25BcnJvd0ljb24sIHt9KVxuICAgICAgICAgICAgICB9KSldXG4gICAgICAgICAgICB9KSldXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSksIGpzeChcInBcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInBhdGgtZGVzY3JpcHRpb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5lbnRlcllvdXJQcmVmZXJyZWRIRFBhdGhcIilcbiAgICAgICAgfSkpLCBqc3goXCJwXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJ3aGF0LWxpbmtcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImFcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vd3d3LmxlZGdlci5jb20vYWNhZGVteS9jcnlwdG8vd2hhdC1hcmUtaGllcmFyY2hpY2FsLWRldGVybWluaXN0aWMtaGQtd2FsbGV0c1wiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiV2hhdCdzIHRoaXM/XCJcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVWYWxpZGF0ZUFjY291bnRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLnNjYW5cIilcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSkpLCByb3V0ZSA9PT0gXCJOb0FjY291bnRzRm91bmRcIiAmJiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJuby1hY2NvdW50cy1mb3VuZC13cmFwcGVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGpzeHMoXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5jYW50RmluZEFueUFjY291bnRcIiksIFwiIFwiLCBqc3goXCJhXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaHJlZjogYGh0dHBzOi8vJHtzZWxlY3Rvci5vcHRpb25zLm5ldHdvcmsubmV0d29ya0lkID09PSBcInRlc3RuZXRcIiA/IFwidGVzdG5ldFwiIDogXCJhcHBcIn0ubXluZWFyd2FsbGV0LmNvbS9jcmVhdGVgLFxuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiTXlOZWFyV2FsbGV0XCJcbiAgICAgICAgICB9KSksIFwiIFwiLCB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIub3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyXCIpXVxuICAgICAgICB9KVxuICAgICAgfSkpLCByb3V0ZSA9PT0gXCJDaG9vc2VBY2NvdW50XCIgJiYganN4KEhhcmR3YXJlV2FsbGV0QWNjb3VudHNGb3JtLCB7XG4gICAgICAgIGFjY291bnRzOiBhY2NvdW50cyxcbiAgICAgICAgb25TZWxlY3RlZENoYW5nZWQ6IChpbmRleCwgc2VsZWN0ZWQpID0+IHtcbiAgICAgICAgICBzZXRBY2NvdW50cyhwcmV2QWNjb3VudHMgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlQWNjb3VudHMgPSBwcmV2QWNjb3VudHMubWFwKChhY2NvdW50LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IGluZGV4ID09PSBpZHggPyBzZWxlY3RlZCA6IGFjY291bnQuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbLi4udXBkYXRlQWNjb3VudHNdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblN1Ym1pdDogKGFjYywgZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZEFjYyA9IGFjYy5maWx0ZXIoYWNjb3VudCA9PiBhY2NvdW50LnNlbGVjdGVkKTtcbiAgICAgICAgICBzZXRTZWxlY3RlZEFjY291bnRzKHNlbGVjdGVkQWNjKTtcbiAgICAgICAgICBjb25zdCBudW1iZXJPZkFjY291bnRzID0gc2VsZWN0ZWRBY2MubGVuZ3RoO1xuICAgICAgICAgIHNldEhlYWRlclRpdGxlKGAke3RyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5jb25uZWN0aW5nXCIpfSAke251bWJlck9mQWNjb3VudHN9ICR7dHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLm9mQWNjb3VudHNcIil9YCk7XG4gICAgICAgICAgc2V0Um91dGUoXCJPdmVydmlld0FjY291bnRzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZVJvdXRlOiBuZXdSb3V0ZSA9PiB7XG4gICAgICAgICAgaWYgKG5ld1JvdXRlID09PSBcIlNwZWNpZnlIRFBhdGhcIikge1xuICAgICAgICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLnNwZWNpZnlIRFBhdGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRSb3V0ZShuZXdSb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCByb3V0ZSA9PT0gXCJBZGRDdXN0b21BY2NvdW50SWRcIiAmJiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiZW50ZXItY3VzdG9tLWFjY291bnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuZmFpbGVkVG9BdXRvbWF0aWNhbGx5XCIpXG4gICAgICAgIH0pLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImlucHV0LXdyYXBwZXJcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiQWNjb3VudCBJRFwiLFxuICAgICAgICAgICAgdmFsdWU6IGN1c3RvbUFjY291bnRJZCxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBlID0+IHtcbiAgICAgICAgICAgICAgc2V0Q3VzdG9tQWNjb3VudElkKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYWN0aW9uLWJ1dHRvbnNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZUFkZEN1c3RvbUFjY291bnRJZFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJsZWRnZXIuQ29udGludWVcIilcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSkpLCByb3V0ZSA9PT0gXCJPdmVydmlld0FjY291bnRzXCIgJiYganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm92ZXJ2aWV3LXdyYXBwZXJcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIub3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkXCIpXG4gICAgICAgIH0pLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjY291bnRzXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBzZWxlY3RlZEFjY291bnRzLm1hcCgoYWNjb3VudCwgaW5kZXgpID0+IGpzeChcImRpdlwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjoganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiYWNjb3VudFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogYWNjb3VudC5hY2NvdW50SWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0sIGFjY291bnQuYWNjb3VudElkKSlcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBoYW5kbGVTaWduSW4sXG4gICAgICAgICAgICBkaXNhYmxlZDogYWNjb3VudHMubGVuZ3RoID09PSAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5maW5pc2hcIilcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSkpXVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG5jb25zdCBXYWxsZXROb3RJbnN0YWxsZWQgPSAoe1xuICBtb2R1bGUsXG4gIG9uQmFjayxcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1oZWFkZXItd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goQmFja0Fycm93LCB7XG4gICAgICAgIG9uQ2xpY2s6IG9uQmFja1xuICAgICAgfSksIGpzeChNb2RhbEhlYWRlciwge1xuICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXVxuICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtbm90LWluc3RhbGxlZC13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtZGF0YVwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogYHdhbGxldC1pY29uLWJveCAke21vZHVsZS5pZH1gXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICAgIHNyYzogbW9kdWxlLm1ldGFkYXRhLmljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogbW9kdWxlLm1ldGFkYXRhLm5hbWVcbiAgICAgICAgfSldXG4gICAgICB9KSksIGpzeHMoXCJwXCIsIHtcbiAgICAgICAgY2hpbGRyZW46IFt0cmFuc2xhdGUoXCJtb2RhbC5pbnN0YWxsLnlvdWxsTmVlZFRvSW5zdGFsbFwiKSwgXCIgXCIsIG1vZHVsZS5tZXRhZGF0YS5uYW1lLCBcIiBcIiwgdHJhbnNsYXRlKFwibW9kYWwuaW5zdGFsbC50b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nXCIpLCBqc3hzKFwic3BhblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVmcmVzaC1saW5rXCIsXG4gICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiIFwiLCB0cmFuc2xhdGUoXCJtb2RhbC5pbnN0YWxsLnJlZnJlc2hUaGVQYWdlXCIpXVxuICAgICAgICB9KSldXG4gICAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiYWN0aW9uLWJ1dHRvbnNcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjoganN4cyhcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS50eXBlICE9PSBcImluamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93Lm9wZW4obW9kdWxlLm1ldGFkYXRhLmRvd25sb2FkVXJsLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLmluc3RhbGwub3BlblwiKSwgXCIgXCIsIG1vZHVsZS5tZXRhZGF0YS5uYW1lXVxuICAgICAgICB9KSlcbiAgICAgIH0pKV1cbiAgICB9KSldXG4gIH0pO1xufTtcblxuY29uc3QgUVJJY29uID0gKCkgPT4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgd2lkdGg6IFwiMThcIixcbiAgaGVpZ2h0OiBcIjE2XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE4IDE2XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCB7XG4gIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNy4yMjIyNCAxLjMzMzM0SDEuNDQ0NDZWNi42NjY2OEg3LjIyMjI0VjEuMzMzMzRaXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xNS44ODg5IDEuMzMzMzRIMTAuMTExMVY2LjY2NjY4SDE1Ljg4ODlWMS4zMzMzNFpcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTcuMjIyMjQgOS4zMzMzNEgxLjQ0NDQ2VjE0LjY2NjdINy4yMjIyNFY5LjMzMzM0WlwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTAuMTExMSAxMy4xNDI5VjE0LjY2NjdIMTUuODg4OU0xMC4xMTExIDkuMzMzMzRWMTAuODU3MkgxMi41ODczVjkuMzMzMzRIMTUuODg4OVYxMi4zODFcIixcbiAgICBzdHJva2U6IFwiIzRDNTE1NVwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJyZWN0XCIsIHtcbiAgICB4OiBcIjMuNjExMDhcIixcbiAgICB5OiBcIjMuMzMzMzRcIixcbiAgICB3aWR0aDogXCIxLjQ0NDQ0XCIsXG4gICAgaGVpZ2h0OiBcIjEuMzMzMzNcIixcbiAgICBmaWxsOiBcIiM0QzUxNTVcIlxuICB9KSwganN4KFwicmVjdFwiLCB7XG4gICAgeDogXCIzLjYxMTA4XCIsXG4gICAgeTogXCIxMS4zMzMzXCIsXG4gICAgd2lkdGg6IFwiMS40NDQ0NFwiLFxuICAgIGhlaWdodDogXCIxLjMzMzMzXCIsXG4gICAgZmlsbDogXCIjNEM1MTU1XCJcbiAgfSksIGpzeChcInJlY3RcIiwge1xuICAgIHg6IFwiMTIuMjc3OFwiLFxuICAgIHk6IFwiMy4zMzMzNFwiLFxuICAgIHdpZHRoOiBcIjEuNDQ0NDVcIixcbiAgICBoZWlnaHQ6IFwiMS4zMzMzM1wiLFxuICAgIGZpbGw6IFwiIzRDNTE1NVwiXG4gIH0pXVxufSkpO1xuXG5jb25zdCBMaW5rSWNvbiA9ICgpID0+IGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHdpZHRoOiBcIjE4XCIsXG4gIGhlaWdodDogXCIxNlwiLFxuICB2aWV3Qm94OiBcIjAgMCAxOCAxNlwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwge1xuICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEzIDguNjY2NjdWMTIuNjY2N0MxMyAxMy4wMjAzIDEyLjg0NzggMTMuMzU5NCAxMi41NzcgMTMuNjA5NUMxMi4zMDYxIDEzLjg1OTUgMTEuOTM4NyAxNCAxMS41NTU2IDE0SDMuNjExMTNDMy4yMjgwNCAxNCAyLjg2MDY0IDEzLjg1OTUgMi41ODk3NSAxMy42MDk1QzIuMzE4ODcgMTMuMzU5NCAyLjE2NjY5IDEzLjAyMDMgMi4xNjY2OSAxMi42NjY3VjUuMzMzMzNDMi4xNjY2OSA0Ljk3OTcxIDIuMzE4ODcgNC42NDA1NyAyLjU4OTc1IDQuMzkwNTJDMi44NjA2NCA0LjE0MDQ4IDMuMjI4MDQgNCAzLjYxMTEzIDRINy45NDQ0N1wiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTAuODMzMyAySDE1LjE2NjZWNlwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNy4yMjIyMyA5LjMzMzMzTDE1LjE2NjcgMlwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KV1cbn0pKTtcblxuY29uc3QgS2V5SWNvbiA9ICgpID0+IGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgd2lkdGg6IFwiNDBcIixcbiAgaGVpZ2h0OiBcIjQwXCIsXG4gIHZpZXdCb3g6IFwiMCAwIDQwIDQwXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCB7XG4gIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0zMy41IDEuODMzMjVMMzAuMTY2NiA1LjE2NjU4TTE3LjQ4MTggMTcuODUxNEMxOS4xNDA2IDE5LjUxMDMgMjAuMTY2NiAyMS44MDE5IDIwLjE2NjYgMjQuMzMzM0MyMC4xNjY2IDI5LjM5NTkgMTYuMDYyNiAzMy40OTk5IDExIDMzLjQ5OTlDNS45MzczNSAzMy40OTk5IDEuODMzMyAyOS4zOTU5IDEuODMzMyAyNC4zMzMzQzEuODMzMyAxOS4yNzA2IDUuOTM3MzUgMTUuMTY2NiAxMSAxNS4xNjY2QzEzLjUzMTMgMTUuMTY2NiAxNS44MjI5IDE2LjE5MjYgMTcuNDgxOCAxNy44NTE0Wk0xNy40ODE4IDE3Ljg1MTRMMjQuMzMzMyAxMC45OTk5TTI0LjMzMzMgMTAuOTk5OUwyOS4zMzMzIDE1Ljk5OTlMMzUuMTY2NiAxMC4xNjY2TDMwLjE2NjYgNS4xNjY1OE0yNC4zMzMzIDEwLjk5OTlMMzAuMTY2NiA1LjE2NjU4XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjNcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KVxufSkpO1xuXG5jb25zdCBGb2xkZXJJY29uID0gKCkgPT4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgd2lkdGg6IFwiNDBcIixcbiAgaGVpZ2h0OiBcIjQxXCIsXG4gIHZpZXdCb3g6IFwiMCAwIDQwIDQxXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCB7XG4gIGNoaWxkcmVuOiBbanN4KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogXCIyOC4zMzMzXCIsXG4gICAgY3k6IFwiMjMuODMzM1wiLFxuICAgIHI6IFwiMS42NjY2N1wiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTM1IDEyLjE2NjdIN0M1Ljg5NTQzIDEyLjE2NjcgNSAxMS4yNzEyIDUgMTAuMTY2N1Y3LjVDNSA2LjM5NTQzIDUuODk1NDMgNS41IDcgNS41SDMxLjY2NjdcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiM1wiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0zNSAxMi4xNjY3VjM1LjVIN0M1Ljg5NTQzIDM1LjUgNSAzNC42MDQ2IDUgMzMuNVY4LjgzMzM0XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjNcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KV1cbn0pKTtcblxuY29uc3QgV2FsbGV0SG9tZSA9ICh7XG4gIHNlbGVjdG9yLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgY29uc3QgW21vZHVsZXMsIHNldE1vZHVsZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbcm91dGUsIHNldFJvdXRlXSA9IHVzZVN0YXRlKFwiV2FsbGV0SW5mb1wiKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzZWxlY3Rvci5zdG9yZS5vYnNlcnZhYmxlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJCeVR5cGUgPSBpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSAhPT0gXCJicmlkZ2VcIiAmJiBpdGVtLnR5cGUgIT09IFwiaGFyZHdhcmVcIiAmJiBpdGVtLnR5cGUgIT09IFwiaW5zdGFudC1saW5rXCI7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlsdGVyZWRNb2R1bGVzID0gc3RhdGUubW9kdWxlcy5maWx0ZXIoZmlsdGVyQnlUeXBlKTtcbiAgICAgIHNldE1vZHVsZXMoZmlsdGVyZWRNb2R1bGVzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFdhbGxldFVybCA9IG1vZHVsZSA9PiB7XG4gICAgbGV0IHVybCA9IFwiXCI7XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSBcImluamVjdGVkXCIpIHtcbiAgICAgIHVybCA9IG1vZHVsZS5tZXRhZGF0YS5kb3dubG9hZFVybDtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSBcImJyb3dzZXJcIikge1xuICAgICAgdXJsID0gbW9kdWxlLm1ldGFkYXRhLndhbGxldFVybDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcbiAgcmV0dXJuIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgY2xhc3NOYW1lOiBcIndhbGxldC1ob21lLXdyYXBwZXJcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1oZWFkZXItd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtyb3V0ZSA9PT0gXCJHZXRXYWxsZXRzXCIgJiYganN4KEJhY2tBcnJvdywge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgc2V0Um91dGUoXCJXYWxsZXRJbmZvXCIpO1xuICAgICAgICB9XG4gICAgICB9KSwganN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICAgIHRpdGxlOiByb3V0ZSA9PT0gXCJHZXRXYWxsZXRzXCIgPyB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuZ2V0QVdhbGxldFwiKSA6IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC53aGF0SXNBV2FsbGV0XCIpLFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCByb3V0ZSA9PT0gXCJHZXRXYWxsZXRzXCIgJiYganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImdldC13YWxsZXQtd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IG1vZHVsZXMubWFwKG1vZHVsZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpY29uVXJsLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IG1vZHVsZS5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgcXJJY29uID0gW1wibmVhcmZpXCIsIFwiaGVyZS13YWxsZXRcIl0uaW5jbHVkZXMobW9kdWxlLmlkKTtcbiAgICAgICAgY29uc3QgaGVyZVdhbGxldFR5cGUgPSBtb2R1bGUuaWQgPT09IFwiaGVyZS13YWxsZXRcIiA/IFwibW9iaWxlXCIgOiBcIlwiO1xuICAgICAgICBjb25zdCB3YWxsZXRVcmwgPSBnZXRXYWxsZXRVcmwobW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgY2xhc3NOYW1lOiBgc2luZ2xlLXdhbGxldC1nZXQgJHttb2R1bGUuaWR9YCxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAod2FsbGV0VXJsKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHdhbGxldFVybCwgXCJfYmxhbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNtYWxsLWljb25cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbcXJJY29uICYmIHdhbGxldFVybCAmJiBqc3goUVJJY29uLCB7fSksICFxckljb24gJiYgd2FsbGV0VXJsICYmIGpzeChMaW5rSWNvbiwge30pXVxuICAgICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgICBzcmM6IGljb25VcmwsXG4gICAgICAgICAgICAgIGFsdDogbmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiY29udGVudFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0aXRsZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBuYW1lXG4gICAgICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInR5cGVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKGBtb2RhbC53YWxsZXRUeXBlcy4ke2hlcmVXYWxsZXRUeXBlIHx8IG1vZHVsZS50eXBlfWApXG4gICAgICAgICAgICB9KSldXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSwgbW9kdWxlLmlkKTtcbiAgICAgIH0pXG4gICAgfSkpLCByb3V0ZSA9PT0gXCJXYWxsZXRJbmZvXCIgJiYganN4cyhGcmFnbWVudCQxLCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtaW5mby13cmFwcGVyIHdoYXQtd2FsbGV0LWhpZGVcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC13aGF0XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImljb24tc2lkZVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChLZXlJY29uLCB7fSlcbiAgICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiY29udGVudC1zaWRlXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImgzXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5zZWN1cmVBbmRNYW5hZ2VcIilcbiAgICAgICAgICAgIH0pLCBqc3goXCJwXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5zYWZlbHlTdG9yZVwiKVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC13aGF0XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImljb24tc2lkZVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChGb2xkZXJJY29uLCB7fSlcbiAgICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiY29udGVudC1zaWRlXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImgzXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5sb2dJblRvQW55XCIpXG4gICAgICAgICAgICB9KSwganN4KFwicFwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQubm9OZWVkVG9DcmVhdGVcIilcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJidXR0b24tc3BhY2luZ1wiXG4gICAgICAgIH0pLCBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHNldFJvdXRlKFwiR2V0V2FsbGV0c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmdldEFXYWxsZXRcIilcbiAgICAgICAgfSkpXVxuICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwid2hhdC13YWxsZXQtbW9iaWxlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LnVzZUFXYWxsZXRcIilcbiAgICAgICAgfSksIGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgc2V0Um91dGUoXCJHZXRXYWxsZXRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuZ2V0QVdhbGxldFwiKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmctc2VsZWN0b3Itd3JhcHBlclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBqc3hzKFwic2VsZWN0XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJsYW5nLXNlbGVjdG9yXCIsXG4gICAgICAgICAgbmFtZTogXCJsYW5nXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwib3B0aW9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgdmFsdWU6IFwiZW5cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkVuZ2xpc2hcIlxuICAgICAgICAgIH0pKSwganN4KFwib3B0aW9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgdmFsdWU6IFwiZXNcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlNwYW5pc2hcIlxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpXG4gICAgICB9KSldXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IFdhbGxldENvbm5lY3RlZCA9ICh7XG4gIG1vZHVsZSxcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1oZWFkZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVUaXRsZVwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBgYFxuICAgICAgfSkpLCBqc3goQ2xvc2VCdXR0b24sIHtcbiAgICAgICAgb25DbGljazogb25DbG9zZU1vZGFsXG4gICAgICB9KV1cbiAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiY29udGVudFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiZ3JlZW4tZG90XCJcbiAgICAgICAgICB9KSwganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICAgIHNyYzogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLmljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pKSwganN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbmFtZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLm5hbWVcbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtY29ubmVjdGVkLXN1Y2Nlc3NcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goQ29ubmVjdGlvblN1Y2Nlc3NJY29uLCB7fSksIGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW9uU3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KSldXG4gICAgICB9KSlcbiAgICB9KSldXG4gIH0pO1xufTtcblxudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRjO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMSh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDEpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUkMSwgUilcbiAgICA/IGNhbGwocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRjO1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJDM7XG52YXIgZmFpbHMgPSBmYWlscyRoO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVnZXhwR2V0RmxhZ3M7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbiRUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuJFRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIG4kVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIGRlZmluZUJ1aWx0SW4oUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwYXR0ZXJuID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgZmxhZ3MgPSAkdG9TdHJpbmcoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5jb25zdCBDb3B5SWNvbiA9ICgpID0+IGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIHtcbiAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk02LjUgMTUuMjVhMS43NSAxLjc1IDAgMCAxLTEuNzUtMS43NVY2Ljc1YTIgMiAwIDAgMSAyLTJoNi43NWMuOTY2IDAgMS43NS43ODQgMS43NSAxLjc1XCIsXG4gICAgc3Ryb2tlOiBcIiM0RjdDRDFcIixcbiAgICBzdHJva2VXaWR0aDogMS41LFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk04Ljc1IDEwLjc1YTIgMiAwIDAgMSAyLTJoNi41YTIgMiAwIDAgMSAyIDJ2Ni41YTIgMiAwIDAgMS0yIDJoLTYuNWEyIDIgMCAwIDEtMi0ydi02LjVaXCIsXG4gICAgc3Ryb2tlOiBcIiM0RjdDRDFcIixcbiAgICBzdHJva2VXaWR0aDogMS41LFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pXVxufSkpO1xuXG5mdW5jdGlvbiBmb3JtYXRRUkNvZGVJbWFnZShkYXRhKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHlpZWxkIFFSQ29kZS50b1N0cmluZyhkYXRhLCB7XG4gICAgICBtYXJnaW46IDAsXG4gICAgICB0eXBlOiBcInN2Z1wiXG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgU2NhblFSQ29kZSA9ICh7XG4gIHdhbGxldCxcbiAgdXJpLFxuICBvbkNsb3NlTW9kYWwsXG4gIGhhbmRsZU9wZW5EZWZhdWx0TW9kYWxcbn0pID0+IHtcbiAgY29uc3QgW25vdGlmaWNhdGlvbiwgc2V0Tm90aWZpY2F0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbc3ZnLCBzZXRTdmddID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IGNvcHlUb0NsaXBib2FyZCA9ICgpID0+IHtcbiAgICBpZiAoIXVyaSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdWNjZXNzID0gY29weSh1cmkpO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBzZXROb3RpZmljYXRpb24odHJhbnNsYXRlKFwibW9kYWwucXIuY29waWVkVG9DbGlwYm9hcmRcIikpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXROb3RpZmljYXRpb24oXCJcIiksIDEyMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXROb3RpZmljYXRpb24odHJhbnNsYXRlKFwibW9kYWwucXIuZmFpbGVkVG9Db3B5XCIpKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0Tm90aWZpY2F0aW9uKFwiXCIpLCAxMjAwKTtcbiAgICB9XG4gIH07XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgKCgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHVyaSkge1xuICAgICAgICBzZXRTdmcoeWllbGQgZm9ybWF0UVJDb2RlSW1hZ2UodXJpKSk7XG4gICAgICB9XG4gICAgfSkpKCk7XG4gIH0sIFt1cmldKTtcbiAgcmV0dXJuIGpzeHMoXCJzZWN0aW9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJzY2FuLXFyLWNvZGVcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgIHRpdGxlOiB0cmFuc2xhdGUoXCJtb2RhbC5xci5zY2FuV2l0aFlvdXJNb2JpbGVcIiksXG4gICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgIH0pLCBqc3hzKFwic2VjdGlvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJxci1jb2RlXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7XG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgX19odG1sOiBzdmdcbiAgICAgICAgfVxuICAgICAgfSksIG5vdGlmaWNhdGlvbiA/IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlmaWNhdGlvblwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBub3RpZmljYXRpb25cbiAgICAgIH0pKSA6IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb3B5LWJ0blwiLFxuICAgICAgICBvbkNsaWNrOiBjb3B5VG9DbGlwYm9hcmRcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goQ29weUljb24sIHt9KSwgdHJhbnNsYXRlKFwibW9kYWwucXIuY29weVRvQ2xpcGJvYXJkXCIpXVxuICAgICAgfSkpXVxuICAgIH0pKSwganN4cyhcImZvb3RlclwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJmb290ZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLnFyLnByZWZlclRoZU9mZmljaWFsXCIpLCBcIiBcIiwgd2FsbGV0Lm1ldGFkYXRhLm5hbWUsIFwiP1wiXVxuICAgICAgfSksIGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJ0blwiLFxuICAgICAgICBvbkNsaWNrOiBoYW5kbGVPcGVuRGVmYXVsdE1vZGFsXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5xci5vcGVuXCIpXG4gICAgICB9KSldXG4gICAgfSkpXVxuICB9KSk7XG59O1xuXG5jb25zdCBnZXRUaGVtZUNsYXNzID0gdGhlbWUgPT4ge1xuICBzd2l0Y2ggKHRoZW1lKSB7XG4gICAgY2FzZSBcImRhcmtcIjpcbiAgICAgIHJldHVybiBcImRhcmstdGhlbWVcIjtcbiAgICBjYXNlIFwibGlnaHRcIjpcbiAgICAgIHJldHVybiBcImxpZ2h0LXRoZW1lXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuY29uc3QgTW9kYWwgPSAoe1xuICBzZWxlY3RvcixcbiAgb3B0aW9ucyxcbiAgdmlzaWJsZSxcbiAgaGlkZSxcbiAgZW1pdHRlclxufSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgW3JvdXRlLCBzZXRSb3V0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgfSk7XG4gIGNvbnN0IFthbGVydE1lc3NhZ2UsIHNldEFsZXJ0TWVzc2FnZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3NlbGVjdGVkV2FsbGV0LCBzZXRTZWxlY3RlZFdhbGxldF0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBbYnJpZGdlV2FsbGV0VXJpLCBzZXRCcmlkZ2VXYWxsZXRVcmldID0gdXNlU3RhdGUoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRSb3V0ZSh7XG4gICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgIH0pO1xuICAgIGFsbG93T25seUxhbmd1YWdlKHNlbGVjdG9yLm9wdGlvbnMubGFuZ3VhZ2VDb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgbW9kdWxlc1xuICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBtb2R1bGVzLmZpbmQobSA9PiBtLmlkID09PSBzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIHNldFNlbGVjdGVkV2FsbGV0KG1vZHVsZSk7XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiV2FsbGV0Q29ubmVjdGVkXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0QnJpZGdlV2FsbGV0VXJpKFwiXCIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBbdmlzaWJsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNlbGVjdG9yLm9uKFwibmV0d29ya0NoYW5nZWRcIiwgKHtcbiAgICAgIG5ldHdvcmtJZFxuICAgIH0pID0+IHtcbiAgICAgIC8vIFN3aXRjaGVkIGJhY2sgdG8gdGhlIGNvcnJlY3QgbmV0d29yay5cbiAgICAgIGlmIChuZXR3b3JrSWQgPT09IHNlbGVjdG9yLm9wdGlvbnMubmV0d29yay5uZXR3b3JrSWQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZURpc21pc3NDbGljayh7fSk7XG4gICAgICB9XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiV2FsbGV0TmV0d29ya0NoYW5nZWRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi5yZW1vdmUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgY29uc3QgaGFuZGxlRGlzbWlzc0NsaWNrID0gdXNlQ2FsbGJhY2soKHtcbiAgICBoaWRlUmVhc29uXG4gIH0pID0+IHtcbiAgICBzZXRBbGVydE1lc3NhZ2UobnVsbCk7XG4gICAgc2V0Um91dGUoe1xuICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICB9KTtcbiAgICBpZiAoaGlkZVJlYXNvbiA9PT0gXCJ1c2VyLXRyaWdnZXJlZFwiKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoXCJvbkhpZGVcIiwge1xuICAgICAgICBoaWRlUmVhc29uXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGhpZGVSZWFzb24gPT09IFwid2FsbGV0LW5hdmlnYXRpb25cIikge1xuICAgICAgZW1pdHRlci5lbWl0KFwib25IaWRlXCIsIHtcbiAgICAgICAgaGlkZVJlYXNvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGhpZGUoKTtcbiAgfSwgW2hpZGUsIGVtaXR0ZXJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbG9zZSA9IGUgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNsb3NlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNsb3NlKTtcbiAgfSwgW2hhbmRsZURpc21pc3NDbGlja10pO1xuICBjb25zdCBoYW5kbGVXYWxsZXRDbGljayA9IChtb2R1bGUsIHFyQ29kZU1vZGFsKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBzZXRTZWxlY3RlZFdhbGxldChtb2R1bGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICB9ID0gc2VsZWN0b3Iuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc2VsZWN0ZWRXYWxsZXRJZCA9PT0gbW9kdWxlLmlkKSB7XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiV2FsbGV0Q29ubmVjdGVkXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVwcmVjYXRlZCxcbiAgICAgICAgYXZhaWxhYmxlXG4gICAgICB9ID0gbW9kdWxlLm1ldGFkYXRhO1xuICAgICAgaWYgKG1vZHVsZS50eXBlID09PSBcImluamVjdGVkXCIgJiYgIWF2YWlsYWJsZSkge1xuICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgbmFtZTogXCJXYWxsZXROb3RJbnN0YWxsZWRcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgbW9kdWxlLndhbGxldCgpO1xuICAgICAgaWYgKGRlcHJlY2F0ZWQpIHtcbiAgICAgICAgc2V0QWxlcnRNZXNzYWdlKGAke21vZHVsZS5tZXRhZGF0YS5uYW1lfSBpcyBkZXByZWNhdGVkLiBQbGVhc2Ugc2VsZWN0IGFub3RoZXIgd2FsbGV0LmApO1xuICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgbmFtZTogXCJBbGVydE1lc3NhZ2VcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHdhbGxldC50eXBlID09PSBcImhhcmR3YXJlXCIpIHtcbiAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgIG5hbWU6IFwiRGVyaXZhdGlvblBhdGhcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHdhbGxldElkOiB3YWxsZXQuaWQgfHwgXCJsZWRnZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgbmFtZTogXCJXYWxsZXRDb25uZWN0aW5nXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHdhbGxldDogd2FsbGV0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdhbGxldC50eXBlID09PSBcImJyaWRnZVwiKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNlbGVjdG9yLm9uKFwidXJpQ2hhbmdlZFwiLCAoe1xuICAgICAgICAgIHVyaVxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgc2V0QnJpZGdlV2FsbGV0VXJpKHVyaSk7XG4gICAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgICAgbmFtZTogXCJTY2FuUVJDb2RlXCIsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICB3YWxsZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICAgIGNvbnRyYWN0SWQ6IG9wdGlvbnMuY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lczogb3B0aW9ucy5tZXRob2ROYW1lcyxcbiAgICAgICAgICBxckNvZGVNb2RhbFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnJlbW92ZSgpO1xuICAgICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgIGhpZGVSZWFzb246IFwid2FsbGV0LW5hdmlnYXRpb25cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHdhbGxldC50eXBlID09PSBcImJyb3dzZXJcIikge1xuICAgICAgICB5aWVsZCB3YWxsZXQuc2lnbkluKHtcbiAgICAgICAgICBjb250cmFjdElkOiBvcHRpb25zLmNvbnRyYWN0SWQsXG4gICAgICAgICAgbWV0aG9kTmFtZXM6IG9wdGlvbnMubWV0aG9kTmFtZXMsXG4gICAgICAgICAgc3VjY2Vzc1VybDogd2FsbGV0Lm1ldGFkYXRhLnN1Y2Nlc3NVcmwsXG4gICAgICAgICAgZmFpbHVyZVVybDogd2FsbGV0Lm1ldGFkYXRhLmZhaWx1cmVVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgaGlkZVJlYXNvbjogXCJ3YWxsZXQtbmF2aWdhdGlvblwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5aWVsZCB3YWxsZXQuc2lnbkluKHtcbiAgICAgICAgY29udHJhY3RJZDogb3B0aW9ucy5jb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lczogb3B0aW9ucy5tZXRob2ROYW1lc1xuICAgICAgfSk7XG4gICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICBoaWRlUmVhc29uOiBcIndhbGxldC1uYXZpZ2F0aW9uXCJcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gbW9kdWxlLm1ldGFkYXRhO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nXCI7XG4gICAgICBzZXRBbGVydE1lc3NhZ2UoYEZhaWxlZCB0byBzaWduIGluIHdpdGggJHtuYW1lfTogJHttZXNzYWdlfWApO1xuICAgICAgc2V0Um91dGUoe1xuICAgICAgICBuYW1lOiBcIkFsZXJ0TWVzc2FnZVwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBtb2R1bGU6IG1vZHVsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXZpc2libGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IGBud3MtbW9kYWwtd3JhcHBlciAke2dldFRoZW1lQ2xhc3Mob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRoZW1lKX0gJHt2aXNpYmxlID8gXCJvcGVuXCIgOiBcIlwifWBcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtb3ZlcmxheVwiLFxuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWxcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1vZGFsLWxlZnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibW9kYWwtbGVmdC10aXRsZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaDJcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0WW91cldhbGxldFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFdhbGxldE9wdGlvbnMsIHtcbiAgICAgICAgICBoYW5kbGVXYWxsZXRDbGljazogbW9kdWxlID0+IHtcbiAgICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrKG1vZHVsZSwgZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH0pXVxuICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJtb2RhbC1yaWdodFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtYm9keVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3JvdXRlLm5hbWUgPT09IFwiQWxlcnRNZXNzYWdlXCIgJiYgYWxlcnRNZXNzYWdlICYmIGpzeChBbGVydE1lc3NhZ2UsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGFsZXJ0TWVzc2FnZSxcbiAgICAgICAgICAgIG1vZHVsZTogKF9hID0gcm91dGUucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kdWxlLFxuICAgICAgICAgICAgb25CYWNrOiByZXRyeSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrKHNlbGVjdGVkV2FsbGV0LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0QWxlcnRNZXNzYWdlKG51bGwpO1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiRGVyaXZhdGlvblBhdGhcIiAmJiBqc3goRGVyaXZhdGlvblBhdGgsIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICAgIGhpZGVSZWFzb246IFwid2FsbGV0LW5hdmlnYXRpb25cIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJhbXM6IHJvdXRlLnBhcmFtcyxcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4gc2V0Um91dGUoe1xuICAgICAgICAgICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkVycm9yOiAobWVzc2FnZSwgd2FsbGV0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzXG4gICAgICAgICAgICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICBjb25zdCBmaW5kTW9kdWxlID0gbW9kdWxlcy5maW5kKG1vZHVsZSA9PiBtb2R1bGUuaWQgPT09IHdhbGxldC5pZCk7XG4gICAgICAgICAgICAgIHNldEFsZXJ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQWxlcnRNZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICBtb2R1bGU6IGZpbmRNb2R1bGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2VNb2RhbDogKCkgPT4gaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLCByb3V0ZS5uYW1lID09PSBcIldhbGxldE5ldHdvcmtDaGFuZ2VkXCIgJiYganN4KFdhbGxldE5ldHdvcmtDaGFuZ2VkLCB7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBvbkJhY2s6ICgpID0+IHNldFJvdXRlKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0Tm90SW5zdGFsbGVkXCIgJiYganN4KFdhbGxldE5vdEluc3RhbGxlZCwge1xuICAgICAgICAgICAgbW9kdWxlOiAoX2IgPSByb3V0ZS5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tb2R1bGUsXG4gICAgICAgICAgICBvbkJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2VNb2RhbDogKCkgPT4gaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLCByb3V0ZS5uYW1lID09PSBcIldhbGxldENvbm5lY3RpbmdcIiAmJiBqc3goV2FsbGV0Q29ubmVjdGluZywge1xuICAgICAgICAgICAgd2FsbGV0OiAoX2MgPSByb3V0ZS5wYXJhbXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy53YWxsZXQsXG4gICAgICAgICAgICBvbkJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0Um91dGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2VNb2RhbDogKCkgPT4gaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLCByb3V0ZS5uYW1lID09PSBcIldhbGxldEhvbWVcIiAmJiBqc3goV2FsbGV0SG9tZSwge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0Q29ubmVjdGVkXCIgJiYganN4KFdhbGxldENvbm5lY3RlZCwge1xuICAgICAgICAgICAgbW9kdWxlOiBzZWxlY3RlZFdhbGxldCxcbiAgICAgICAgICAgIG9uQ2xvc2VNb2RhbDogKCkgPT4gaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLCByb3V0ZS5uYW1lID09PSBcIlNjYW5RUkNvZGVcIiAmJiBqc3goU2NhblFSQ29kZSwge1xuICAgICAgICAgICAgaGFuZGxlT3BlbkRlZmF1bHRNb2RhbDogKCkgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVXYWxsZXRDbGljayhzZWxlY3RlZFdhbGxldCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdXJpOiBicmlkZ2VXYWxsZXRVcmksXG4gICAgICAgICAgICB3YWxsZXQ6IHNlbGVjdGVkV2FsbGV0XG4gICAgICAgICAgfSldXG4gICAgICAgIH0pKVxuICAgICAgfSkpXVxuICAgIH0pKV1cbiAgfSkpO1xufTtcblxuY29uc3QgTU9EQUxfRUxFTUVOVF9JRCA9IFwibmVhci13YWxsZXQtc2VsZWN0b3ItbW9kYWxcIjtcbmxldCBtb2RhbEluc3RhbmNlID0gbnVsbDtcbmxldCByb290ID0gbnVsbDtcbi8qKlxyXG4gKiBJbml0aWF0ZXMgYSBtb2RhbCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge1dhbGxldFNlbGVjdG9yfSBzZWxlY3RvciBTZWxlY3RvclxyXG4gKiBAcGFyYW0ge01vZGFsT3B0aW9uc30gb3B0aW9ucyBNb2RhbCBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtXYWxsZXRTZWxlY3Rvck1vZGFsfSBSZXR1cm5zIGEgV2FsbGV0U2VsZWN0b3JNb2RhbCBvYmplY3RcclxuICovXG5jb25zdCBzZXR1cE1vZGFsID0gKHNlbGVjdG9yLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcm9vdCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29udGFpbmVyLmlkID0gTU9EQUxfRUxFTUVOVF9JRDtcbiAgICBib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgcm9vdCA9IGNyZWF0ZVJvb3QoY29udGFpbmVyKTtcbiAgfVxuICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBjb25zdCByZW5kZXIgPSAodmlzaWJsZSA9IGZhbHNlKSA9PiB7XG4gICAgcm9vdC5yZW5kZXIoanN4KE1vZGFsLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgdmlzaWJsZTogdmlzaWJsZSxcbiAgICAgIGhpZGU6ICgpID0+IHJlbmRlcihmYWxzZSksXG4gICAgICBlbWl0dGVyOiBlbWl0dGVyXG4gICAgfSkpO1xuICB9O1xuICBpZiAoIW1vZGFsSW5zdGFuY2UpIHtcbiAgICBtb2RhbEluc3RhbmNlID0ge1xuICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICByZW5kZXIoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gZW1pdHRlci5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBvZmY6IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG1vZGFsSW5zdGFuY2U7XG59O1xuXG5leHBvcnQgeyBzZXR1cE1vZGFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/my-near-wallet/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupMyNearWallet: () => (/* binding */ setupMyNearWallet)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var _near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @near-wallet-selector/wallet-utils */ \"(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js\");\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$o =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$k = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$j = fails$k;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$j(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$i = fails$k;\n\nvar functionBindNative = !fails$i(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$k = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$k.bind(call$k) : function () {\n  return call$k.apply(call$k, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$3(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$8 = FunctionPrototype$2.bind;\nvar call$j = FunctionPrototype$2.call;\nvar uncurryThis$m = NATIVE_BIND$2 && bind$8.bind(call$j, call$j);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$m(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$j.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$l = functionUncurryThis;\n\nvar toString$6 = uncurryThis$l({}.toString);\nvar stringSlice$6 = uncurryThis$l(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$6(toString$6(it), 8, -1);\n};\n\nvar uncurryThis$k = functionUncurryThis;\nvar fails$h = fails$k;\nvar classof$7 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split$3 = uncurryThis$k(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$h(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$7(it) == 'String' ? split$3(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$c = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$4 = function (it) {\n  if (it == undefined) throw $TypeError$c(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$3 = requireObjectCoercible$4;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject$1(requireObjectCoercible$3(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$8 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$n = global$o;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$n[namespace]) : global$n[namespace] && global$n[namespace][method];\n};\n\nvar uncurryThis$j = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$j({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$m = global$o;\nvar userAgent$3 = engineUserAgent;\n\nvar process$3 = global$m.process;\nvar Deno$1 = global$m.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$g = fails$k;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$4 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$3 = tryToString$4;\n\nvar $TypeError$b = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$b(tryToString$3(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$6(func);\n};\n\nvar call$i = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$7 = isObject$8;\n\nvar $TypeError$a = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$7(val = call$i(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n  throw $TypeError$a(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar isPure = false;\n\nvar global$l = global$o;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$6(global$l, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$l[key] = value;\n  } return value;\n};\n\nvar global$k = global$o;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$k[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$2 = requireObjectCoercible$4;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function (argument) {\n  return $Object$2(requireObjectCoercible$2(argument));\n};\n\nvar uncurryThis$i = functionUncurryThis;\nvar toObject$4 = toObject$5;\n\nvar hasOwnProperty = uncurryThis$i({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$4(it), key);\n};\n\nvar uncurryThis$h = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$5 = uncurryThis$h(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$5(++id + postfix, 36);\n};\n\nvar global$j = global$o;\nvar shared$3 = shared$4.exports;\nvar hasOwn$c = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$j.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$i = function (name) {\n  if (!hasOwn$c(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$c(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$h = functionCall;\nvar isObject$6 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$h = wellKnownSymbol$i;\n\nvar $TypeError$9 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$h('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$6(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$h(exoticToPrim, input, pref);\n    if (!isObject$6(result) || isSymbol$1(result)) return result;\n    throw $TypeError$9(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar global$i = global$o;\nvar isObject$5 = isObject$8;\n\nvar document$3 = global$i.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$c = descriptors;\nvar fails$f = fails$k;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$c && !fails$f(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$b = descriptors;\nvar call$g = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toPropertyKey$2 = toPropertyKey$3;\nvar hasOwn$b = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$b ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$4(O);\n  P = toPropertyKey$2(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$b(O, P)) return createPropertyDescriptor$4(!call$g(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$a = descriptors;\nvar fails$e = fails$k;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$a && fails$e(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$4 = isObject$8;\n\nvar $String$2 = String;\nvar $TypeError$8 = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$g = function (argument) {\n  if (isObject$4(argument)) return argument;\n  throw $TypeError$8($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$f = anObject$g;\nvar toPropertyKey$1 = toPropertyKey$3;\n\nvar $TypeError$7 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$f(O);\n  P = toPropertyKey$1(P);\n  anObject$f(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$f(O);\n  P = toPropertyKey$1(P);\n  anObject$f(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$7('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar definePropertyModule$5 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$5 = DESCRIPTORS$8 ? function (object, key, value) {\n  return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$3 = {exports: {}};\n\nvar DESCRIPTORS$7 = descriptors;\nvar hasOwn$a = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$7 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$a(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$7 || (DESCRIPTORS$7 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$g = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$g(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$h = global$o;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$h.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid = uid$2;\n\nvar keys = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$g = global$o;\nvar uncurryThis$f = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$5;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$4 = global$g.TypeError;\nvar WeakMap = global$g.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$4('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$f(store.get);\n  var wmhas = uncurryThis$f(store.has);\n  var wmset = uncurryThis$f(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$9(it, STATE)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$4(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$9(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$9(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$d = fails$k;\nvar isCallable$f = isCallable$n;\nvar hasOwn$8 = hasOwnProperty_1;\nvar DESCRIPTORS$6 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState = InternalStateModule$5.enforce;\nvar getInternalState$3 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$5 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$6 && !fails$d(function () {\n  return defineProperty$5(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$2 = makeBuiltIn$3.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$8(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$6) defineProperty$5(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$8(options, 'arity') && value.length !== options.arity) {\n    defineProperty$5(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$8(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$6) defineProperty$5(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$8(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$2(function toString() {\n  return isCallable$f(this) && getInternalState$3(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$4 = objectDefineProperty;\nvar makeBuiltIn$1 = makeBuiltIn$3.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$a = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn$1(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$4.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$4 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$4 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$4 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\n\nvar max$2 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function (index, length) {\n  var integer = toIntegerOrInfinity$3(index);\n  return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$2 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$1 = toLength$2;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$4 = function (obj) {\n  return toLength$1(obj.length);\n};\n\nvar toIndexedObject$3 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$4;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$3($this);\n    var length = lengthOfArrayLike$3(O);\n    var index = toAbsoluteIndex$1(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$1(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$1(false)\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar hasOwn$7 = hasOwnProperty_1;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$4 = uncurryThis$e([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$2(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$7(hiddenKeys$2, key) && hasOwn$7(O, key) && push$4(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$7(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$4(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$d = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$e = anObject$g;\n\nvar concat$2 = uncurryThis$d([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$e(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$2(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$6 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$3 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$3.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$6(target, key) && !(exceptions && hasOwn$6(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$c = fails$k;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$c(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$f = global$o;\nvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$5;\nvar defineBuiltIn$9 = defineBuiltIn$a;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$f;\n  } else if (STATIC) {\n    target = global$f[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$f[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$2(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$3(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$9(target, key, sourceProperty, options);\n  }\n};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar uncurryThis$c = functionUncurryThis;\nvar call$f = functionCall;\nvar fails$b = fails$k;\nvar objectKeys$1 = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$3 = toObject$5;\nvar IndexedObject = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$4 = Object.defineProperty;\nvar concat$1 = uncurryThis$c([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$b(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$5 && $assign({ b: 1 }, $assign(defineProperty$4({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$4(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$3(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat$1(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$5 || call$f(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$a = _export;\nvar assign$1 = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$a({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign$1 }, {\n  assign: assign$1\n});\n\nvar wellKnownSymbol$g = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$g('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$c = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$f = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$f('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$6 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$c(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$5 = classof$6;\n\nvar $String$1 = String;\n\nvar toString$4 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String$1(argument);\n};\n\nvar anObject$d = anObject$g;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$d(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call$e = functionCall;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags$1;\n\nvar RegExpPrototype$2 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$2) && !hasOwn$5(R, 'flags') && isPrototypeOf$2(RegExpPrototype$2, R)\n    ? call$e(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar defineBuiltIn$8 = defineBuiltIn$a;\nvar anObject$c = anObject$g;\nvar $toString$2 = toString$4;\nvar fails$a = fails$k;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype$1 = RegExp.prototype;\nvar n$ToString = RegExpPrototype$1[TO_STRING];\n\nvar NOT_GENERIC = fails$a(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn$8(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject$c(this);\n    var pattern = $toString$2(R.source);\n    var flags = $toString$2(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\nvar objectDefineProperties = {};\n\nvar DESCRIPTORS$4 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$b = anObject$g;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar objectKeys = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$b(O);\n  var props = toIndexedObject$1(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$4('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$a = anObject$g;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$a(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$e = wellKnownSymbol$i;\nvar create$3 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$e('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar fails$9 = fails$k;\n\nvar correctPrototypeGetter = !fails$9(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$b = isCallable$n;\nvar toObject$2 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$2(O);\n  if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$b(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype : null;\n};\n\nvar fails$8 = fails$k;\nvar isCallable$a = isCallable$n;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$7 = defineBuiltIn$a;\nvar wellKnownSymbol$d = wellKnownSymbol$i;\n\nvar ITERATOR$7 = wellKnownSymbol$d('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$8(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$7].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$a(IteratorPrototype$2[ITERATOR$7])) {\n  defineBuiltIn$7(IteratorPrototype$2, ITERATOR$7, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$2 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$i;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');\n\nvar setToStringTag$5 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$3(target, TO_STRING_TAG$1)) {\n    defineProperty$2(target, TO_STRING_TAG$1, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$4 = setToStringTag$5;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$2 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$9 = isCallable$n;\n\nvar $String = String;\nvar $TypeError$6 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$9(argument)) return argument;\n  throw $TypeError$6(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$b = functionUncurryThis;\nvar anObject$9 = anObject$g;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$b(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$9(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$9 = _export;\nvar call$d = functionCall;\nvar FunctionName = functionName;\nvar isCallable$8 = isCallable$n;\nvar createIteratorConstructor$1 = createIteratorConstructor$2;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$5;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$5;\nvar defineBuiltIn$6 = defineBuiltIn$a;\nvar wellKnownSymbol$b = wellKnownSymbol$i;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$6 = wellKnownSymbol$b('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$2 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor$1(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$6]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$8(CurrentIteratorPrototype[ITERATOR$6])) {\n          defineBuiltIn$6(CurrentIteratorPrototype, ITERATOR$6, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$2(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$d(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$6(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$9({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$6] !== defaultIterator) {\n    defineBuiltIn$6(IterablePrototype, ITERATOR$6, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$4 = internalState;\nvar defineProperty$1 = objectDefineProperty.f;\nvar defineIterator$1 = defineIterator$2;\nvar DESCRIPTORS$3 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$2 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator$1(Array, 'Array', function (iterated, kind) {\n  setInternalState$4(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$2(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== 'values') try {\n  defineProperty$1(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\nvar classof$4 = classofRaw$1;\nvar global$e = global$o;\n\nvar engineIsNode = classof$4(global$e.process) == 'process';\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule$1 = objectDefineProperty;\nvar wellKnownSymbol$a = wellKnownSymbol$i;\nvar DESCRIPTORS$2 = descriptors;\n\nvar SPECIES$3 = wellKnownSymbol$a('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$1.f;\n\n  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {\n    defineProperty(Constructor, SPECIES$3, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$1 = objectIsPrototypeOf;\n\nvar $TypeError$5 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$1(Prototype, it)) return it;\n  throw $TypeError$5('Incorrect invocation');\n};\n\nvar uncurryThis$a = functionUncurryThis;\nvar fails$7 = fails$k;\nvar isCallable$7 = isCallable$n;\nvar classof$3 = classof$6;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$3 = uncurryThis$a(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$7(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$7(argument)) return false;\n  switch (classof$3(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$3(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$7(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$2 = tryToString$4;\n\nvar $TypeError$4 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$4(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$8 = anObject$g;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$9 = wellKnownSymbol$i;\n\nvar SPECIES$2 = wellKnownSymbol$9('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$8(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$8(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$2 = FunctionPrototype.apply;\nvar call$c = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$c.bind(apply$2) : function () {\n  return call$c.apply(apply$2, arguments);\n});\n\nvar uncurryThis$9 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$7 = uncurryThis$9(uncurryThis$9.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$7(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis$8 = functionUncurryThis;\n\nvar arraySlice$3 = uncurryThis$8([].slice);\n\nvar $TypeError$3 = TypeError;\n\nvar validateArgumentsLength$3 = function (passed, required) {\n  if (passed < required) throw $TypeError$3('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$d = global$o;\nvar apply$1 = functionApply;\nvar bind$6 = functionBindContext;\nvar isCallable$6 = isCallable$n;\nvar hasOwn$2 = hasOwnProperty_1;\nvar fails$6 = fails$k;\nvar html = html$2;\nvar arraySlice$2 = arraySlice$3;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength$2 = validateArgumentsLength$3;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$d.setImmediate;\nvar clear = global$d.clearImmediate;\nvar process$2 = global$d.process;\nvar Dispatch = global$d.Dispatch;\nvar Function$1 = global$d.Function;\nvar MessageChannel = global$d.MessageChannel;\nvar String$1 = global$d.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$d.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$2(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$d.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength$2(arguments.length, 1);\n    var fn = isCallable$6(handler) ? handler : Function$1(handler);\n    var args = arraySlice$2(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$1(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$6(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$d.addEventListener &&\n    isCallable$6(global$d.postMessage) &&\n    !global$d.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$6(post)\n  ) {\n    defer = post;\n    global$d.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$c = global$o;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$c.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$b = global$o;\nvar bind$5 = functionBindContext;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$b.MutationObserver || global$b.WebKitMutationObserver;\nvar document$2 = global$b.document;\nvar process$1 = global$b.process;\nvar Promise$1 = global$b.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$b, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$5(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$5(macrotask, global$b);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$a = global$o;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$a.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$9 = global$o;\n\nvar promiseNativeConstructor = global$9.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$8 = global$o;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$5 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$i;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$1 = wellKnownSymbol$8('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$5(global$8.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$1] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$7;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$8 = _export;\nvar IS_NODE = engineIsNode;\nvar global$7 = global$o;\nvar call$b = functionCall;\nvar defineBuiltIn$5 = defineBuiltIn$a;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag$2 = setToStringTag$5;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$4 = isCallable$n;\nvar isObject$2 = isObject$8;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$3 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$3.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$3 = global$7.TypeError;\nvar document$1 = global$7.document;\nvar process = global$7.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$7.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$2(it) && isCallable$4(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$3('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$b(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$7.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$7['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$b(task, global$7, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$b(task, global$7, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$4 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$3(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$b(then, value,\n            bind$4(internalResolve, wrapper, state),\n            bind$4(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$3(executor);\n    call$b(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$4(internalResolve, state), bind$4(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$5(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$4(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$4(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$4(internalResolve, state);\n    this.reject = bind$4(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$4(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$5(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$b(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$8({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$2(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$7 = wellKnownSymbol$i;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$7('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$5] === it);\n};\n\nvar classof$2 = classof$6;\nvar getMethod$2 = getMethod$4;\nvar Iterators = iterators;\nvar wellKnownSymbol$6 = wellKnownSymbol$i;\n\nvar ITERATOR$4 = wellKnownSymbol$6('iterator');\n\nvar getIteratorMethod$4 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators[classof$2(it)];\n};\n\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$7 = anObject$g;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$3 = getIteratorMethod$4;\n\nvar $TypeError$2 = TypeError;\n\nvar getIterator$3 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$3(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$7(call$a(iteratorMethod, argument));\n  throw $TypeError$2(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$9 = functionCall;\nvar anObject$6 = anObject$g;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$2 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$6(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$9(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$6(innerResult);\n  return value;\n};\n\nvar bind$3 = functionBindContext;\nvar call$8 = functionCall;\nvar anObject$5 = anObject$g;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$4;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar getIterator$2 = getIterator$3;\nvar getIteratorMethod$2 = getIteratorMethod$4;\nvar iteratorClose$1 = iteratorClose$2;\n\nvar $TypeError$1 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$3(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose$1(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$5(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$2(iterable);\n    if (!iterFn) throw $TypeError$1(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$2(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$8(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose$1(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$5 = wellKnownSymbol$i;\n\nvar ITERATOR$3 = wellKnownSymbol$5('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$7 = _export;\nvar call$7 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$7({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$7($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$6 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$3 = isCallable$n;\nvar defineBuiltIn$4 = defineBuiltIn$a;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$6({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$3(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$4(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$5 = _export;\nvar call$6 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$5({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$6($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$4 = _export;\nvar call$5 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$4({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$5(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$4 = anObject$g;\nvar isObject$1 = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$4(C);\n  if (isObject$1(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$3 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$3({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$6 = global$o;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$i;\n\nvar ITERATOR$2 = wellKnownSymbol$4('iterator');\nvar TO_STRING_TAG = wellKnownSymbol$4('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {\n      createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$2, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$2] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$6[COLLECTION_NAME] && global$6[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar uncurryThis$7 = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$3 = toString$4;\nvar requireObjectCoercible$1 = requireObjectCoercible$4;\n\nvar charAt$6 = uncurryThis$7(''.charAt);\nvar charCodeAt$1 = uncurryThis$7(''.charCodeAt);\nvar stringSlice$5 = uncurryThis$7(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$3(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity$1(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt$1(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$6(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$5(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt$5 = stringMultibyte.charAt;\nvar toString$2 = toString$4;\nvar InternalStateModule$2 = internalState;\nvar defineIterator = defineIterator$2;\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$2 = InternalStateModule$2.set;\nvar getInternalState$1 = InternalStateModule$2.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState$2(this, {\n    type: STRING_ITERATOR,\n    string: toString$2(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$1(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt$5(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\nvar fails$5 = fails$k;\nvar wellKnownSymbol$3 = wellKnownSymbol$i;\nvar IS_PURE = isPure;\n\nvar ITERATOR$1 = wellKnownSymbol$3('iterator');\n\nvar nativeUrl = !fails$5(function () {\n  // eslint-disable-next-line unicorn/relative-url-style -- required for testing\n  var url = new URL('b?a=1&b=2&c=3', 'http://a');\n  var searchParams = url.searchParams;\n  var result = '';\n  url.pathname = 'c%20d';\n  searchParams.forEach(function (value, key) {\n    searchParams['delete']('b');\n    result += key + value;\n  });\n  return (IS_PURE && !url.toJSON)\n    || !searchParams.sort\n    || url.href !== 'http://a/c%20d?a=1&c=3'\n    || searchParams.get('c') !== '3'\n    || String(new URLSearchParams('?a=1')) !== 'a=1'\n    || !searchParams[ITERATOR$1]\n    // throws in Edge\n    || new URL('https://a@b').username !== 'a'\n    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'\n    // not punycoded in Edge\n    || new URL('http://тест').host !== 'xn--e1aybc'\n    // not escaped in Chrome 62-\n    || new URL('http://a#б').hash !== '#%D0%B1'\n    // fails in Chrome 66-\n    || result !== 'a1c3'\n    // throws in Safari\n    || new URL('http://x', undefined).host !== 'x';\n});\n\nvar makeBuiltIn = makeBuiltIn$3.exports;\nvar defineProperty = objectDefineProperty;\n\nvar defineBuiltInAccessor$1 = function (target, name, descriptor) {\n  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });\n  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });\n  return defineProperty.f(target, name, descriptor);\n};\n\nvar anObject$3 = anObject$g;\nvar iteratorClose = iteratorClose$2;\n\n// call something on iterator step with safe closing on error\nvar callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject$3(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator, 'throw', error);\n  }\n};\n\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$2 = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$4 = functionCall;\nvar toObject$1 = toObject$5;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar isConstructor = isConstructor$2;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$4;\nvar createProperty$1 = createProperty$2;\nvar getIterator$1 = getIterator$3;\nvar getIteratorMethod$1 = getIteratorMethod$4;\n\nvar $Array$1 = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nvar arrayFrom$1 = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject$1(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind$2(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod$1(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array$1 && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = getIterator$1(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call$4(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty$1(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike$1(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array$1(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty$1(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike = lengthOfArrayLike$4;\nvar createProperty = createProperty$2;\n\nvar $Array = Array;\nvar max$1 = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max$1(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar uncurryThis$6 = functionUncurryThis;\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\n\nvar $RangeError = RangeError;\nvar exec$2 = uncurryThis$6(regexSeparators.exec);\nvar floor$3 = Math.floor;\nvar fromCharCode = String.fromCharCode;\nvar charCodeAt = uncurryThis$6(''.charCodeAt);\nvar join$2 = uncurryThis$6([].join);\nvar push$3 = uncurryThis$6([].push);\nvar replace$4 = uncurryThis$6(''.replace);\nvar split$2 = uncurryThis$6(''.split);\nvar toLowerCase$1 = uncurryThis$6(''.toLowerCase);\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var value = charCodeAt(string, counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = charCodeAt(string, counter++);\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n        push$3(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        push$3(output, value);\n        counter--;\n      }\n    } else {\n      push$3(output, value);\n    }\n  }\n  return output;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n */\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor$3(delta / damp) : delta >> 1;\n  delta += floor$3(delta / numPoints);\n  while (delta > baseMinusTMin * tMax >> 1) {\n    delta = floor$3(delta / baseMinusTMin);\n    k += base;\n  }\n  return floor$3(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\nvar encode = function (input) {\n  var output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  var inputLength = input.length;\n\n  // Initialize the state.\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue;\n\n  // Handle the basic code points.\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n    if (currentValue < 0x80) {\n      push$3(output, fromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n  var handledCPCount = basicLength; // number of code points that have been handled;\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    push$3(output, delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n    var handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor$3((maxInt - delta) / handledCPCountPlusOne)) {\n      throw $RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue < n && ++delta > maxInt) {\n        throw $RangeError(OVERFLOW_ERROR);\n      }\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        var k = base;\n        while (true) {\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          push$3(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor$3(qMinusT / baseMinusT);\n          k += base;\n        }\n\n        push$3(output, fromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        handledCPCount++;\n      }\n    }\n\n    delta++;\n    n++;\n  }\n  return join$2(output, '');\n};\n\nvar stringPunycodeToAscii = function (input) {\n  var encoded = [];\n  var labels = split$2(replace$4(toLowerCase$1(input), regexSeparators, '\\u002E'), '.');\n  var i, label;\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    push$3(encoded, exec$2(regexNonASCII, label) ? 'xn--' + encode(label) : label);\n  }\n  return join$2(encoded, '.');\n};\n\nvar defineBuiltIn$3 = defineBuiltIn$a;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$3(target, key, src[key], options);\n  return target;\n};\n\nvar arraySlice$1 = arraySliceSimple;\n\nvar floor$2 = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor$2(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$1(array, 0, middle), comparefn),\n    mergeSort(arraySlice$1(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort$1 = mergeSort;\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n\nvar $$2 = _export;\nvar global$5 = global$o;\nvar call$3 = functionCall;\nvar uncurryThis$5 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar USE_NATIVE_URL$1 = nativeUrl;\nvar defineBuiltIn$2 = defineBuiltIn$a;\nvar defineBuiltIns = defineBuiltIns$1;\nvar setToStringTag$1 = setToStringTag$5;\nvar createIteratorConstructor = createIteratorConstructor$2;\nvar InternalStateModule$1 = internalState;\nvar anInstance$1 = anInstance$3;\nvar isCallable$2 = isCallable$n;\nvar hasOwn$1 = hasOwnProperty_1;\nvar bind$1 = functionBindContext;\nvar classof$1 = classof$6;\nvar anObject$2 = anObject$g;\nvar isObject = isObject$8;\nvar $toString$1 = toString$4;\nvar create$1 = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar getIterator = getIterator$3;\nvar getIteratorMethod = getIteratorMethod$4;\nvar validateArgumentsLength$1 = validateArgumentsLength$3;\nvar wellKnownSymbol$2 = wellKnownSymbol$i;\nvar arraySort = arraySort$1;\n\nvar ITERATOR = wellKnownSymbol$2('iterator');\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalParamsState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS_ITERATOR);\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Avoid NodeJS experimental warning\nvar safeGetBuiltIn = function (name) {\n  if (!DESCRIPTORS$1) return global$5[name];\n  var descriptor = getOwnPropertyDescriptor(global$5, name);\n  return descriptor && descriptor.value;\n};\n\nvar nativeFetch = safeGetBuiltIn('fetch');\nvar NativeRequest = safeGetBuiltIn('Request');\nvar Headers = safeGetBuiltIn('Headers');\nvar RequestPrototype = NativeRequest && NativeRequest.prototype;\nvar HeadersPrototype = Headers && Headers.prototype;\nvar RegExp$1 = global$5.RegExp;\nvar TypeError$2 = global$5.TypeError;\nvar decodeURIComponent = global$5.decodeURIComponent;\nvar encodeURIComponent$1 = global$5.encodeURIComponent;\nvar charAt$4 = uncurryThis$5(''.charAt);\nvar join$1 = uncurryThis$5([].join);\nvar push$2 = uncurryThis$5([].push);\nvar replace$3 = uncurryThis$5(''.replace);\nvar shift$1 = uncurryThis$5([].shift);\nvar splice = uncurryThis$5([].splice);\nvar split$1 = uncurryThis$5(''.split);\nvar stringSlice$4 = uncurryThis$5(''.slice);\n\nvar plus = /\\+/g;\nvar sequences = Array(4);\n\nvar percentSequence = function (bytes) {\n  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1('((?:%[\\\\da-f]{2}){' + bytes + '})', 'gi'));\n};\n\nvar percentDecode = function (sequence) {\n  try {\n    return decodeURIComponent(sequence);\n  } catch (error) {\n    return sequence;\n  }\n};\n\nvar deserialize = function (it) {\n  var result = replace$3(it, plus, ' ');\n  var bytes = 4;\n  try {\n    return decodeURIComponent(result);\n  } catch (error) {\n    while (bytes) {\n      result = replace$3(result, percentSequence(bytes--), percentDecode);\n    }\n    return result;\n  }\n};\n\nvar find = /[!'()~]|%20/g;\n\nvar replacements = {\n  '!': '%21',\n  \"'\": '%27',\n  '(': '%28',\n  ')': '%29',\n  '~': '%7E',\n  '%20': '+'\n};\n\nvar replacer = function (match) {\n  return replacements[match];\n};\n\nvar serialize = function (it) {\n  return replace$3(encodeURIComponent$1(it), find, replacer);\n};\n\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n  setInternalState$1(this, {\n    type: URL_SEARCH_PARAMS_ITERATOR,\n    iterator: getIterator(getInternalParamsState(params).entries),\n    kind: kind\n  });\n}, 'Iterator', function next() {\n  var state = getInternalIteratorState(this);\n  var kind = state.kind;\n  var step = state.iterator.next();\n  var entry = step.value;\n  if (!step.done) {\n    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];\n  } return step;\n}, true);\n\nvar URLSearchParamsState = function (init) {\n  this.entries = [];\n  this.url = null;\n\n  if (init !== undefined) {\n    if (isObject(init)) this.parseObject(init);\n    else this.parseQuery(typeof init == 'string' ? charAt$4(init, 0) === '?' ? stringSlice$4(init, 1) : init : $toString$1(init));\n  }\n};\n\nURLSearchParamsState.prototype = {\n  type: URL_SEARCH_PARAMS,\n  bindURL: function (url) {\n    this.url = url;\n    this.update();\n  },\n  parseObject: function (object) {\n    var iteratorMethod = getIteratorMethod(object);\n    var iterator, next, step, entryIterator, entryNext, first, second;\n\n    if (iteratorMethod) {\n      iterator = getIterator(object, iteratorMethod);\n      next = iterator.next;\n      while (!(step = call$3(next, iterator)).done) {\n        entryIterator = getIterator(anObject$2(step.value));\n        entryNext = entryIterator.next;\n        if (\n          (first = call$3(entryNext, entryIterator)).done ||\n          (second = call$3(entryNext, entryIterator)).done ||\n          !call$3(entryNext, entryIterator).done\n        ) throw TypeError$2('Expected sequence with length 2');\n        push$2(this.entries, { key: $toString$1(first.value), value: $toString$1(second.value) });\n      }\n    } else for (var key in object) if (hasOwn$1(object, key)) {\n      push$2(this.entries, { key: key, value: $toString$1(object[key]) });\n    }\n  },\n  parseQuery: function (query) {\n    if (query) {\n      var attributes = split$1(query, '&');\n      var index = 0;\n      var attribute, entry;\n      while (index < attributes.length) {\n        attribute = attributes[index++];\n        if (attribute.length) {\n          entry = split$1(attribute, '=');\n          push$2(this.entries, {\n            key: deserialize(shift$1(entry)),\n            value: deserialize(join$1(entry, '='))\n          });\n        }\n      }\n    }\n  },\n  serialize: function () {\n    var entries = this.entries;\n    var result = [];\n    var index = 0;\n    var entry;\n    while (index < entries.length) {\n      entry = entries[index++];\n      push$2(result, serialize(entry.key) + '=' + serialize(entry.value));\n    } return join$1(result, '&');\n  },\n  update: function () {\n    this.entries.length = 0;\n    this.parseQuery(this.url.query);\n  },\n  updateURL: function () {\n    if (this.url) this.url.update();\n  }\n};\n\n// `URLSearchParams` constructor\n// https://url.spec.whatwg.org/#interface-urlsearchparams\nvar URLSearchParamsConstructor = function URLSearchParams(/* init */) {\n  anInstance$1(this, URLSearchParamsPrototype);\n  var init = arguments.length > 0 ? arguments[0] : undefined;\n  setInternalState$1(this, new URLSearchParamsState(init));\n};\n\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\n\ndefineBuiltIns(URLSearchParamsPrototype, {\n  // `URLSearchParams.prototype.append` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-append\n  append: function append(name, value) {\n    validateArgumentsLength$1(arguments.length, 2);\n    var state = getInternalParamsState(this);\n    push$2(state.entries, { key: $toString$1(name), value: $toString$1(value) });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.delete` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete\n  'delete': function (name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var key = $toString$1(name);\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index].key === key) splice(entries, index, 1);\n      else index++;\n    }\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.get` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-get\n  get: function get(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) return entries[index].value;\n    }\n    return null;\n  },\n  // `URLSearchParams.prototype.getAll` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall\n  getAll: function getAll(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var result = [];\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) push$2(result, entries[index].value);\n    }\n    return result;\n  },\n  // `URLSearchParams.prototype.has` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-has\n  has: function has(name) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = $toString$1(name);\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index++].key === key) return true;\n    }\n    return false;\n  },\n  // `URLSearchParams.prototype.set` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-set\n  set: function set(name, value) {\n    validateArgumentsLength$1(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var found = false;\n    var key = $toString$1(name);\n    var val = $toString$1(value);\n    var index = 0;\n    var entry;\n    for (; index < entries.length; index++) {\n      entry = entries[index];\n      if (entry.key === key) {\n        if (found) splice(entries, index--, 1);\n        else {\n          found = true;\n          entry.value = val;\n        }\n      }\n    }\n    if (!found) push$2(entries, { key: key, value: val });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.sort` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort\n  sort: function sort() {\n    var state = getInternalParamsState(this);\n    arraySort(state.entries, function (a, b) {\n      return a.key > b.key ? 1 : -1;\n    });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.forEach` method\n  forEach: function forEach(callback /* , thisArg */) {\n    var entries = getInternalParamsState(this).entries;\n    var boundFunction = bind$1(callback, arguments.length > 1 ? arguments[1] : undefined);\n    var index = 0;\n    var entry;\n    while (index < entries.length) {\n      entry = entries[index++];\n      boundFunction(entry.value, entry.key, this);\n    }\n  },\n  // `URLSearchParams.prototype.keys` method\n  keys: function keys() {\n    return new URLSearchParamsIterator(this, 'keys');\n  },\n  // `URLSearchParams.prototype.values` method\n  values: function values() {\n    return new URLSearchParamsIterator(this, 'values');\n  },\n  // `URLSearchParams.prototype.entries` method\n  entries: function entries() {\n    return new URLSearchParamsIterator(this, 'entries');\n  }\n}, { enumerable: true });\n\n// `URLSearchParams.prototype[@@iterator]` method\ndefineBuiltIn$2(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });\n\n// `URLSearchParams.prototype.toString` method\n// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\ndefineBuiltIn$2(URLSearchParamsPrototype, 'toString', function toString() {\n  return getInternalParamsState(this).serialize();\n}, { enumerable: true });\n\nsetToStringTag$1(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n\n$$2({ global: true, constructor: true, forced: !USE_NATIVE_URL$1 }, {\n  URLSearchParams: URLSearchParamsConstructor\n});\n\n// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`\nif (!USE_NATIVE_URL$1 && isCallable$2(Headers)) {\n  var headersHas = uncurryThis$5(HeadersPrototype.has);\n  var headersSet = uncurryThis$5(HeadersPrototype.set);\n\n  var wrapRequestOptions = function (init) {\n    if (isObject(init)) {\n      var body = init.body;\n      var headers;\n      if (classof$1(body) === URL_SEARCH_PARAMS) {\n        headers = init.headers ? new Headers(init.headers) : new Headers();\n        if (!headersHas(headers, 'content-type')) {\n          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n        return create$1(init, {\n          body: createPropertyDescriptor(0, $toString$1(body)),\n          headers: createPropertyDescriptor(0, headers)\n        });\n      }\n    } return init;\n  };\n\n  if (isCallable$2(nativeFetch)) {\n    $$2({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {\n      fetch: function fetch(input /* , init */) {\n        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n      }\n    });\n  }\n\n  if (isCallable$2(NativeRequest)) {\n    var RequestConstructor = function Request(input /* , init */) {\n      anInstance$1(this, RequestPrototype);\n      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n    };\n\n    RequestPrototype.constructor = RequestConstructor;\n    RequestConstructor.prototype = RequestPrototype;\n\n    $$2({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {\n      Request: RequestConstructor\n    });\n  }\n}\n\nvar web_urlSearchParams_constructor = {\n  URLSearchParams: URLSearchParamsConstructor,\n  getState: getInternalParamsState\n};\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n\nvar $$1 = _export;\nvar DESCRIPTORS = descriptors;\nvar USE_NATIVE_URL = nativeUrl;\nvar global$4 = global$o;\nvar bind = functionBindContext;\nvar uncurryThis$4 = functionUncurryThis;\nvar defineBuiltIn$1 = defineBuiltIn$a;\nvar defineBuiltInAccessor = defineBuiltInAccessor$1;\nvar anInstance = anInstance$3;\nvar hasOwn = hasOwnProperty_1;\nvar assign = objectAssign;\nvar arrayFrom = arrayFrom$1;\nvar arraySlice = arraySliceSimple;\nvar codeAt = stringMultibyte.codeAt;\nvar toASCII = stringPunycodeToAscii;\nvar $toString = toString$4;\nvar setToStringTag = setToStringTag$5;\nvar validateArgumentsLength = validateArgumentsLength$3;\nvar URLSearchParamsModule = web_urlSearchParams_constructor;\nvar InternalStateModule = internalState;\n\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor('URL');\nvar URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\n\nvar NativeURL = global$4.URL;\nvar TypeError$1 = global$4.TypeError;\nvar parseInt = global$4.parseInt;\nvar floor$1 = Math.floor;\nvar pow = Math.pow;\nvar charAt$3 = uncurryThis$4(''.charAt);\nvar exec$1 = uncurryThis$4(/./.exec);\nvar join = uncurryThis$4([].join);\nvar numberToString = uncurryThis$4(1.0.toString);\nvar pop = uncurryThis$4([].pop);\nvar push$1 = uncurryThis$4([].push);\nvar replace$2 = uncurryThis$4(''.replace);\nvar shift = uncurryThis$4([].shift);\nvar split = uncurryThis$4(''.split);\nvar stringSlice$3 = uncurryThis$4(''.slice);\nvar toLowerCase = uncurryThis$4(''.toLowerCase);\nvar unshift = uncurryThis$4([].unshift);\n\nvar INVALID_AUTHORITY = 'Invalid authority';\nvar INVALID_SCHEME = 'Invalid scheme';\nvar INVALID_HOST = 'Invalid host';\nvar INVALID_PORT = 'Invalid port';\n\nvar ALPHA = /[a-z]/i;\n// eslint-disable-next-line regexp/no-obscure-range -- safe\nvar ALPHANUMERIC = /[\\d+-.a-z]/i;\nvar DIGIT = /\\d/;\nvar HEX_START = /^0x/i;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\da-f]+$/i;\n/* eslint-disable regexp/no-control-character -- safe */\nvar FORBIDDEN_HOST_CODE_POINT = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u0020]+|[\\u0000-\\u0020]+$/g;\nvar TAB_AND_NEW_LINE = /[\\t\\n\\r]/g;\n/* eslint-enable regexp/no-control-character -- safe */\nvar EOF;\n\n// https://url.spec.whatwg.org/#ipv4-number-parser\nvar parseIPv4 = function (input) {\n  var parts = split(input, '.');\n  var partsLength, numbers, index, part, radix, number, ipv4;\n  if (parts.length && parts[parts.length - 1] == '') {\n    parts.length--;\n  }\n  partsLength = parts.length;\n  if (partsLength > 4) return input;\n  numbers = [];\n  for (index = 0; index < partsLength; index++) {\n    part = parts[index];\n    if (part == '') return input;\n    radix = 10;\n    if (part.length > 1 && charAt$3(part, 0) == '0') {\n      radix = exec$1(HEX_START, part) ? 16 : 8;\n      part = stringSlice$3(part, radix == 8 ? 1 : 2);\n    }\n    if (part === '') {\n      number = 0;\n    } else {\n      if (!exec$1(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;\n      number = parseInt(part, radix);\n    }\n    push$1(numbers, number);\n  }\n  for (index = 0; index < partsLength; index++) {\n    number = numbers[index];\n    if (index == partsLength - 1) {\n      if (number >= pow(256, 5 - partsLength)) return null;\n    } else if (number > 255) return null;\n  }\n  ipv4 = pop(numbers);\n  for (index = 0; index < numbers.length; index++) {\n    ipv4 += numbers[index] * pow(256, 3 - index);\n  }\n  return ipv4;\n};\n\n// https://url.spec.whatwg.org/#concept-ipv6-parser\n// eslint-disable-next-line max-statements -- TODO\nvar parseIPv6 = function (input) {\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\n  var pieceIndex = 0;\n  var compress = null;\n  var pointer = 0;\n  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n\n  var chr = function () {\n    return charAt$3(input, pointer);\n  };\n\n  if (chr() == ':') {\n    if (charAt$3(input, 1) != ':') return;\n    pointer += 2;\n    pieceIndex++;\n    compress = pieceIndex;\n  }\n  while (chr()) {\n    if (pieceIndex == 8) return;\n    if (chr() == ':') {\n      if (compress !== null) return;\n      pointer++;\n      pieceIndex++;\n      compress = pieceIndex;\n      continue;\n    }\n    value = length = 0;\n    while (length < 4 && exec$1(HEX, chr())) {\n      value = value * 16 + parseInt(chr(), 16);\n      pointer++;\n      length++;\n    }\n    if (chr() == '.') {\n      if (length == 0) return;\n      pointer -= length;\n      if (pieceIndex > 6) return;\n      numbersSeen = 0;\n      while (chr()) {\n        ipv4Piece = null;\n        if (numbersSeen > 0) {\n          if (chr() == '.' && numbersSeen < 4) pointer++;\n          else return;\n        }\n        if (!exec$1(DIGIT, chr())) return;\n        while (exec$1(DIGIT, chr())) {\n          number = parseInt(chr(), 10);\n          if (ipv4Piece === null) ipv4Piece = number;\n          else if (ipv4Piece == 0) return;\n          else ipv4Piece = ipv4Piece * 10 + number;\n          if (ipv4Piece > 255) return;\n          pointer++;\n        }\n        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n        numbersSeen++;\n        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;\n      }\n      if (numbersSeen != 4) return;\n      break;\n    } else if (chr() == ':') {\n      pointer++;\n      if (!chr()) return;\n    } else if (chr()) return;\n    address[pieceIndex++] = value;\n  }\n  if (compress !== null) {\n    swaps = pieceIndex - compress;\n    pieceIndex = 7;\n    while (pieceIndex != 0 && swaps > 0) {\n      swap = address[pieceIndex];\n      address[pieceIndex--] = address[compress + swaps - 1];\n      address[compress + --swaps] = swap;\n    }\n  } else if (pieceIndex != 8) return;\n  return address;\n};\n\nvar findLongestZeroSequence = function (ipv6) {\n  var maxIndex = null;\n  var maxLength = 1;\n  var currStart = null;\n  var currLength = 0;\n  var index = 0;\n  for (; index < 8; index++) {\n    if (ipv6[index] !== 0) {\n      if (currLength > maxLength) {\n        maxIndex = currStart;\n        maxLength = currLength;\n      }\n      currStart = null;\n      currLength = 0;\n    } else {\n      if (currStart === null) currStart = index;\n      ++currLength;\n    }\n  }\n  if (currLength > maxLength) {\n    maxIndex = currStart;\n    maxLength = currLength;\n  }\n  return maxIndex;\n};\n\n// https://url.spec.whatwg.org/#host-serializing\nvar serializeHost = function (host) {\n  var result, index, compress, ignore0;\n  // ipv4\n  if (typeof host == 'number') {\n    result = [];\n    for (index = 0; index < 4; index++) {\n      unshift(result, host % 256);\n      host = floor$1(host / 256);\n    } return join(result, '.');\n  // ipv6\n  } else if (typeof host == 'object') {\n    result = '';\n    compress = findLongestZeroSequence(host);\n    for (index = 0; index < 8; index++) {\n      if (ignore0 && host[index] === 0) continue;\n      if (ignore0) ignore0 = false;\n      if (compress === index) {\n        result += index ? ':' : '::';\n        ignore0 = true;\n      } else {\n        result += numberToString(host[index], 16);\n        if (index < 7) result += ':';\n      }\n    }\n    return '[' + result + ']';\n  } return host;\n};\n\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n  ' ': 1, '\"': 1, '<': 1, '>': 1, '`': 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n  '#': 1, '?': 1, '{': 1, '}': 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\\\': 1, ']': 1, '^': 1, '|': 1\n});\n\nvar percentEncode = function (chr, set) {\n  var code = codeAt(chr, 0);\n  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);\n};\n\n// https://url.spec.whatwg.org/#special-scheme\nvar specialSchemes = {\n  ftp: 21,\n  file: null,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443\n};\n\n// https://url.spec.whatwg.org/#windows-drive-letter\nvar isWindowsDriveLetter = function (string, normalized) {\n  var second;\n  return string.length == 2 && exec$1(ALPHA, charAt$3(string, 0))\n    && ((second = charAt$3(string, 1)) == ':' || (!normalized && second == '|'));\n};\n\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nvar startsWithWindowsDriveLetter = function (string) {\n  var third;\n  return string.length > 1 && isWindowsDriveLetter(stringSlice$3(string, 0, 2)) && (\n    string.length == 2 ||\n    ((third = charAt$3(string, 2)) === '/' || third === '\\\\' || third === '?' || third === '#')\n  );\n};\n\n// https://url.spec.whatwg.org/#single-dot-path-segment\nvar isSingleDot = function (segment) {\n  return segment === '.' || toLowerCase(segment) === '%2e';\n};\n\n// https://url.spec.whatwg.org/#double-dot-path-segment\nvar isDoubleDot = function (segment) {\n  segment = toLowerCase(segment);\n  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\n};\n\n// States:\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\n\nvar URLState = function (url, isBase, base) {\n  var urlString = $toString(url);\n  var baseState, failure, searchParams;\n  if (isBase) {\n    failure = this.parse(urlString);\n    if (failure) throw TypeError$1(failure);\n    this.searchParams = null;\n  } else {\n    if (base !== undefined) baseState = new URLState(base, true);\n    failure = this.parse(urlString, null, baseState);\n    if (failure) throw TypeError$1(failure);\n    searchParams = getInternalSearchParamsState(new URLSearchParams$1());\n    searchParams.bindURL(this);\n    this.searchParams = searchParams;\n  }\n};\n\nURLState.prototype = {\n  type: 'URL',\n  // https://url.spec.whatwg.org/#url-parsing\n  // eslint-disable-next-line max-statements -- TODO\n  parse: function (input, stateOverride, base) {\n    var url = this;\n    var state = stateOverride || SCHEME_START;\n    var pointer = 0;\n    var buffer = '';\n    var seenAt = false;\n    var seenBracket = false;\n    var seenPasswordToken = false;\n    var codePoints, chr, bufferCodePoints, failure;\n\n    input = $toString(input);\n\n    if (!stateOverride) {\n      url.scheme = '';\n      url.username = '';\n      url.password = '';\n      url.host = null;\n      url.port = null;\n      url.path = [];\n      url.query = null;\n      url.fragment = null;\n      url.cannotBeABaseURL = false;\n      input = replace$2(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\n    }\n\n    input = replace$2(input, TAB_AND_NEW_LINE, '');\n\n    codePoints = arrayFrom(input);\n\n    while (pointer <= codePoints.length) {\n      chr = codePoints[pointer];\n      switch (state) {\n        case SCHEME_START:\n          if (chr && exec$1(ALPHA, chr)) {\n            buffer += toLowerCase(chr);\n            state = SCHEME;\n          } else if (!stateOverride) {\n            state = NO_SCHEME;\n            continue;\n          } else return INVALID_SCHEME;\n          break;\n\n        case SCHEME:\n          if (chr && (exec$1(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {\n            buffer += toLowerCase(chr);\n          } else if (chr == ':') {\n            if (stateOverride && (\n              (url.isSpecial() != hasOwn(specialSchemes, buffer)) ||\n              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||\n              (url.scheme == 'file' && !url.host)\n            )) return;\n            url.scheme = buffer;\n            if (stateOverride) {\n              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;\n              return;\n            }\n            buffer = '';\n            if (url.scheme == 'file') {\n              state = FILE;\n            } else if (url.isSpecial() && base && base.scheme == url.scheme) {\n              state = SPECIAL_RELATIVE_OR_AUTHORITY;\n            } else if (url.isSpecial()) {\n              state = SPECIAL_AUTHORITY_SLASHES;\n            } else if (codePoints[pointer + 1] == '/') {\n              state = PATH_OR_AUTHORITY;\n              pointer++;\n            } else {\n              url.cannotBeABaseURL = true;\n              push$1(url.path, '');\n              state = CANNOT_BE_A_BASE_URL_PATH;\n            }\n          } else if (!stateOverride) {\n            buffer = '';\n            state = NO_SCHEME;\n            pointer = 0;\n            continue;\n          } else return INVALID_SCHEME;\n          break;\n\n        case NO_SCHEME:\n          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;\n          if (base.cannotBeABaseURL && chr == '#') {\n            url.scheme = base.scheme;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n            url.fragment = '';\n            url.cannotBeABaseURL = true;\n            state = FRAGMENT;\n            break;\n          }\n          state = base.scheme == 'file' ? FILE : RELATIVE;\n          continue;\n\n        case SPECIAL_RELATIVE_OR_AUTHORITY:\n          if (chr == '/' && codePoints[pointer + 1] == '/') {\n            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n            pointer++;\n          } else {\n            state = RELATIVE;\n            continue;\n          } break;\n\n        case PATH_OR_AUTHORITY:\n          if (chr == '/') {\n            state = AUTHORITY;\n            break;\n          } else {\n            state = PATH;\n            continue;\n          }\n\n        case RELATIVE:\n          url.scheme = base.scheme;\n          if (chr == EOF) {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n          } else if (chr == '/' || (chr == '\\\\' && url.isSpecial())) {\n            state = RELATIVE_SLASH;\n          } else if (chr == '?') {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = '';\n            state = QUERY;\n          } else if (chr == '#') {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.query = base.query;\n            url.fragment = '';\n            state = FRAGMENT;\n          } else {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            url.path = arraySlice(base.path);\n            url.path.length--;\n            state = PATH;\n            continue;\n          } break;\n\n        case RELATIVE_SLASH:\n          if (url.isSpecial() && (chr == '/' || chr == '\\\\')) {\n            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n          } else if (chr == '/') {\n            state = AUTHORITY;\n          } else {\n            url.username = base.username;\n            url.password = base.password;\n            url.host = base.host;\n            url.port = base.port;\n            state = PATH;\n            continue;\n          } break;\n\n        case SPECIAL_AUTHORITY_SLASHES:\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n          if (chr != '/' || charAt$3(buffer, pointer + 1) != '/') continue;\n          pointer++;\n          break;\n\n        case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n          if (chr != '/' && chr != '\\\\') {\n            state = AUTHORITY;\n            continue;\n          } break;\n\n        case AUTHORITY:\n          if (chr == '@') {\n            if (seenAt) buffer = '%40' + buffer;\n            seenAt = true;\n            bufferCodePoints = arrayFrom(buffer);\n            for (var i = 0; i < bufferCodePoints.length; i++) {\n              var codePoint = bufferCodePoints[i];\n              if (codePoint == ':' && !seenPasswordToken) {\n                seenPasswordToken = true;\n                continue;\n              }\n              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n              if (seenPasswordToken) url.password += encodedCodePoints;\n              else url.username += encodedCodePoints;\n            }\n            buffer = '';\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial())\n          ) {\n            if (seenAt && buffer == '') return INVALID_AUTHORITY;\n            pointer -= arrayFrom(buffer).length + 1;\n            buffer = '';\n            state = HOST;\n          } else buffer += chr;\n          break;\n\n        case HOST:\n        case HOSTNAME:\n          if (stateOverride && url.scheme == 'file') {\n            state = FILE_HOST;\n            continue;\n          } else if (chr == ':' && !seenBracket) {\n            if (buffer == '') return INVALID_HOST;\n            failure = url.parseHost(buffer);\n            if (failure) return failure;\n            buffer = '';\n            state = PORT;\n            if (stateOverride == HOSTNAME) return;\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial())\n          ) {\n            if (url.isSpecial() && buffer == '') return INVALID_HOST;\n            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;\n            failure = url.parseHost(buffer);\n            if (failure) return failure;\n            buffer = '';\n            state = PATH_START;\n            if (stateOverride) return;\n            continue;\n          } else {\n            if (chr == '[') seenBracket = true;\n            else if (chr == ']') seenBracket = false;\n            buffer += chr;\n          } break;\n\n        case PORT:\n          if (exec$1(DIGIT, chr)) {\n            buffer += chr;\n          } else if (\n            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||\n            (chr == '\\\\' && url.isSpecial()) ||\n            stateOverride\n          ) {\n            if (buffer != '') {\n              var port = parseInt(buffer, 10);\n              if (port > 0xFFFF) return INVALID_PORT;\n              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;\n              buffer = '';\n            }\n            if (stateOverride) return;\n            state = PATH_START;\n            continue;\n          } else return INVALID_PORT;\n          break;\n\n        case FILE:\n          url.scheme = 'file';\n          if (chr == '/' || chr == '\\\\') state = FILE_SLASH;\n          else if (base && base.scheme == 'file') {\n            if (chr == EOF) {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = base.query;\n            } else if (chr == '?') {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = '';\n              state = QUERY;\n            } else if (chr == '#') {\n              url.host = base.host;\n              url.path = arraySlice(base.path);\n              url.query = base.query;\n              url.fragment = '';\n              state = FRAGMENT;\n            } else {\n              if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {\n                url.host = base.host;\n                url.path = arraySlice(base.path);\n                url.shortenPath();\n              }\n              state = PATH;\n              continue;\n            }\n          } else {\n            state = PATH;\n            continue;\n          } break;\n\n        case FILE_SLASH:\n          if (chr == '/' || chr == '\\\\') {\n            state = FILE_HOST;\n            break;\n          }\n          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {\n            if (isWindowsDriveLetter(base.path[0], true)) push$1(url.path, base.path[0]);\n            else url.host = base.host;\n          }\n          state = PATH;\n          continue;\n\n        case FILE_HOST:\n          if (chr == EOF || chr == '/' || chr == '\\\\' || chr == '?' || chr == '#') {\n            if (!stateOverride && isWindowsDriveLetter(buffer)) {\n              state = PATH;\n            } else if (buffer == '') {\n              url.host = '';\n              if (stateOverride) return;\n              state = PATH_START;\n            } else {\n              failure = url.parseHost(buffer);\n              if (failure) return failure;\n              if (url.host == 'localhost') url.host = '';\n              if (stateOverride) return;\n              buffer = '';\n              state = PATH_START;\n            } continue;\n          } else buffer += chr;\n          break;\n\n        case PATH_START:\n          if (url.isSpecial()) {\n            state = PATH;\n            if (chr != '/' && chr != '\\\\') continue;\n          } else if (!stateOverride && chr == '?') {\n            url.query = '';\n            state = QUERY;\n          } else if (!stateOverride && chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            state = PATH;\n            if (chr != '/') continue;\n          } break;\n\n        case PATH:\n          if (\n            chr == EOF || chr == '/' ||\n            (chr == '\\\\' && url.isSpecial()) ||\n            (!stateOverride && (chr == '?' || chr == '#'))\n          ) {\n            if (isDoubleDot(buffer)) {\n              url.shortenPath();\n              if (chr != '/' && !(chr == '\\\\' && url.isSpecial())) {\n                push$1(url.path, '');\n              }\n            } else if (isSingleDot(buffer)) {\n              if (chr != '/' && !(chr == '\\\\' && url.isSpecial())) {\n                push$1(url.path, '');\n              }\n            } else {\n              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\n                if (url.host) url.host = '';\n                buffer = charAt$3(buffer, 0) + ':'; // normalize windows drive letter\n              }\n              push$1(url.path, buffer);\n            }\n            buffer = '';\n            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {\n              while (url.path.length > 1 && url.path[0] === '') {\n                shift(url.path);\n              }\n            }\n            if (chr == '?') {\n              url.query = '';\n              state = QUERY;\n            } else if (chr == '#') {\n              url.fragment = '';\n              state = FRAGMENT;\n            }\n          } else {\n            buffer += percentEncode(chr, pathPercentEncodeSet);\n          } break;\n\n        case CANNOT_BE_A_BASE_URL_PATH:\n          if (chr == '?') {\n            url.query = '';\n            state = QUERY;\n          } else if (chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);\n          } break;\n\n        case QUERY:\n          if (!stateOverride && chr == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          } else if (chr != EOF) {\n            if (chr == \"'\" && url.isSpecial()) url.query += '%27';\n            else if (chr == '#') url.query += '%23';\n            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);\n          } break;\n\n        case FRAGMENT:\n          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);\n          break;\n      }\n\n      pointer++;\n    }\n  },\n  // https://url.spec.whatwg.org/#host-parsing\n  parseHost: function (input) {\n    var result, codePoints, index;\n    if (charAt$3(input, 0) == '[') {\n      if (charAt$3(input, input.length - 1) != ']') return INVALID_HOST;\n      result = parseIPv6(stringSlice$3(input, 1, -1));\n      if (!result) return INVALID_HOST;\n      this.host = result;\n    // opaque host\n    } else if (!this.isSpecial()) {\n      if (exec$1(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;\n      result = '';\n      codePoints = arrayFrom(input);\n      for (index = 0; index < codePoints.length; index++) {\n        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n      }\n      this.host = result;\n    } else {\n      input = toASCII(input);\n      if (exec$1(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;\n      result = parseIPv4(input);\n      if (result === null) return INVALID_HOST;\n      this.host = result;\n    }\n  },\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  cannotHaveUsernamePasswordPort: function () {\n    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';\n  },\n  // https://url.spec.whatwg.org/#include-credentials\n  includesCredentials: function () {\n    return this.username != '' || this.password != '';\n  },\n  // https://url.spec.whatwg.org/#is-special\n  isSpecial: function () {\n    return hasOwn(specialSchemes, this.scheme);\n  },\n  // https://url.spec.whatwg.org/#shorten-a-urls-path\n  shortenPath: function () {\n    var path = this.path;\n    var pathSize = path.length;\n    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n      path.length--;\n    }\n  },\n  // https://url.spec.whatwg.org/#concept-url-serializer\n  serialize: function () {\n    var url = this;\n    var scheme = url.scheme;\n    var username = url.username;\n    var password = url.password;\n    var host = url.host;\n    var port = url.port;\n    var path = url.path;\n    var query = url.query;\n    var fragment = url.fragment;\n    var output = scheme + ':';\n    if (host !== null) {\n      output += '//';\n      if (url.includesCredentials()) {\n        output += username + (password ? ':' + password : '') + '@';\n      }\n      output += serializeHost(host);\n      if (port !== null) output += ':' + port;\n    } else if (scheme == 'file') output += '//';\n    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';\n    if (query !== null) output += '?' + query;\n    if (fragment !== null) output += '#' + fragment;\n    return output;\n  },\n  // https://url.spec.whatwg.org/#dom-url-href\n  setHref: function (href) {\n    var failure = this.parse(href);\n    if (failure) throw TypeError$1(failure);\n    this.searchParams.update();\n  },\n  // https://url.spec.whatwg.org/#dom-url-origin\n  getOrigin: function () {\n    var scheme = this.scheme;\n    var port = this.port;\n    if (scheme == 'blob') try {\n      return new URLConstructor(scheme.path[0]).origin;\n    } catch (error) {\n      return 'null';\n    }\n    if (scheme == 'file' || !this.isSpecial()) return 'null';\n    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');\n  },\n  // https://url.spec.whatwg.org/#dom-url-protocol\n  getProtocol: function () {\n    return this.scheme + ':';\n  },\n  setProtocol: function (protocol) {\n    this.parse($toString(protocol) + ':', SCHEME_START);\n  },\n  // https://url.spec.whatwg.org/#dom-url-username\n  getUsername: function () {\n    return this.username;\n  },\n  setUsername: function (username) {\n    var codePoints = arrayFrom($toString(username));\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    this.username = '';\n    for (var i = 0; i < codePoints.length; i++) {\n      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n    }\n  },\n  // https://url.spec.whatwg.org/#dom-url-password\n  getPassword: function () {\n    return this.password;\n  },\n  setPassword: function (password) {\n    var codePoints = arrayFrom($toString(password));\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    this.password = '';\n    for (var i = 0; i < codePoints.length; i++) {\n      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n    }\n  },\n  // https://url.spec.whatwg.org/#dom-url-host\n  getHost: function () {\n    var host = this.host;\n    var port = this.port;\n    return host === null ? ''\n      : port === null ? serializeHost(host)\n      : serializeHost(host) + ':' + port;\n  },\n  setHost: function (host) {\n    if (this.cannotBeABaseURL) return;\n    this.parse(host, HOST);\n  },\n  // https://url.spec.whatwg.org/#dom-url-hostname\n  getHostname: function () {\n    var host = this.host;\n    return host === null ? '' : serializeHost(host);\n  },\n  setHostname: function (hostname) {\n    if (this.cannotBeABaseURL) return;\n    this.parse(hostname, HOSTNAME);\n  },\n  // https://url.spec.whatwg.org/#dom-url-port\n  getPort: function () {\n    var port = this.port;\n    return port === null ? '' : $toString(port);\n  },\n  setPort: function (port) {\n    if (this.cannotHaveUsernamePasswordPort()) return;\n    port = $toString(port);\n    if (port == '') this.port = null;\n    else this.parse(port, PORT);\n  },\n  // https://url.spec.whatwg.org/#dom-url-pathname\n  getPathname: function () {\n    var path = this.path;\n    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';\n  },\n  setPathname: function (pathname) {\n    if (this.cannotBeABaseURL) return;\n    this.path = [];\n    this.parse(pathname, PATH_START);\n  },\n  // https://url.spec.whatwg.org/#dom-url-search\n  getSearch: function () {\n    var query = this.query;\n    return query ? '?' + query : '';\n  },\n  setSearch: function (search) {\n    search = $toString(search);\n    if (search == '') {\n      this.query = null;\n    } else {\n      if ('?' == charAt$3(search, 0)) search = stringSlice$3(search, 1);\n      this.query = '';\n      this.parse(search, QUERY);\n    }\n    this.searchParams.update();\n  },\n  // https://url.spec.whatwg.org/#dom-url-searchparams\n  getSearchParams: function () {\n    return this.searchParams.facade;\n  },\n  // https://url.spec.whatwg.org/#dom-url-hash\n  getHash: function () {\n    var fragment = this.fragment;\n    return fragment ? '#' + fragment : '';\n  },\n  setHash: function (hash) {\n    hash = $toString(hash);\n    if (hash == '') {\n      this.fragment = null;\n      return;\n    }\n    if ('#' == charAt$3(hash, 0)) hash = stringSlice$3(hash, 1);\n    this.fragment = '';\n    this.parse(hash, FRAGMENT);\n  },\n  update: function () {\n    this.query = this.searchParams.serialize() || null;\n  }\n};\n\n// `URL` constructor\n// https://url.spec.whatwg.org/#url-class\nvar URLConstructor = function URL(url /* , base */) {\n  var that = anInstance(this, URLPrototype);\n  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;\n  var state = setInternalState(that, new URLState(url, false, base));\n  if (!DESCRIPTORS) {\n    that.href = state.serialize();\n    that.origin = state.getOrigin();\n    that.protocol = state.getProtocol();\n    that.username = state.getUsername();\n    that.password = state.getPassword();\n    that.host = state.getHost();\n    that.hostname = state.getHostname();\n    that.port = state.getPort();\n    that.pathname = state.getPathname();\n    that.search = state.getSearch();\n    that.searchParams = state.getSearchParams();\n    that.hash = state.getHash();\n  }\n};\n\nvar URLPrototype = URLConstructor.prototype;\n\nvar accessorDescriptor = function (getter, setter) {\n  return {\n    get: function () {\n      return getInternalURLState(this)[getter]();\n    },\n    set: setter && function (value) {\n      return getInternalURLState(this)[setter](value);\n    },\n    configurable: true,\n    enumerable: true\n  };\n};\n\nif (DESCRIPTORS) {\n  // `URL.prototype.href` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-href\n  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));\n  // `URL.prototype.origin` getter\n  // https://url.spec.whatwg.org/#dom-url-origin\n  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));\n  // `URL.prototype.protocol` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-protocol\n  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));\n  // `URL.prototype.username` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-username\n  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));\n  // `URL.prototype.password` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-password\n  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));\n  // `URL.prototype.host` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-host\n  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));\n  // `URL.prototype.hostname` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-hostname\n  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));\n  // `URL.prototype.port` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-port\n  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));\n  // `URL.prototype.pathname` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-pathname\n  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));\n  // `URL.prototype.search` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-search\n  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));\n  // `URL.prototype.searchParams` getter\n  // https://url.spec.whatwg.org/#dom-url-searchparams\n  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));\n  // `URL.prototype.hash` accessors pair\n  // https://url.spec.whatwg.org/#dom-url-hash\n  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));\n}\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\ndefineBuiltIn$1(URLPrototype, 'toJSON', function toJSON() {\n  return getInternalURLState(this).serialize();\n}, { enumerable: true });\n\n// `URL.prototype.toString` method\n// https://url.spec.whatwg.org/#URL-stringification-behavior\ndefineBuiltIn$1(URLPrototype, 'toString', function toString() {\n  return getInternalURLState(this).serialize();\n}, { enumerable: true });\n\nif (NativeURL) {\n  var nativeCreateObjectURL = NativeURL.createObjectURL;\n  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n  // `URL.createObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n  if (nativeCreateObjectURL) defineBuiltIn$1(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));\n  // `URL.revokeObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n  if (nativeRevokeObjectURL) defineBuiltIn$1(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));\n}\n\nsetToStringTag(URLConstructor, 'URL');\n\n$$1({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {\n  URL: URLConstructor\n});\n\nvar fails$4 = fails$k;\nvar global$3 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$3.RegExp;\n\nvar UNSUPPORTED_Y$1 = fails$4(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$1\n};\n\nvar fails$3 = fails$k;\nvar global$2 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$2.RegExp;\n\nvar regexpUnsupportedDotAll = fails$3(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$2 = fails$k;\nvar global$1 = global$o;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$1.RegExp;\n\nvar regexpUnsupportedNcg = fails$2(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$2 = functionCall;\nvar uncurryThis$3 = functionUncurryThis;\nvar toString$1 = toString$4;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create = objectCreate;\nvar getInternalState = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$3(''.charAt);\nvar indexOf = uncurryThis$3(''.indexOf);\nvar replace$1 = uncurryThis$3(''.replace);\nvar stringSlice$2 = uncurryThis$3(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$2(nativeExec, re1, 'a');\n  call$2(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState(re);\n    var str = toString$1(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$2(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y && re.sticky;\n    var flags = call$2(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace$1(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$2(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$2(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$2 = patchedExec;\n\nvar $ = _export;\nvar exec = regexpExec$2;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\n  exec: exec\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$a;\nvar regexpExec$1 = regexpExec$2;\nvar fails$1 = fails$k;\nvar wellKnownSymbol$1 = wellKnownSymbol$i;\nvar createNonEnumerableProperty = createNonEnumerableProperty$5;\n\nvar SPECIES = wellKnownSymbol$1('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol$1(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar charAt$1 = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt$1(S, index).length : 1);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toObject = toObject$5;\n\nvar floor = Math.floor;\nvar charAt = uncurryThis$1(''.charAt);\nvar replace = uncurryThis$1(''.replace);\nvar stringSlice$1 = uncurryThis$1(''.slice);\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n\n// `GetSubstitution` abstract operation\n// https://tc39.es/ecma262/#sec-getsubstitution\nvar getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (charAt(ch, 0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return stringSlice$1(str, 0, position);\n      case \"'\": return stringSlice$1(str, tailPos);\n      case '<':\n        capture = namedCaptures[stringSlice$1(ch, 1, -1)];\n        break;\n      default: // \\d\\d?\n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$g;\nvar isCallable$1 = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec = regexpExec$2;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable$1(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar fails = fails$k;\nvar anObject = anObject$g;\nvar isCallable = isCallable$n;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar toLength = toLength$2;\nvar toString = toString$4;\nvar requireObjectCoercible = requireObjectCoercible$4;\nvar advanceStringIndex = advanceStringIndex$1;\nvar getMethod = getMethod$4;\nvar getSubstitution = getSubstitution$1;\nvar regExpExec = regexpExecAbstract;\nvar wellKnownSymbol = wellKnownSymbol$i;\n\nvar REPLACE = wellKnownSymbol('replace');\nvar max = Math.max;\nvar min = Math.min;\nvar concat = uncurryThis([].concat);\nvar push = uncurryThis([].push);\nvar stringIndexOf = uncurryThis(''.indexOf);\nvar stringSlice = uncurryThis(''.slice);\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);\n      return replacer\n        ? call(replacer, searchValue, O, replaceValue)\n        : call(nativeReplace, toString(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n    function (string, replaceValue) {\n      var rx = anObject(this);\n      var S = toString(string);\n\n      if (\n        typeof replaceValue == 'string' &&\n        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&\n        stringIndexOf(replaceValue, '$<') === -1\n      ) {\n        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var functionalReplace = isCallable(replaceValue);\n      if (!functionalReplace) replaceValue = toString(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        push(results, result);\n        if (!global) break;\n\n        var matchStr = toString(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = toString(result[0]);\n        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = concat([matched], captures, position, S);\n          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);\n          var replacement = toString(apply(replaceValue, undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + stringSlice(S, nextSourcePosition);\n    }\n  ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar icon = `data:image/png;base64,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`;\n\nconst resolveWalletUrl = (network, walletUrl) => {\n  if (walletUrl) {\n    return walletUrl;\n  }\n  switch (network.networkId) {\n    case \"mainnet\":\n      return \"https://app.mynearwallet.com\";\n    case \"testnet\":\n      return \"https://testnet.mynearwallet.com\";\n    default:\n      throw new Error(\"Invalid wallet url\");\n  }\n};\nconst setupWalletState = (params, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const keyStore = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.keyStores.BrowserLocalStorageKeyStore();\n  const near = yield near_api_js__WEBPACK_IMPORTED_MODULE_0__.connect(Object.assign(Object.assign({\n    keyStore,\n    walletUrl: params.walletUrl\n  }, network), {\n    headers: {}\n  }));\n  const wallet = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.WalletConnection(near, \"near_app\");\n  return {\n    wallet,\n    keyStore\n  };\n});\nconst MyNearWallet = ({\n  metadata,\n  options,\n  store,\n  params,\n  logger,\n  id\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const _state = yield setupWalletState(params, options.network);\n  const getAccounts = () => __awaiter(void 0, void 0, void 0, function* () {\n    const accountId = _state.wallet.getAccountId();\n    const account = _state.wallet.account();\n    if (!accountId || !account) {\n      return [];\n    }\n    const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);\n    return [{\n      accountId,\n      publicKey: publicKey ? publicKey.toString() : \"\"\n    }];\n  });\n  const transformTransactions = transactions => __awaiter(void 0, void 0, void 0, function* () {\n    const account = _state.wallet.account();\n    const {\n      networkId,\n      signer,\n      provider\n    } = account.connection;\n    const localKey = yield signer.getPublicKey(account.accountId, networkId);\n    return Promise.all(transactions.map((transaction, index) => __awaiter(void 0, void 0, void 0, function* () {\n      const actions = transaction.actions.map(action => (0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action));\n      const accessKey = yield account.accessKeyForTransaction(transaction.receiverId, actions, localKey);\n      if (!accessKey) {\n        throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);\n      }\n      const block = yield provider.block({\n        finality: \"final\"\n      });\n      return near_api_js__WEBPACK_IMPORTED_MODULE_0__.transactions.createTransaction(account.accountId, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(accessKey.public_key), transaction.receiverId, accessKey.access_key.nonce + index + 1, actions, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.serialize.base_decode(block.header.hash));\n    })));\n  });\n  return {\n    signIn({\n      contractId,\n      methodNames,\n      successUrl,\n      failureUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const existingAccounts = yield getAccounts();\n        if (existingAccounts.length) {\n          return existingAccounts;\n        }\n        yield _state.wallet.requestSignIn({\n          contractId,\n          methodNames,\n          successUrl,\n          failureUrl\n        });\n        return getAccounts();\n      });\n    },\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (_state.wallet.isSignedIn()) {\n          _state.wallet.signOut();\n        }\n      });\n    },\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return getAccounts();\n      });\n    },\n    verifyOwner() {\n      return __awaiter(this, void 0, void 0, function* () {\n        throw new Error(`Method not supported by ${metadata.name}`);\n      });\n    },\n    signMessage({\n      message,\n      nonce,\n      recipient,\n      callbackUrl,\n      state\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"sign message\", {\n          message\n        });\n        if (id !== \"my-near-wallet\") {\n          throw Error(`The signMessage method is not supported by ${metadata.name}`);\n        }\n        const locationUrl = typeof window !== \"undefined\" ? window.location.href : \"\";\n        const url = callbackUrl || locationUrl;\n        if (!url) {\n          throw new Error(`The callbackUrl is missing for ${metadata.name}`);\n        }\n        const href = new URL(params.walletUrl);\n        href.pathname = \"sign-message\";\n        href.searchParams.append(\"message\", message);\n        href.searchParams.append(\"nonce\", nonce.toString());\n        href.searchParams.append(\"recipient\", recipient);\n        href.searchParams.append(\"callbackUrl\", url);\n        if (state) {\n          href.searchParams.append(\"state\", state);\n        }\n        window.location.replace(href.toString());\n        return;\n      });\n    },\n    signAndSendTransaction({\n      signerId,\n      receiverId,\n      actions,\n      callbackUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"signAndSendTransaction\", {\n          signerId,\n          receiverId,\n          actions,\n          callbackUrl\n        });\n        const {\n          contract\n        } = store.getState();\n        if (!_state.wallet.isSignedIn() || !contract) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        const account = _state.wallet.account();\n        return account[\"signAndSendTransaction\"]({\n          receiverId: receiverId || contract.contractId,\n          actions: actions.map(action => (0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action)),\n          walletCallbackUrl: callbackUrl\n        });\n      });\n    },\n    signAndSendTransactions({\n      transactions,\n      callbackUrl\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"signAndSendTransactions\", {\n          transactions,\n          callbackUrl\n        });\n        if (!_state.wallet.isSignedIn()) {\n          throw new Error(\"Wallet not signed in\");\n        }\n        return _state.wallet.requestSignTransactions({\n          transactions: yield transformTransactions(transactions),\n          callbackUrl\n        });\n      });\n    },\n    buildImportAccountsUrl() {\n      return `${params.walletUrl}/batch-import`;\n    }\n  };\n});\nfunction setupMyNearWallet({\n  walletUrl,\n  iconUrl = icon,\n  deprecated = false,\n  successUrl = \"\",\n  failureUrl = \"\"\n} = {}) {\n  return moduleOptions => __awaiter(this, void 0, void 0, function* () {\n    return {\n      id: \"my-near-wallet\",\n      type: \"browser\",\n      metadata: {\n        name: \"MyNearWallet\",\n        description: \"NEAR wallet to store, buy, send and stake assets for DeFi.\",\n        iconUrl,\n        deprecated,\n        available: true,\n        successUrl,\n        failureUrl,\n        walletUrl: resolveWalletUrl(moduleOptions.options.network, walletUrl)\n      },\n      init: options => {\n        return MyNearWallet(Object.assign(Object.assign({}, options), {\n          params: {\n            walletUrl: resolveWalletUrl(options.options.network, walletUrl)\n          }\n        }));\n      }\n    };\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL215LW5lYXItd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUMyQjs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLG1CQUFtQixhQUFhO0FBQ3hFLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxNQUFNOztBQUVwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUx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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG1FQUFtRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLGtCQUFrQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSw4RUFBOEU7QUFDcEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDBEQUEwRDtBQUM5RDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QyxrREFBa0QsSUFBSTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0YmFzZW1pbnQvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL215LW5lYXItd2FsbGV0L2luZGV4LmpzPzlkZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICdAbmVhci13YWxsZXQtc2VsZWN0b3Ivd2FsbGV0LXV0aWxzJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkbyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRrID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRqID0gZmFpbHMkaztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRqKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJGkgPSBmYWlscyRrO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJGkoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGsgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGsuYmluZChjYWxsJGspIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRrLmFwcGx5KGNhbGwkaywgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDModGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJDggPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRqID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJG0gPSBOQVRJVkVfQklORCQyICYmIGJpbmQkOC5iaW5kKGNhbGwkaiwgY2FsbCRqKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRtKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRqLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckNiA9IHVuY3VycnlUaGlzJGwoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDYgPSB1bmN1cnJ5VGhpcyRsKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkNih0b1N0cmluZyQ2KGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGsgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGggPSBmYWlscyRrO1xudmFyIGNsYXNzb2YkNyA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCQzID0gdW5jdXJyeVRoaXMkaygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkNyhpdCkgPT0gJ1N0cmluZycgPyBzcGxpdCQzKGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkYyhcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMoaXQpKTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRtID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgaXNPYmplY3QkOCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJG0oaXQpO1xufTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJG87XG52YXIgaXNDYWxsYWJsZSRsID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGwoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkbltuYW1lc3BhY2VdKSA6IGdsb2JhbCRuW25hbWVzcGFjZV0gJiYgZ2xvYmFsJG5bbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJGooe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDcgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDcoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCRtID0gZ2xvYmFsJG87XG52YXIgdXNlckFnZW50JDMgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzJDMgPSBnbG9iYWwkbS5wcm9jZXNzO1xudmFyIERlbm8kMSA9IGdsb2JhbCRtLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzJDMgJiYgcHJvY2VzcyQzLnZlcnNpb25zIHx8IERlbm8kMSAmJiBEZW5vJDEudmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDMpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgVjhfVkVSU0lPTiQxID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJGcgPSBmYWlscyRrO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyRnKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OJDEgJiYgVjhfVkVSU0lPTiQxIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQxXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkayA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcblxudmFyIGlzU3ltYm9sJDIgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaygkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDMoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMyhpdCkpO1xufTtcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQzKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGogPSBpc0NhbGxhYmxlJG47XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkaihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciRiKHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkNCA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkaSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGkgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkNyA9IGlzT2JqZWN0JDg7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNyh2YWwgPSBjYWxsJGkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNyh2YWwgPSBjYWxsJGkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDcodmFsID0gY2FsbCRpKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJGEoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaXNQdXJlID0gZmFsc2U7XG5cbnZhciBnbG9iYWwkbCA9IGdsb2JhbCRvO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ2KGdsb2JhbCRsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGsgPSBnbG9iYWwkbztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwka1tTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMihhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCQ1O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRpKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQ0KGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ1ID0gdW5jdXJyeVRoaXMkaCgxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckNSgrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCRqID0gZ2xvYmFsJG87XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRjID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRqLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDE7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biRjKFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCRoID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCQ4O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCQzID0gZ2V0TWV0aG9kJDQ7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgJFR5cGVFcnJvciQ5ID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQ2KGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDMoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkaChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDYocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQ5KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRvO1xudmFyIGlzT2JqZWN0JDUgPSBpc09iamVjdCQ4O1xuXG52YXIgZG9jdW1lbnQkMyA9IGdsb2JhbCRpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCQ1KGRvY3VtZW50JDMpICYmIGlzT2JqZWN0JDUoZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkZiA9IGZhaWxzJGs7XG52YXIgY3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRjICYmICFmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCQxKCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkZyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvUHJvcGVydHlLZXkkMiA9IHRvUHJvcGVydHlLZXkkMztcbnZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGIgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biRiKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkZyhwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGUgPSBmYWlscyRrO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGEgJiYgZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDg7XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkZyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkNChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ4KCRTdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JGYgPSBhbk9iamVjdCRnO1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMztcblxudmFyICRUeXBlRXJyb3IkNyA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDkgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRmKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRmKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRmKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRmKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yJDcoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IERFU0NSSVBUT1JTJDggPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIG1ha2VCdWlsdEluJDMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkNyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJGEoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkNyB8fCAoREVTQ1JJUFRPUlMkNyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJG47XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGcoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkaChzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkNCA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCRoID0gZ2xvYmFsJG87XG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRuO1xudmFyIGluc3BlY3RTb3VyY2UkMyA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCRoLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSRnKFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMyhXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQyID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkbztcbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkODtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1O1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQ0ID0gZ2xvYmFsJGcuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkZy5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMyhpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDQoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRmKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGYoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkZihzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQ0KE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQyKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ5KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkNChPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyRkID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQ2ICYmICFmYWlscyRkKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDUoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IG1ha2VCdWlsdEluJDMuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDgodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkNikgZGVmaW5lUHJvcGVydHkkNSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ4KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDUodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDgob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDYpIGRlZmluZVByb3BlcnR5JDUodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDgoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDIoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGYodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDMuZXhwb3J0cztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIGRlZmluZUJ1aWx0SW4kYSA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSRlKHZhbHVlKSkgbWFrZUJ1aWx0SW4kMSh2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQ0ID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDQgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG5cbnZhciBtYXgkMiA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQzKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDIoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkMSA9IHRvTGVuZ3RoJDI7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDEob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMShmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDEodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDEoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgaW5kZXhPZiQxID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkNCA9IHVuY3VycnlUaGlzJGUoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDcoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ3KE8sIGtleSkgJiYgcHVzaCQ0KHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ3KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMShyZXN1bHQsIGtleSkgfHwgcHVzaCQ0KHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGUgPSBhbk9iamVjdCRnO1xuXG52YXIgY29uY2F0JDIgPSB1bmN1cnJ5VGhpcyRkKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkZShpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQyKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kNih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQ2KGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkYyA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSRkID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMiA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSRkKGRldGVjdGlvbikgPyBmYWlscyRjKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDIubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQyLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQyLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDIuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMjtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJG87XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1O1xudmFyIGRlZmluZUJ1aWx0SW4kOSA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMTtcbnZhciBpc0ZvcmNlZCQxID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCRmO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCRmW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCRmW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQkMShHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4kOSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJGYgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkYiA9IGZhaWxzJGs7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCQ1O1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRjKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkNSAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDQoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQ0KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzJDEoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkMyh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKG9iamVjdEtleXMkMShTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMkMShTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkNSB8fCBjYWxsJGYocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkYSA9IF9leHBvcnQ7XG52YXIgYXNzaWduJDEgPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCRhKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduJDEgfSwge1xuICBhc3NpZ246IGFzc2lnbiQxXG59KTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkZygndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkZigndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQ2ID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QkMShpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSRjKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIGNsYXNzb2YkNSA9IGNsYXNzb2YkNjtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YkNShhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nJDEoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JGQgPSBhbk9iamVjdCRnO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCRkKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FsbCRlID0gZnVuY3Rpb25DYWxsO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcblxudmFyIFJlZ0V4cFByb3RvdHlwZSQyID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIHJlZ2V4cEdldEZsYWdzID0gZnVuY3Rpb24gKFIpIHtcbiAgdmFyIGZsYWdzID0gUi5mbGFncztcbiAgcmV0dXJuIGZsYWdzID09PSB1bmRlZmluZWQgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSQyKSAmJiAhaGFzT3duJDUoUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZiQyKFJlZ0V4cFByb3RvdHlwZSQyLCBSKVxuICAgID8gY2FsbCRlKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4kOCA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBhbk9iamVjdCRjID0gYW5PYmplY3QkZztcbnZhciAkdG9TdHJpbmckMiA9IHRvU3RyaW5nJDQ7XG52YXIgZmFpbHMkYSA9IGZhaWxzJGs7XG52YXIgZ2V0UmVnRXhwRmxhZ3MgPSByZWdleHBHZXRGbGFncztcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGUkMVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4kVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluJDgoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0JGModGhpcyk7XG4gICAgdmFyIHBhdHRlcm4gPSAkdG9TdHJpbmckMihSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nJDIoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRnO1xudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDQgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDEoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ0KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cblxudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRnO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ0O1xudmFyIGh0bWwkMSA9IGh0bWwkMjtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwkMS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPJDFdID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QkYShPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgY3JlYXRlJDMgPSBvYmplY3RDcmVhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCRlKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eSQzKEFycmF5UHJvdG90eXBlJDEsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUkMyhudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciBmYWlscyQ5ID0gZmFpbHMkaztcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJG47XG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JDU7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDM7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDIoTyk7XG4gIGlmIChoYXNPd24kNChvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkYihjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cbnZhciBmYWlscyQ4ID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJG47XG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIGRlZmluZUJ1aWx0SW4kNyA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkNyA9IHdlbGxLbm93blN5bWJvbCRkKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMiwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDEoZ2V0UHJvdG90eXBlT2YkMShhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlJDIgPT0gdW5kZWZpbmVkIHx8IGZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkN10uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUkYShJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDddKSkge1xuICBkZWZpbmVCdWlsdEluJDcoSXRlcmF0b3JQcm90b3R5cGUkMiwgSVRFUkFUT1IkNywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQyLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCRjKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNSA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMih0YXJnZXQsIFRPX1NUUklOR19UQUckMSwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSQxID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUkMiA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHNldFRvU3RyaW5nVGFnJDQgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMiA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlJDIoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDQoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UpO1xuICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkOShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ2KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyhhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZztcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkYihPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkOShPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciBjYWxsJGQgPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbjtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDI7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciBkZWZpbmVCdWlsdEluJDYgPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkaTtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNiA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMiA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDZdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YkMSkge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUkOChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkNl0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbiQ2KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkNiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJGQobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDYoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ5KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kNihJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMTtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDQgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBkZWZpbmVJdGVyYXRvciQyO1xudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDEoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDQodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG52YXIgdmFsdWVzID0gSXRlcmF0b3JzJDIuQXJndW1lbnRzID0gSXRlcmF0b3JzJDIuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoREVTQ1JJUFRPUlMkMyAmJiB2YWx1ZXMubmFtZSAhPT0gJ3ZhbHVlcycpIHRyeSB7XG4gIGRlZmluZVByb3BlcnR5JDEodmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCRlID0gZ2xvYmFsJG87XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDQoZ2xvYmFsJGUucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCRhKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMkMiAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFUyQzXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTJDMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDEoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDcgPSBmYWlscyRrO1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mJDMgPSBjbGFzc29mJDY7XG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDIoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMyA9IHVuY3VycnlUaGlzJGEoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQzKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQzKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlJDEoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQyID0gIWNvbnN0cnVjdCB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIGlzQ29uc3RydWN0b3IkMSA9IGlzQ29uc3RydWN0b3IkMjtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNDtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3RvciQxKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGc7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDkgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ5KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ4KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDgoQylbU1BFQ0lFUyQyXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQyID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCRjID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJGMuYmluZChhcHBseSQyKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkYy5hcHBseShhcHBseSQyLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ3ID0gdW5jdXJyeVRoaXMkOSh1bmN1cnJ5VGhpcyQ5LmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDcoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGFycmF5U2xpY2UkMyA9IHVuY3VycnlUaGlzJDgoW10uc2xpY2UpO1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMyA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgJFR5cGVFcnJvciQzKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJb3MgPSAvKD86aXBhZHxpcGhvbmV8aXBvZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkZCA9IGdsb2JhbCRvO1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkNiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRuO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQ2ID0gZmFpbHMkaztcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2UkMztcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMiA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDM7XG52YXIgSVNfSU9TJDEgPSBlbmdpbmVJc0lvcztcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBzZXQgPSBnbG9iYWwkZC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkZC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkZC5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJGQuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRkLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJGQuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkZC5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJGQubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQyKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJGQucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoaGFuZGxlcikge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDIoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQ2KGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlJDIoYXJndW1lbnRzLCAxKTtcbiAgICBxdWV1ZSQxWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseSQxKGZuLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSQyKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MkMi5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgLy8gZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82MjRcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TJDEpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQkNihwb3J0LnBvc3RNZXNzYWdlLCBwb3J0KTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsJGQuYWRkRXZlbnRMaXN0ZW5lciAmJlxuICAgIGlzQ2FsbGFibGUkNihnbG9iYWwkZC5wb3N0TWVzc2FnZSkgJiZcbiAgICAhZ2xvYmFsJGQuaW1wb3J0U2NyaXB0cyAmJlxuICAgIGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgIWZhaWxzJDYocG9zdClcbiAgKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbCRkLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkbztcblxudmFyIGVuZ2luZUlzSW9zUGViYmxlID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCQxKSAmJiBnbG9iYWwkYy5QZWJibGUgIT09IHVuZGVmaW5lZDtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzV2Vib3NXZWJraXQgPSAvd2ViMHMoPyEuKmNocm9tZSkvaS50ZXN0KHVzZXJBZ2VudCk7XG5cbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRvO1xudmFyIGJpbmQkNSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkYi5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCRiLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCRiLmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCRiLnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJGIuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShnbG9iYWwkYiwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSQxLCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFJDEgJiYgKHBhcmVudCA9IHByb2Nlc3MkMS5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkkMSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIC8vIGFsc28gZXhjZXB0IFdlYk9TIFdlYmtpdCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODk4XG4gIGlmICghSVNfSU9TICYmICFJU19OT0RFJDEgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50JDIpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudCQyLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZSQxICYmIFByb21pc2UkMS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAvLyB3b3JrYXJvdW5kIG9mIFdlYktpdCB+IGlPUyBTYWZhcmkgMTAuMSBidWdcbiAgICBwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZSQxO1xuICAgIHRoZW4gPSBiaW5kJDUocHJvbWlzZS50aGVuLCBwcm9taXNlKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUkMSkge1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdlXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5iaW5kKGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kJDUobWFjcm90YXNrLCBnbG9iYWwkYik7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1pY3JvdGFzayQxID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5JDEoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cbnZhciBnbG9iYWwkYSA9IGdsb2JhbCRvO1xuXG52YXIgaG9zdFJlcG9ydEVycm9ycyQxID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwkYS5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG5cbnZhciBwZXJmb3JtJDMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxudmFyIFF1ZXVlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG59O1xuXG5RdWV1ZSQxLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBlbnRyeSA9IHsgaXRlbTogaXRlbSwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV4dDtcbiAgICAgIGlmICh0aGlzLnRhaWwgPT09IGVudHJ5KSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW07XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUgPSBRdWV1ZSQxO1xuXG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkbztcblxudmFyIHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCQ5LlByb21pc2U7XG5cbnZhciBlbmdpbmVJc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHR5cGVvZiBEZW5vICE9ICdvYmplY3QnO1xuXG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkbztcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkaTtcbnZhciBJU19CUk9XU0VSID0gZW5naW5lSXNCcm93c2VyO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG5cbk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzLnByb3RvdHlwZTtcbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkOCgnc3BlY2llcycpO1xudmFyIFNVQkNMQVNTSU5HID0gZmFsc2U7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEgPSBpc0NhbGxhYmxlJDUoZ2xvYmFsJDguUHJvbWlzZVJlamVjdGlvbkV2ZW50KTtcblxudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUgPSBpc0ZvcmNlZCgnUHJvbWlzZScsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFID0gaW5zcGVjdFNvdXJjZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIC8vIFY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gIC8vIFdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gIGlmICghR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBWOF9WRVJTSU9OID09PSA2NikgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBuZXcgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSgxKTsgfSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFUyQxXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkbztcbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkODtcbnZhciBhbkluc3RhbmNlJDIgPSBhbkluc3RhbmNlJDM7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDE7XG52YXIgdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgbWljcm90YXNrID0gbWljcm90YXNrJDE7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IGhvc3RSZXBvcnRFcnJvcnMkMTtcbnZhciBwZXJmb3JtJDIgPSBwZXJmb3JtJDM7XG52YXIgUXVldWUgPSBxdWV1ZTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJDcuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkNy5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDcucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkNy5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMihpdCkgJiYgaXNDYWxsYWJsZSQ0KHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQzKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkYih0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDcuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkN1snb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJGIodGFzaywgZ2xvYmFsJDcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkYih0YXNrLCBnbG9iYWwkNywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDQgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDMoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJGIodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDQoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDQoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSQyKHRoaXMsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIGFDYWxsYWJsZSQzKGV4ZWN1dG9yKTtcbiAgICBjYWxsJGIoSW50ZXJuYWwsIHRoaXMpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kJDQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSksIGJpbmQkNChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMsIHtcbiAgICAgIHR5cGU6IFBST01JU0UsXG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgICAgIHBhcmVudDogZmFsc2UsXG4gICAgICByZWFjdGlvbnM6IG5ldyBRdWV1ZSgpLFxuICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgICAgIHN0YXRlOiBQRU5ESU5HLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gIEludGVybmFsLnByb3RvdHlwZSA9IGRlZmluZUJ1aWx0SW4kNShQcm9taXNlUHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQ0KG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQ0KG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBQRU5ESU5HKSBzdGF0ZS5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICBlbHNlIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQkNChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQkNChpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuICB9O1xuXG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQ0KE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLnRoZW47XG5cbiAgICBpZiAoIU5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HKSB7XG4gICAgICAvLyBtYWtlIGBQcm9taXNlI3RoZW5gIHJldHVybiBhIHBvbHlmaWxsZWQgYFByb21pc2VgIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgICBkZWZpbmVCdWlsdEluJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY2FsbCRiKG5hdGl2ZVRoZW4sIHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY0MFxuICAgICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBgLmNvbnN0cnVjdG9yID09PSBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEuY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgLy8gbWFrZSBgaW5zdGFuY2VvZiBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBzZXRQcm90b3R5cGVPZihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJDgoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyQyKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sJDcoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDVdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiQ2O1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDQ7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJDYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QkMihpdCwgSVRFUkFUT1IkNClcbiAgICB8fCBnZXRNZXRob2QkMihpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mJDIoaXQpXTtcbn07XG5cbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkZztcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQzID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDMgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQzKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ3KGNhbGwkYShpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQyKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGc7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkNDtcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMiA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ2KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkOShpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDYoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYmluZCQzID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGc7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDQ7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IkMiA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG52YXIgaXRlcmF0b3JDbG9zZSQxID0gaXRlcmF0b3JDbG9zZSQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG52YXIgaXRlcmF0ZSQyID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQkMyh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZSQxKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkNSh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kJDIoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyAkVHlwZUVycm9yJDEodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QkMShpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbCQ4KG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UkMShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDNdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCQ3KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMShDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkNygkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiRhO1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4vLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuJCQ2KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIsIHJlYWw6IHRydWUgfSwge1xuICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgfVxufSk7XG5cbi8vIG1ha2VzIHN1cmUgdGhhdCBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzIGBQcm9taXNlI2NhdGNoYCBwcm9wZXJseSB3b3JrcyB3aXRoIHBhdGNoZWQgYFByb21pc2UjdGhlbmBcbmlmIChpc0NhbGxhYmxlJDMoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQ0KE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJDUoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkNigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkNCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkNShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRnO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCQ4O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQ0KEMpO1xuICBpZiAoaXNPYmplY3QkMSh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQkMyh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuLy8gaW4gb2xkIFdlYktpdCB2ZXJzaW9ucywgYGVsZW1lbnQuY2xhc3NMaXN0YCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgZ2xvYmFsIGBET01Ub2tlbkxpc3RgXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbnZhciBjbGFzc0xpc3QgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NwYW4nKS5jbGFzc0xpc3Q7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBkb21Ub2tlbkxpc3RQcm90b3R5cGUgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IERPTVRva2VuTGlzdFByb3RvdHlwZSQxO1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkbztcbnZhciBET01JdGVyYWJsZXMgPSBkb21JdGVyYWJsZXM7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gZG9tVG9rZW5MaXN0UHJvdG90eXBlO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gZXNfYXJyYXlfaXRlcmF0b3I7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCQ0KCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkNCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQyXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiQyLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkMl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsJDZbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWwkNltDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNDtcblxudmFyIGNoYXJBdCQ2ID0gdW5jdXJyeVRoaXMkNygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQkMSA9IHVuY3VycnlUaGlzJDcoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UkNSA9IHVuY3VycnlUaGlzJDcoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDEocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdCQ2KFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UkNShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxuICAgICAgICAgIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgY2hhckF0JDUgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQyO1xuXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiB0b1N0cmluZyQyKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQkNShzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxudmFyIGZhaWxzJDUgPSBmYWlscyRrO1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSVNfUFVSRSA9IGlzUHVyZTtcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnaXRlcmF0b3InKTtcblxudmFyIG5hdGl2ZVVybCA9ICFmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcmVsYXRpdmUtdXJsLXN0eWxlIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciB1cmwgPSBuZXcgVVJMKCdiP2E9MSZiPTImYz0zJywgJ2h0dHA6Ly9hJyk7XG4gIHZhciBzZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgc2VhcmNoUGFyYW1zWydkZWxldGUnXSgnYicpO1xuICAgIHJlc3VsdCArPSBrZXkgKyB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiAoSVNfUFVSRSAmJiAhdXJsLnRvSlNPTilcbiAgICB8fCAhc2VhcmNoUGFyYW1zLnNvcnRcbiAgICB8fCB1cmwuaHJlZiAhPT0gJ2h0dHA6Ly9hL2MlMjBkP2E9MSZjPTMnXG4gICAgfHwgc2VhcmNoUGFyYW1zLmdldCgnYycpICE9PSAnMydcbiAgICB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MSdcbiAgICB8fCAhc2VhcmNoUGFyYW1zW0lURVJBVE9SJDFdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcblxudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMy5leHBvcnRzO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLmdldCwgbmFtZSwgeyBnZXR0ZXI6IHRydWUgfSk7XG4gIGlmIChkZXNjcmlwdG9yLnNldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5zZXQsIG5hbWUsIHsgc2V0dGVyOiB0cnVlIH0pO1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcblxudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRnO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDI7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QkMyh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDIgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciBiaW5kJDIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkNTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDQ7XG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGNyZWF0ZVByb3BlcnR5JDI7XG52YXIgZ2V0SXRlcmF0b3IkMSA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG5cbnZhciAkQXJyYXkkMSA9IEFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbnZhciBhcnJheUZyb20kMSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCQxKGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQkMihtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDEoTyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlO1xuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgISh0aGlzID09PSAkQXJyYXkkMSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMShPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XG4gICAgZm9yICg7IShzdGVwID0gY2FsbCQ0KG5leHQsIGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKE8pO1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMobGVuZ3RoKSA6ICRBcnJheSQxKGxlbmd0aCk7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMjtcblxudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheShtYXgkMShmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMvYmxvYi9tYXN0ZXIvcHVueWNvZGUuanNcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxcdTAwN0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1suXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG52YXIgT1ZFUkZMT1dfRVJST1IgPSAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnO1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbnZhciBleGVjJDIgPSB1bmN1cnJ5VGhpcyQ2KHJlZ2V4U2VwYXJhdG9ycy5leGVjKTtcbnZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyQ2KCcnLmNoYXJDb2RlQXQpO1xudmFyIGpvaW4kMiA9IHVuY3VycnlUaGlzJDYoW10uam9pbik7XG52YXIgcHVzaCQzID0gdW5jdXJyeVRoaXMkNihbXS5wdXNoKTtcbnZhciByZXBsYWNlJDQgPSB1bmN1cnJ5VGhpcyQ2KCcnLnJlcGxhY2UpO1xudmFyIHNwbGl0JDIgPSB1bmN1cnJ5VGhpcyQ2KCcnLnNwbGl0KTtcbnZhciB0b0xvd2VyQ2FzZSQxID0gdW5jdXJyeVRoaXMkNignJy50b0xvd2VyQ2FzZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICovXG52YXIgdWNzMmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGNoYXJDb2RlQXQoc3RyaW5nLCBjb3VudGVyKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgIC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICB2YXIgZXh0cmEgPSBjaGFyQ29kZUF0KHN0cmluZywgY291bnRlcisrKTtcbiAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuICAgICAgICBwdXNoJDMob3V0cHV0LCAoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIHB1c2gkMyhvdXRwdXQsIHZhbHVlKTtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoJDMob3V0cHV0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgdmFyIGsgPSAwO1xuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yJDMoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gIGRlbHRhICs9IGZsb29yJDMoZGVsdGEgLyBudW1Qb2ludHMpO1xuICB3aGlsZSAoZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxKSB7XG4gICAgZGVsdGEgPSBmbG9vciQzKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gICAgayArPSBiYXNlO1xuICB9XG4gIHJldHVybiBmbG9vciQzKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG4gIC8vIENhY2hlIHRoZSBsZW5ndGguXG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cbiAgdmFyIG4gPSBpbml0aWFsTjtcbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiAgdmFyIGksIGN1cnJlbnRWYWx1ZTtcblxuICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgcHVzaCQzKG91dHB1dCwgZnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgdmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7IC8vIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gIGlmIChiYXNpY0xlbmd0aCkge1xuICAgIHB1c2gkMyhvdXRwdXQsIGRlbGltaXRlcik7XG4gIH1cblxuICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dCBsYXJnZXIgb25lOlxuICAgIHZhciBtID0gbWF4SW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwgYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgdmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICBpZiAobSAtIG4gPiBmbG9vciQzKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICB0aHJvdyAkUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgfVxuXG4gICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICBuID0gbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgIHRocm93ICRSYW5nZUVycm9yKE9WRVJGTE9XX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgdmFyIHEgPSBkZWx0YTtcbiAgICAgICAgdmFyIGsgPSBiYXNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcbiAgICAgICAgICBpZiAocSA8IHQpIGJyZWFrO1xuICAgICAgICAgIHZhciBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgdmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBwdXNoJDMob3V0cHV0LCBmcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcbiAgICAgICAgICBxID0gZmxvb3IkMyhxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgayArPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCQzKG91dHB1dCwgZnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgIGhhbmRsZWRDUENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsdGErKztcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIGpvaW4kMihvdXRwdXQsICcnKTtcbn07XG5cbnZhciBzdHJpbmdQdW55Y29kZVRvQXNjaWkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcbiAgdmFyIGxhYmVscyA9IHNwbGl0JDIocmVwbGFjZSQ0KHRvTG93ZXJDYXNlJDEoaW5wdXQpLCByZWdleFNlcGFyYXRvcnMsICdcXHUwMDJFJyksICcuJyk7XG4gIHZhciBpLCBsYWJlbDtcbiAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIHB1c2gkMyhlbmNvZGVkLCBleGVjJDIocmVnZXhOb25BU0NJSSwgbGFiZWwpID8gJ3huLS0nICsgZW5jb2RlKGxhYmVsKSA6IGxhYmVsKTtcbiAgfVxuICByZXR1cm4gam9pbiQyKGVuY29kZWQsICcuJyk7XG59O1xuXG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiRhO1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluJDModGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBhcnJheVNsaWNlJDEgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IkMihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQxKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gIHZhciBsbGVuZ3RoID0gbGVmdC5sZW5ndGg7XG4gIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICB2YXIgbGluZGV4ID0gMDtcbiAgdmFyIHJpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK11cbiAgICAgIDogbGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdO1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheVNvcnQkMSA9IG1lcmdlU29ydDtcblxuLy8gVE9ETzogaW4gY29yZS1qc0A0LCBtb3ZlIC9tb2R1bGVzLyBkZXBlbmRlbmNpZXMgdG8gcHVibGljIGVudHJpZXMgZm9yIGJldHRlciBvcHRpbWl6YXRpb24gYnkgdG9vbHMgbGlrZSBgcHJlc2V0LWVudmBcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkbztcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xudmFyIFVTRV9OQVRJVkVfVVJMJDEgPSBuYXRpdmVVcmw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMTtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQyO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQzO1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgYmluZCQxID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDY7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGc7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ4O1xudmFyICR0b1N0cmluZyQxID0gdG9TdHJpbmckNDtcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQzO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgYXJyYXlTb3J0ID0gYXJyYXlTb3J0JDE7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCQyKCdpdGVyYXRvcicpO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TID0gJ1VSTFNlYXJjaFBhcmFtcyc7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IgPSBVUkxfU0VBUkNIX1BBUkFNUyArICdJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNUyk7XG52YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBBdm9pZCBOb2RlSlMgZXhwZXJpbWVudGFsIHdhcm5pbmdcbnZhciBzYWZlR2V0QnVpbHRJbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghREVTQ1JJUFRPUlMkMSkgcmV0dXJuIGdsb2JhbCQ1W25hbWVdO1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwkNSwgbmFtZSk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG59O1xuXG52YXIgbmF0aXZlRmV0Y2ggPSBzYWZlR2V0QnVpbHRJbignZmV0Y2gnKTtcbnZhciBOYXRpdmVSZXF1ZXN0ID0gc2FmZUdldEJ1aWx0SW4oJ1JlcXVlc3QnKTtcbnZhciBIZWFkZXJzID0gc2FmZUdldEJ1aWx0SW4oJ0hlYWRlcnMnKTtcbnZhciBSZXF1ZXN0UHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdCAmJiBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTtcbnZhciBIZWFkZXJzUHJvdG90eXBlID0gSGVhZGVycyAmJiBIZWFkZXJzLnByb3RvdHlwZTtcbnZhciBSZWdFeHAkMSA9IGdsb2JhbCQ1LlJlZ0V4cDtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCQ1LlR5cGVFcnJvcjtcbnZhciBkZWNvZGVVUklDb21wb25lbnQgPSBnbG9iYWwkNS5kZWNvZGVVUklDb21wb25lbnQ7XG52YXIgZW5jb2RlVVJJQ29tcG9uZW50JDEgPSBnbG9iYWwkNS5lbmNvZGVVUklDb21wb25lbnQ7XG52YXIgY2hhckF0JDQgPSB1bmN1cnJ5VGhpcyQ1KCcnLmNoYXJBdCk7XG52YXIgam9pbiQxID0gdW5jdXJyeVRoaXMkNShbXS5qb2luKTtcbnZhciBwdXNoJDIgPSB1bmN1cnJ5VGhpcyQ1KFtdLnB1c2gpO1xudmFyIHJlcGxhY2UkMyA9IHVuY3VycnlUaGlzJDUoJycucmVwbGFjZSk7XG52YXIgc2hpZnQkMSA9IHVuY3VycnlUaGlzJDUoW10uc2hpZnQpO1xudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDUoW10uc3BsaWNlKTtcbnZhciBzcGxpdCQxID0gdW5jdXJyeVRoaXMkNSgnJy5zcGxpdCk7XG52YXIgc3RyaW5nU2xpY2UkNCA9IHVuY3VycnlUaGlzJDUoJycuc2xpY2UpO1xuXG52YXIgcGx1cyA9IC9cXCsvZztcbnZhciBzZXF1ZW5jZXMgPSBBcnJheSg0KTtcblxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gc2VxdWVuY2VzW2J5dGVzIC0gMV0gfHwgKHNlcXVlbmNlc1tieXRlcyAtIDFdID0gUmVnRXhwJDEoJygoPzolW1xcXFxkYS1mXXsyfSl7JyArIGJ5dGVzICsgJ30pJywgJ2dpJykpO1xufTtcblxudmFyIHBlcmNlbnREZWNvZGUgPSBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHNlcXVlbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH1cbn07XG5cbnZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gcmVwbGFjZSQzKGl0LCBwbHVzLCAnICcpO1xuICB2YXIgYnl0ZXMgPSA0O1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3aGlsZSAoYnl0ZXMpIHtcbiAgICAgIHJlc3VsdCA9IHJlcGxhY2UkMyhyZXN1bHQsIHBlcmNlbnRTZXF1ZW5jZShieXRlcy0tKSwgcGVyY2VudERlY29kZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XG5cbnZhciByZXBsYWNlbWVudHMgPSB7XG4gICchJzogJyUyMScsXG4gIFwiJ1wiOiAnJTI3JyxcbiAgJygnOiAnJTI4JyxcbiAgJyknOiAnJTI5JyxcbiAgJ34nOiAnJTdFJyxcbiAgJyUyMCc6ICcrJ1xufTtcblxudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gIHJldHVybiByZXBsYWNlbWVudHNbbWF0Y2hdO1xufTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gcmVwbGFjZSQzKGVuY29kZVVSSUNvbXBvbmVudCQxKGl0KSwgZmluZCwgcmVwbGFjZXIpO1xufTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBJdGVyYXRvcihwYXJhbXMsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUixcbiAgICBpdGVyYXRvcjogZ2V0SXRlcmF0b3IoZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMpLFxuICAgIGtpbmQ6IGtpbmRcbiAgfSk7XG59LCAnSXRlcmF0b3InLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIHN0ZXAgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gIGlmICghc3RlcC5kb25lKSB7XG4gICAgc3RlcC52YWx1ZSA9IGtpbmQgPT09ICdrZXlzJyA/IGVudHJ5LmtleSA6IGtpbmQgPT09ICd2YWx1ZXMnID8gZW50cnkudmFsdWUgOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV07XG4gIH0gcmV0dXJuIHN0ZXA7XG59LCB0cnVlKTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1N0YXRlID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG4gIHRoaXMudXJsID0gbnVsbDtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB0aGlzLnBhcnNlT2JqZWN0KGluaXQpO1xuICAgIGVsc2UgdGhpcy5wYXJzZVF1ZXJ5KHR5cGVvZiBpbml0ID09ICdzdHJpbmcnID8gY2hhckF0JDQoaW5pdCwgMCkgPT09ICc/JyA/IHN0cmluZ1NsaWNlJDQoaW5pdCwgMSkgOiBpbml0IDogJHRvU3RyaW5nJDEoaW5pdCkpO1xuICB9XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICBiaW5kVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcbiAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChvYmplY3QpO1xuICAgIHZhciBpdGVyYXRvciwgbmV4dCwgc3RlcCwgZW50cnlJdGVyYXRvciwgZW50cnlOZXh0LCBmaXJzdCwgc2Vjb25kO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKG9iamVjdCwgaXRlcmF0b3JNZXRob2QpO1xuICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgICB3aGlsZSAoIShzdGVwID0gY2FsbCQzKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgICBlbnRyeUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoYW5PYmplY3QkMihzdGVwLnZhbHVlKSk7XG4gICAgICAgIGVudHJ5TmV4dCA9IGVudHJ5SXRlcmF0b3IubmV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChmaXJzdCA9IGNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgKHNlY29uZCA9IGNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgIWNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpLmRvbmVcbiAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IkMignRXhwZWN0ZWQgc2VxdWVuY2Ugd2l0aCBsZW5ndGggMicpO1xuICAgICAgICBwdXNoJDIodGhpcy5lbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nJDEoZmlyc3QudmFsdWUpLCB2YWx1ZTogJHRvU3RyaW5nJDEoc2Vjb25kLnZhbHVlKSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgZm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093biQxKG9iamVjdCwga2V5KSkge1xuICAgICAgcHVzaCQyKHRoaXMuZW50cmllcywgeyBrZXk6IGtleSwgdmFsdWU6ICR0b1N0cmluZyQxKG9iamVjdFtrZXldKSB9KTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlUXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzcGxpdCQxKHF1ZXJ5LCAnJicpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICAgICAgd2hpbGUgKGluZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBlbnRyeSA9IHNwbGl0JDEoYXR0cmlidXRlLCAnPScpO1xuICAgICAgICAgIHB1c2gkMih0aGlzLmVudHJpZXMsIHtcbiAgICAgICAgICAgIGtleTogZGVzZXJpYWxpemUoc2hpZnQkMShlbnRyeSkpLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2VyaWFsaXplKGpvaW4kMShlbnRyeSwgJz0nKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICAgICBwdXNoJDIocmVzdWx0LCBzZXJpYWxpemUoZW50cnkua2V5KSArICc9JyArIHNlcmlhbGl6ZShlbnRyeS52YWx1ZSkpO1xuICAgIH0gcmV0dXJuIGpvaW4kMShyZXN1bHQsICcmJyk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGFyc2VRdWVyeSh0aGlzLnVybC5xdWVyeSk7XG4gIH0sXG4gIHVwZGF0ZVVSTDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnVybCkgdGhpcy51cmwudXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXNgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXNcbnZhciBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcygvKiBpbml0ICovKSB7XG4gIGFuSW5zdGFuY2UkMSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUpO1xuICB2YXIgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywgbmV3IFVSTFNlYXJjaFBhcmFtc1N0YXRlKGluaXQpKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbmRlZmluZUJ1aWx0SW5zKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHB1c2gkMihzdGF0ZS5lbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nJDEobmFtZSksIHZhbHVlOiAkdG9TdHJpbmckMSh2YWx1ZSkgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1kZWxldGVcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBzcGxpY2UoZW50cmllcywgaW5kZXgsIDEpO1xuICAgICAgZWxzZSBpbmRleCsrO1xuICAgIH1cbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldFxuICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSByZXR1cm4gZW50cmllc1tpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRBbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmckMShuYW1lKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBwdXNoJDIocmVzdWx0LCBlbnRyaWVzW2luZGV4XS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1oYXNcbiAgaGFzOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyQxKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4KytdLmtleSA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtc2V0XG4gIHNldDogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIHZhbCA9ICR0b1N0cmluZyQxKHZhbHVlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoZm91bmQpIHNwbGljZShlbnRyaWVzLCBpbmRleC0tLCAxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHB1c2gkMihlbnRyaWVzLCB7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNvcnRcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIGFycmF5U29ydChzdGF0ZS5lbnRyaWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEua2V5ID4gYi5rZXkgPyAxIDogLTE7XG4gICAgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQxKGNhbGxiYWNrLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzYCBtZXRob2RcbiAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdrZXlzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ3ZhbHVlcycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdlbnRyaWVzJyk7XG4gIH1cbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuZGVmaW5lQnVpbHRJbiQyKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzLCB7IG5hbWU6ICdlbnRyaWVzJyB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5kZWZpbmVCdWlsdEluJDIoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuc2VyaWFsaXplKCk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbnNldFRvU3RyaW5nVGFnJDEoVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcblxuJCQyKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwkMSB9LCB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3Jcbn0pO1xuXG4vLyBXcmFwIGBmZXRjaGAgYW5kIGBSZXF1ZXN0YCBmb3IgY29ycmVjdCB3b3JrIHdpdGggcG9seWZpbGxlZCBgVVJMU2VhcmNoUGFyYW1zYFxuaWYgKCFVU0VfTkFUSVZFX1VSTCQxICYmIGlzQ2FsbGFibGUkMihIZWFkZXJzKSkge1xuICB2YXIgaGVhZGVyc0hhcyA9IHVuY3VycnlUaGlzJDUoSGVhZGVyc1Byb3RvdHlwZS5oYXMpO1xuICB2YXIgaGVhZGVyc1NldCA9IHVuY3VycnlUaGlzJDUoSGVhZGVyc1Byb3RvdHlwZS5zZXQpO1xuXG4gIHZhciB3cmFwUmVxdWVzdE9wdGlvbnMgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIGlmIChpc09iamVjdChpbml0KSkge1xuICAgICAgdmFyIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgICB2YXIgaGVhZGVycztcbiAgICAgIGlmIChjbGFzc29mJDEoYm9keSkgPT09IFVSTF9TRUFSQ0hfUEFSQU1TKSB7XG4gICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpIDogbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKCFoZWFkZXJzSGFzKGhlYWRlcnMsICdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgIGhlYWRlcnNTZXQoaGVhZGVycywgJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGUkMShpbml0LCB7XG4gICAgICAgICAgYm9keTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsICR0b1N0cmluZyQxKGJvZHkpKSxcbiAgICAgICAgICBoZWFkZXJzOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgaGVhZGVycylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSByZXR1cm4gaW5pdDtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQyKG5hdGl2ZUZldGNoKSkge1xuICAgICQkMih7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZG9udENhbGxHZXRTZXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVGZXRjaChpbnB1dCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB3cmFwUmVxdWVzdE9wdGlvbnMoYXJndW1lbnRzWzFdKSA6IHt9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0NhbGxhYmxlJDIoTmF0aXZlUmVxdWVzdCkpIHtcbiAgICB2YXIgUmVxdWVzdENvbnN0cnVjdG9yID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCAvKiAsIGluaXQgKi8pIHtcbiAgICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBSZXF1ZXN0UHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB3cmFwUmVxdWVzdE9wdGlvbnMoYXJndW1lbnRzWzFdKSA6IHt9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcXVlc3RDb25zdHJ1Y3RvcjtcbiAgICBSZXF1ZXN0Q29uc3RydWN0b3IucHJvdG90eXBlID0gUmVxdWVzdFByb3RvdHlwZTtcblxuICAgICQkMih7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGRvbnRDYWxsR2V0U2V0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgUmVxdWVzdDogUmVxdWVzdENvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIHdlYl91cmxTZWFyY2hQYXJhbXNfY29uc3RydWN0b3IgPSB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gIGdldFN0YXRlOiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlXG59O1xuXG4vLyBUT0RPOiBpbiBjb3JlLWpzQDQsIG1vdmUgL21vZHVsZXMvIGRlcGVuZGVuY2llcyB0byBwdWJsaWMgZW50cmllcyBmb3IgYmV0dGVyIG9wdGltaXphdGlvbiBieSB0b29scyBsaWtlIGBwcmVzZXQtZW52YFxuXG52YXIgJCQxID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gbmF0aXZlVXJsO1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJG87XG52YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQxO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBhc3NpZ24gPSBvYmplY3RBc3NpZ247XG52YXIgYXJyYXlGcm9tID0gYXJyYXlGcm9tJDE7XG52YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgY29kZUF0ID0gc3RyaW5nTXVsdGlieXRlLmNvZGVBdDtcbnZhciB0b0FTQ0lJID0gc3RyaW5nUHVueWNvZGVUb0FzY2lpO1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJDQ7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMztcbnZhciBVUkxTZWFyY2hQYXJhbXNNb2R1bGUgPSB3ZWJfdXJsU2VhcmNoUGFyYW1zX2NvbnN0cnVjdG9yO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zJDEgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG5cbnZhciBOYXRpdmVVUkwgPSBnbG9iYWwkNC5VUkw7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkNC5UeXBlRXJyb3I7XG52YXIgcGFyc2VJbnQgPSBnbG9iYWwkNC5wYXJzZUludDtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBjaGFyQXQkMyA9IHVuY3VycnlUaGlzJDQoJycuY2hhckF0KTtcbnZhciBleGVjJDEgPSB1bmN1cnJ5VGhpcyQ0KC8uLy5leGVjKTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMkNChbXS5qb2luKTtcbnZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzJDQoMS4wLnRvU3RyaW5nKTtcbnZhciBwb3AgPSB1bmN1cnJ5VGhpcyQ0KFtdLnBvcCk7XG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNChbXS5wdXNoKTtcbnZhciByZXBsYWNlJDIgPSB1bmN1cnJ5VGhpcyQ0KCcnLnJlcGxhY2UpO1xudmFyIHNoaWZ0ID0gdW5jdXJyeVRoaXMkNChbXS5zaGlmdCk7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyQ0KCcnLnNwbGl0KTtcbnZhciBzdHJpbmdTbGljZSQzID0gdW5jdXJyeVRoaXMkNCgnJy5zbGljZSk7XG52YXIgdG9Mb3dlckNhc2UgPSB1bmN1cnJ5VGhpcyQ0KCcnLnRvTG93ZXJDYXNlKTtcbnZhciB1bnNoaWZ0ID0gdW5jdXJyeVRoaXMkNChbXS51bnNoaWZ0KTtcblxudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcbnZhciBJTlZBTElEX1NDSEVNRSA9ICdJbnZhbGlkIHNjaGVtZSc7XG52YXIgSU5WQUxJRF9IT1NUID0gJ0ludmFsaWQgaG9zdCc7XG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XG5cbnZhciBBTFBIQSA9IC9bYS16XS9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1vYnNjdXJlLXJhbmdlIC0tIHNhZmVcbnZhciBBTFBIQU5VTUVSSUMgPSAvW1xcZCstLmEtel0vaTtcbnZhciBESUdJVCA9IC9cXGQvO1xudmFyIEhFWF9TVEFSVCA9IC9eMHgvaTtcbnZhciBPQ1QgPSAvXlswLTddKyQvO1xudmFyIERFQyA9IC9eXFxkKyQvO1xudmFyIEhFWCA9IC9eW1xcZGEtZl0rJC9pO1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWNvbnRyb2wtY2hhcmFjdGVyIC0tIHNhZmUgKi9cbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UID0gL1tcXDBcXHRcXG5cXHIgIyUvOjw+P0BbXFxcXFxcXV58XS87XG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCA9IC9bXFwwXFx0XFxuXFxyICMvOjw+P0BbXFxcXFxcXV58XS87XG52YXIgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSA9IC9eW1xcdTAwMDAtXFx1MDAyMF0rfFtcXHUwMDAwLVxcdTAwMjBdKyQvZztcbnZhciBUQUJfQU5EX05FV19MSU5FID0gL1tcXHRcXG5cXHJdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIHJlZ2V4cC9uby1jb250cm9sLWNoYXJhY3RlciAtLSBzYWZlICovXG52YXIgRU9GO1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lwdjQtbnVtYmVyLXBhcnNlclxudmFyIHBhcnNlSVB2NCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgcGFydHMgPSBzcGxpdChpbnB1dCwgJy4nKTtcbiAgdmFyIHBhcnRzTGVuZ3RoLCBudW1iZXJzLCBpbmRleCwgcGFydCwgcmFkaXgsIG51bWJlciwgaXB2NDtcbiAgaWYgKHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PSAnJykge1xuICAgIHBhcnRzLmxlbmd0aC0tO1xuICB9XG4gIHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICBpZiAocGFydHNMZW5ndGggPiA0KSByZXR1cm4gaW5wdXQ7XG4gIG51bWJlcnMgPSBbXTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFydHNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICAgIGlmIChwYXJ0ID09ICcnKSByZXR1cm4gaW5wdXQ7XG4gICAgcmFkaXggPSAxMDtcbiAgICBpZiAocGFydC5sZW5ndGggPiAxICYmIGNoYXJBdCQzKHBhcnQsIDApID09ICcwJykge1xuICAgICAgcmFkaXggPSBleGVjJDEoSEVYX1NUQVJULCBwYXJ0KSA/IDE2IDogODtcbiAgICAgIHBhcnQgPSBzdHJpbmdTbGljZSQzKHBhcnQsIHJhZGl4ID09IDggPyAxIDogMik7XG4gICAgfVxuICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgbnVtYmVyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleGVjJDEocmFkaXggPT0gMTAgPyBERUMgOiByYWRpeCA9PSA4ID8gT0NUIDogSEVYLCBwYXJ0KSkgcmV0dXJuIGlucHV0O1xuICAgICAgbnVtYmVyID0gcGFyc2VJbnQocGFydCwgcmFkaXgpO1xuICAgIH1cbiAgICBwdXNoJDEobnVtYmVycywgbnVtYmVyKTtcbiAgfVxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICAgIGlmIChpbmRleCA9PSBwYXJ0c0xlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChudW1iZXIgPj0gcG93KDI1NiwgNSAtIHBhcnRzTGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPiAyNTUpIHJldHVybiBudWxsO1xuICB9XG4gIGlwdjQgPSBwb3AobnVtYmVycyk7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaXB2NCArPSBudW1iZXJzW2luZGV4XSAqIHBvdygyNTYsIDMgLSBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIGlwdjQ7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaXB2Ni1wYXJzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBhZGRyZXNzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICB2YXIgcGllY2VJbmRleCA9IDA7XG4gIHZhciBjb21wcmVzcyA9IG51bGw7XG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIHZhbHVlLCBsZW5ndGgsIG51bWJlcnNTZWVuLCBpcHY0UGllY2UsIG51bWJlciwgc3dhcHMsIHN3YXA7XG5cbiAgdmFyIGNociA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhckF0JDMoaW5wdXQsIHBvaW50ZXIpO1xuICB9O1xuXG4gIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICBpZiAoY2hhckF0JDMoaW5wdXQsIDEpICE9ICc6JykgcmV0dXJuO1xuICAgIHBvaW50ZXIgKz0gMjtcbiAgICBwaWVjZUluZGV4Kys7XG4gICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICB9XG4gIHdoaWxlIChjaHIoKSkge1xuICAgIGlmIChwaWVjZUluZGV4ID09IDgpIHJldHVybjtcbiAgICBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHJldHVybjtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIHBpZWNlSW5kZXgrKztcbiAgICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKGxlbmd0aCA8IDQgJiYgZXhlYyQxKEhFWCwgY2hyKCkpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaHIoKSwgMTYpO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgbGVuZ3RoKys7XG4gICAgfVxuICAgIGlmIChjaHIoKSA9PSAnLicpIHtcbiAgICAgIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICAgICBpZiAocGllY2VJbmRleCA+IDYpIHJldHVybjtcbiAgICAgIG51bWJlcnNTZWVuID0gMDtcbiAgICAgIHdoaWxlIChjaHIoKSkge1xuICAgICAgICBpcHY0UGllY2UgPSBudWxsO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPiAwKSB7XG4gICAgICAgICAgaWYgKGNocigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpIHBvaW50ZXIrKztcbiAgICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4ZWMkMShESUdJVCwgY2hyKCkpKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChleGVjJDEoRElHSVQsIGNocigpKSkge1xuICAgICAgICAgIG51bWJlciA9IHBhcnNlSW50KGNocigpLCAxMCk7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA9PT0gbnVsbCkgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICAgICAgIGVsc2UgaWYgKGlwdjRQaWVjZSA9PSAwKSByZXR1cm47XG4gICAgICAgICAgZWxzZSBpcHY0UGllY2UgPSBpcHY0UGllY2UgKiAxMCArIG51bWJlcjtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID4gMjU1KSByZXR1cm47XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSBhZGRyZXNzW3BpZWNlSW5kZXhdICogMjU2ICsgaXB2NFBpZWNlO1xuICAgICAgICBudW1iZXJzU2VlbisrO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KSBwaWVjZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyc1NlZW4gIT0gNCkgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGlmICghY2hyKCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGNocigpKSByZXR1cm47XG4gICAgYWRkcmVzc1twaWVjZUluZGV4KytdID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gICAgc3dhcHMgPSBwaWVjZUluZGV4IC0gY29tcHJlc3M7XG4gICAgcGllY2VJbmRleCA9IDc7XG4gICAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgICAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpIHJldHVybjtcbiAgcmV0dXJuIGFkZHJlc3M7XG59O1xuXG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuICB2YXIgbWF4SW5kZXggPSBudWxsO1xuICB2YXIgbWF4TGVuZ3RoID0gMTtcbiAgdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gIHZhciBjdXJyTGVuZ3RoID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgIGlmIChpcHY2W2luZGV4XSAhPT0gMCkge1xuICAgICAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xuICAgICAgY3Vyckxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGluZGV4O1xuICAgICAgKytjdXJyTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNob3N0LXNlcmlhbGl6aW5nXG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIHZhciByZXN1bHQsIGluZGV4LCBjb21wcmVzcywgaWdub3JlMDtcbiAgLy8gaXB2NFxuICBpZiAodHlwZW9mIGhvc3QgPT0gJ251bWJlcicpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0OyBpbmRleCsrKSB7XG4gICAgICB1bnNoaWZ0KHJlc3VsdCwgaG9zdCAlIDI1Nik7XG4gICAgICBob3N0ID0gZmxvb3IkMShob3N0IC8gMjU2KTtcbiAgICB9IHJldHVybiBqb2luKHJlc3VsdCwgJy4nKTtcbiAgLy8gaXB2NlxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoaWdub3JlMCAmJiBob3N0W2luZGV4XSA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoaWdub3JlMCkgaWdub3JlMCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXByZXNzID09PSBpbmRleCkge1xuICAgICAgICByZXN1bHQgKz0gaW5kZXggPyAnOicgOiAnOjonO1xuICAgICAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBudW1iZXJUb1N0cmluZyhob3N0W2luZGV4XSwgMTYpO1xuICAgICAgICBpZiAoaW5kZXggPCA3KSByZXN1bHQgKz0gJzonO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1snICsgcmVzdWx0ICsgJ10nO1xuICB9IHJldHVybiBob3N0O1xufTtcblxudmFyIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQgPSB7fTtcbnZhciBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJyAnOiAxLCAnXCInOiAxLCAnPCc6IDEsICc+JzogMSwgJ2AnOiAxXG59KTtcbnZhciBwYXRoUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcjJzogMSwgJz8nOiAxLCAneyc6IDEsICd9JzogMVxufSk7XG52YXIgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBwYXRoUGVyY2VudEVuY29kZVNldCwge1xuICAnLyc6IDEsICc6JzogMSwgJzsnOiAxLCAnPSc6IDEsICdAJzogMSwgJ1snOiAxLCAnXFxcXCc6IDEsICddJzogMSwgJ14nOiAxLCAnfCc6IDFcbn0pO1xuXG52YXIgcGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uIChjaHIsIHNldCkge1xuICB2YXIgY29kZSA9IGNvZGVBdChjaHIsIDApO1xuICByZXR1cm4gY29kZSA+IDB4MjAgJiYgY29kZSA8IDB4N0YgJiYgIWhhc093bihzZXQsIGNocikgPyBjaHIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hyKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3BlY2lhbC1zY2hlbWVcbnZhciBzcGVjaWFsU2NoZW1lcyA9IHtcbiAgZnRwOiAyMSxcbiAgZmlsZTogbnVsbCxcbiAgaHR0cDogODAsXG4gIGh0dHBzOiA0NDMsXG4gIHdzOiA4MCxcbiAgd3NzOiA0NDNcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jd2luZG93cy1kcml2ZS1sZXR0ZXJcbnZhciBpc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5vcm1hbGl6ZWQpIHtcbiAgdmFyIHNlY29uZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPT0gMiAmJiBleGVjJDEoQUxQSEEsIGNoYXJBdCQzKHN0cmluZywgMCkpXG4gICAgJiYgKChzZWNvbmQgPSBjaGFyQXQkMyhzdHJpbmcsIDEpKSA9PSAnOicgfHwgKCFub3JtYWxpemVkICYmIHNlY29uZCA9PSAnfCcpKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RhcnQtd2l0aC1hLXdpbmRvd3MtZHJpdmUtbGV0dGVyXG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHRoaXJkO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nU2xpY2UkMyhzdHJpbmcsIDAsIDIpKSAmJiAoXG4gICAgc3RyaW5nLmxlbmd0aCA9PSAyIHx8XG4gICAgKCh0aGlyZCA9IGNoYXJBdCQzKHN0cmluZywgMikpID09PSAnLycgfHwgdGhpcmQgPT09ICdcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXG4gICk7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NpbmdsZS1kb3QtcGF0aC1zZWdtZW50XG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4nIHx8IHRvTG93ZXJDYXNlKHNlZ21lbnQpID09PSAnJTJlJztcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG91YmxlLWRvdC1wYXRoLXNlZ21lbnRcbnZhciBpc0RvdWJsZURvdCA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gIHNlZ21lbnQgPSB0b0xvd2VyQ2FzZShzZWdtZW50KTtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG5cbi8vIFN0YXRlczpcbnZhciBTQ0hFTUVfU1RBUlQgPSB7fTtcbnZhciBTQ0hFTUUgPSB7fTtcbnZhciBOT19TQ0hFTUUgPSB7fTtcbnZhciBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFBBVEhfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUkVMQVRJVkUgPSB7fTtcbnZhciBSRUxBVElWRV9TTEFTSCA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVMgPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUyA9IHt9O1xudmFyIEFVVEhPUklUWSA9IHt9O1xudmFyIEhPU1QgPSB7fTtcbnZhciBIT1NUTkFNRSA9IHt9O1xudmFyIFBPUlQgPSB7fTtcbnZhciBGSUxFID0ge307XG52YXIgRklMRV9TTEFTSCA9IHt9O1xudmFyIEZJTEVfSE9TVCA9IHt9O1xudmFyIFBBVEhfU1RBUlQgPSB7fTtcbnZhciBQQVRIID0ge307XG52YXIgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSCA9IHt9O1xudmFyIFFVRVJZID0ge307XG52YXIgRlJBR01FTlQgPSB7fTtcblxudmFyIFVSTFN0YXRlID0gZnVuY3Rpb24gKHVybCwgaXNCYXNlLCBiYXNlKSB7XG4gIHZhciB1cmxTdHJpbmcgPSAkdG9TdHJpbmcodXJsKTtcbiAgdmFyIGJhc2VTdGF0ZSwgZmFpbHVyZSwgc2VhcmNoUGFyYW1zO1xuICBpZiAoaXNCYXNlKSB7XG4gICAgZmFpbHVyZSA9IHRoaXMucGFyc2UodXJsU3RyaW5nKTtcbiAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yJDEoZmFpbHVyZSk7XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIGJhc2VTdGF0ZSA9IG5ldyBVUkxTdGF0ZShiYXNlLCB0cnVlKTtcbiAgICBmYWlsdXJlID0gdGhpcy5wYXJzZSh1cmxTdHJpbmcsIG51bGwsIGJhc2VTdGF0ZSk7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvciQxKGZhaWx1cmUpO1xuICAgIHNlYXJjaFBhcmFtcyA9IGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUobmV3IFVSTFNlYXJjaFBhcmFtcyQxKCkpO1xuICAgIHNlYXJjaFBhcmFtcy5iaW5kVVJMKHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICB9XG59O1xuXG5VUkxTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdVUkwnLFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG4gIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlT3ZlcnJpZGUsIGJhc2UpIHtcbiAgICB2YXIgdXJsID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzdGF0ZU92ZXJyaWRlIHx8IFNDSEVNRV9TVEFSVDtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciBzZWVuQXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlblBhc3N3b3JkVG9rZW4gPSBmYWxzZTtcbiAgICB2YXIgY29kZVBvaW50cywgY2hyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuXG4gICAgaW5wdXQgPSAkdG9TdHJpbmcoaW5wdXQpO1xuXG4gICAgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgdXJsLmhvc3QgPSBudWxsO1xuICAgICAgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgdXJsLnBhdGggPSBbXTtcbiAgICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSBmYWxzZTtcbiAgICAgIGlucHV0ID0gcmVwbGFjZSQyKGlucHV0LCBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSByZXBsYWNlJDIoaW5wdXQsIFRBQl9BTkRfTkVXX0xJTkUsICcnKTtcblxuICAgIGNvZGVQb2ludHMgPSBhcnJheUZyb20oaW5wdXQpO1xuXG4gICAgd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgICAgIGNociA9IGNvZGVQb2ludHNbcG9pbnRlcl07XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU0NIRU1FX1NUQVJUOlxuICAgICAgICAgIGlmIChjaHIgJiYgZXhlYyQxKEFMUEhBLCBjaHIpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gdG9Mb3dlckNhc2UoY2hyKTtcbiAgICAgICAgICAgIHN0YXRlID0gU0NIRU1FO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNDSEVNRTpcbiAgICAgICAgICBpZiAoY2hyICYmIChleGVjJDEoQUxQSEFOVU1FUklDLCBjaHIpIHx8IGNociA9PSAnKycgfHwgY2hyID09ICctJyB8fCBjaHIgPT0gJy4nKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHRvTG93ZXJDYXNlKGNocik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiAoXG4gICAgICAgICAgICAgICh1cmwuaXNTcGVjaWFsKCkgIT0gaGFzT3duKHNwZWNpYWxTY2hlbWVzLCBidWZmZXIpKSB8fFxuICAgICAgICAgICAgICAoYnVmZmVyID09ICdmaWxlJyAmJiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSB8fCB1cmwucG9ydCAhPT0gbnVsbCkpIHx8XG4gICAgICAgICAgICAgICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpXG4gICAgICAgICAgICApKSByZXR1cm47XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSA9PSB1cmwucG9ydCkgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZJTEU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBiYXNlICYmIGJhc2Uuc2NoZW1lID09IHVybC5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsLmlzU3BlY2lhbCgpKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHVzaCQxKHVybC5wYXRoLCAnJyk7XG4gICAgICAgICAgICAgIHN0YXRlID0gQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgICAgcG9pbnRlciA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTk9fU0NIRU1FOlxuICAgICAgICAgIGlmICghYmFzZSB8fCAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNociAhPSAnIycpKSByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICAgICAgICAgaWYgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUgPSBiYXNlLnNjaGVtZSA9PSAnZmlsZScgPyBGSUxFIDogUkVMQVRJVkU7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTpcbiAgICAgICAgICBpZiAoY2hyID09ICcvJyAmJiBjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUkVMQVRJVkU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSF9PUl9BVVRIT1JJVFk6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFTEFUSVZFOlxuICAgICAgICAgIHVybC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICAgICAgICBpZiAoY2hyID09IEVPRikge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcvJyB8fCAoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFX1NMQVNIO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnBhdGgubGVuZ3RoLS07XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUkVMQVRJVkVfU0xBU0g6XG4gICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiAoY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgIGlmIChjaHIgIT0gJy8nIHx8IGNoYXJBdCQzKGJ1ZmZlciwgcG9pbnRlciArIDEpICE9ICcvJykgY29udGludWU7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgY2hyICE9ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJ0AnKSB7XG4gICAgICAgICAgICBpZiAoc2VlbkF0KSBidWZmZXIgPSAnJTQwJyArIGJ1ZmZlcjtcbiAgICAgICAgICAgIHNlZW5BdCA9IHRydWU7XG4gICAgICAgICAgICBidWZmZXJDb2RlUG9pbnRzID0gYXJyYXlGcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGJ1ZmZlckNvZGVQb2ludHNbaV07XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gJzonICYmICFzZWVuUGFzc3dvcmRUb2tlbikge1xuICAgICAgICAgICAgICAgIHNlZW5QYXNzd29yZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZW5jb2RlZENvZGVQb2ludHMgPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludCwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKSB1cmwucGFzc3dvcmQgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgICAgICAgICAgIGVsc2UgdXJsLnVzZXJuYW1lICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgICAgICAgICBwb2ludGVyIC09IGFycmF5RnJvbShidWZmZXIpLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gSE9TVDtcbiAgICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEhPU1Q6XG4gICAgICAgIGNhc2UgSE9TVE5BTUU6XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgdXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgICAgICAgIGZhaWx1cmUgPSB1cmwucGFyc2VIb3N0KGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUE9SVDtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlID09IEhPU1ROQU1FKSByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmICh1cmwuaW5jbHVkZXNDcmVkZW50aWFscygpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgcmV0dXJuO1xuICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hyID09ICdbJykgc2VlbkJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09ICddJykgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBPUlQ6XG4gICAgICAgICAgaWYgKGV4ZWMkMShESUdJVCwgY2hyKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSB8fFxuICAgICAgICAgICAgc3RhdGVPdmVycmlkZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICAgICAgICAgICB2YXIgcG9ydCA9IHBhcnNlSW50KGJ1ZmZlciwgMTApO1xuICAgICAgICAgICAgICBpZiAocG9ydCA+IDB4RkZGRikgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICAgICAgdXJsLnBvcnQgPSAodXJsLmlzU3BlY2lhbCgpICYmIHBvcnQgPT09IHNwZWNpYWxTY2hlbWVzW3VybC5zY2hlbWVdKSA/IG51bGwgOiBwb3J0O1xuICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEU6XG4gICAgICAgICAgdXJsLnNjaGVtZSA9ICdmaWxlJztcbiAgICAgICAgICBpZiAoY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnKSBzdGF0ZSA9IEZJTEVfU0xBU0g7XG4gICAgICAgICAgZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gRU9GKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoam9pbihhcnJheVNsaWNlKGNvZGVQb2ludHMsIHBvaW50ZXIpLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgICAgdXJsLnNob3J0ZW5QYXRoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEVfU0xBU0g6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnICYmICFzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKGpvaW4oYXJyYXlTbGljZShjb2RlUG9pbnRzLCBwb2ludGVyKSwgJycpKSkge1xuICAgICAgICAgICAgaWYgKGlzV2luZG93c0RyaXZlTGV0dGVyKGJhc2UucGF0aFswXSwgdHJ1ZSkpIHB1c2gkMSh1cmwucGF0aCwgYmFzZS5wYXRoWzBdKTtcbiAgICAgICAgICAgIGVsc2UgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIEZJTEVfSE9TVDpcbiAgICAgICAgICBpZiAoY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnXFxcXCcgfHwgY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWlsdXJlID0gdXJsLnBhcnNlSG9zdChidWZmZXIpO1xuICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICAgIGlmICh1cmwuaG9zdCA9PSAnbG9jYWxob3N0JykgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICAgICAgICAgIH0gY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQQVRIX1NUQVJUOlxuICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmIGNociAhPSAnXFxcXCcpIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyICE9IEVPRikge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgaWYgKGNociAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQQVRIOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSB8fFxuICAgICAgICAgICAgKCFzdGF0ZU92ZXJyaWRlICYmIChjaHIgPT0gJz8nIHx8IGNociA9PSAnIycpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRG91YmxlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgdXJsLnNob3J0ZW5QYXRoKCk7XG4gICAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmICEoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpKSB7XG4gICAgICAgICAgICAgICAgcHVzaCQxKHVybC5wYXRoLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiAhKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5ob3N0KSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXJBdCQzKGJ1ZmZlciwgMCkgKyAnOic7IC8vIG5vcm1hbGl6ZSB3aW5kb3dzIGRyaXZlIGxldHRlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmIChjaHIgPT0gRU9GIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJykpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2hpZnQodXJsLnBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBwYXRoUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg6XG4gICAgICAgICAgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIHVybC5wYXRoWzBdICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUVVFUlk6XG4gICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gXCInXCIgJiYgdXJsLmlzU3BlY2lhbCgpKSB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gJyMnKSB1cmwucXVlcnkgKz0gJyUyMyc7XG4gICAgICAgICAgICBlbHNlIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNociwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZSQUdNRU5UOlxuICAgICAgICAgIGlmIChjaHIgIT0gRU9GKSB1cmwuZnJhZ21lbnQgKz0gcGVyY2VudEVuY29kZShjaHIsIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvaW50ZXIrKztcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaG9zdC1wYXJzaW5nXG4gIHBhcnNlSG9zdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlc3VsdCwgY29kZVBvaW50cywgaW5kZXg7XG4gICAgaWYgKGNoYXJBdCQzKGlucHV0LCAwKSA9PSAnWycpIHtcbiAgICAgIGlmIChjaGFyQXQkMyhpbnB1dCwgaW5wdXQubGVuZ3RoIC0gMSkgIT0gJ10nKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gcGFyc2VJUHY2KHN0cmluZ1NsaWNlJDMoaW5wdXQsIDEsIC0xKSk7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICAvLyBvcGFxdWUgaG9zdFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTcGVjaWFsKCkpIHtcbiAgICAgIGlmIChleGVjJDEoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCwgaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaW5kZXhdLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgICAgIGlmIChleGVjJDEoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCwgaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gcGFyc2VJUHY0KGlucHV0KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICB0aGlzLmhvc3QgPSByZXN1bHQ7XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2Nhbm5vdC1oYXZlLWEtdXNlcm5hbWUtcGFzc3dvcmQtcG9ydFxuICBjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaG9zdCB8fCB0aGlzLmNhbm5vdEJlQUJhc2VVUkwgfHwgdGhpcy5zY2hlbWUgPT0gJ2ZpbGUnO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2luY2x1ZGUtY3JlZGVudGlhbHNcbiAgaW5jbHVkZXNDcmVkZW50aWFsczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJuYW1lICE9ICcnIHx8IHRoaXMucGFzc3dvcmQgIT0gJyc7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaXMtc3BlY2lhbFxuICBpc1NwZWNpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGFzT3duKHNwZWNpYWxTY2hlbWVzLCB0aGlzLnNjaGVtZSk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc2hvcnRlbi1hLXVybHMtcGF0aFxuICBzaG9ydGVuUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHZhciBwYXRoU2l6ZSA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChwYXRoU2l6ZSAmJiAodGhpcy5zY2hlbWUgIT0gJ2ZpbGUnIHx8IHBhdGhTaXplICE9IDEgfHwgIWlzV2luZG93c0RyaXZlTGV0dGVyKHBhdGhbMF0sIHRydWUpKSkge1xuICAgICAgcGF0aC5sZW5ndGgtLTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXJsID0gdGhpcztcbiAgICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgICB2YXIgdXNlcm5hbWUgPSB1cmwudXNlcm5hbWU7XG4gICAgdmFyIHBhc3N3b3JkID0gdXJsLnBhc3N3b3JkO1xuICAgIHZhciBob3N0ID0gdXJsLmhvc3Q7XG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydDtcbiAgICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICAgIHZhciBxdWVyeSA9IHVybC5xdWVyeTtcbiAgICB2YXIgZnJhZ21lbnQgPSB1cmwuZnJhZ21lbnQ7XG4gICAgdmFyIG91dHB1dCA9IHNjaGVtZSArICc6JztcbiAgICBpZiAoaG9zdCAhPT0gbnVsbCkge1xuICAgICAgb3V0cHV0ICs9ICcvLyc7XG4gICAgICBpZiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSkge1xuICAgICAgICBvdXRwdXQgKz0gdXNlcm5hbWUgKyAocGFzc3dvcmQgPyAnOicgKyBwYXNzd29yZCA6ICcnKSArICdAJztcbiAgICAgIH1cbiAgICAgIG91dHB1dCArPSBzZXJpYWxpemVIb3N0KGhvc3QpO1xuICAgICAgaWYgKHBvcnQgIT09IG51bGwpIG91dHB1dCArPSAnOicgKyBwb3J0O1xuICAgIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJykgb3V0cHV0ICs9ICcvLyc7XG4gICAgb3V0cHV0ICs9IHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgam9pbihwYXRoLCAnLycpIDogJyc7XG4gICAgaWYgKHF1ZXJ5ICE9PSBudWxsKSBvdXRwdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgaWYgKGZyYWdtZW50ICE9PSBudWxsKSBvdXRwdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcbiAgc2V0SHJlZjogZnVuY3Rpb24gKGhyZWYpIHtcbiAgICB2YXIgZmFpbHVyZSA9IHRoaXMucGFyc2UoaHJlZik7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvciQxKGZhaWx1cmUpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zLnVwZGF0ZSgpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGdldE9yaWdpbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICBpZiAoc2NoZW1lID09ICdibG9iJykgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMQ29uc3RydWN0b3Ioc2NoZW1lLnBhdGhbMF0pLm9yaWdpbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKHNjaGVtZSA9PSAnZmlsZScgfHwgIXRoaXMuaXNTcGVjaWFsKCkpIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgc2VyaWFsaXplSG9zdCh0aGlzLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgZ2V0UHJvdG9jb2w6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWUgKyAnOic7XG4gIH0sXG4gIHNldFByb3RvY29sOiBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICB0aGlzLnBhcnNlKCR0b1N0cmluZyhwcm90b2NvbCkgKyAnOicsIFNDSEVNRV9TVEFSVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICBnZXRVc2VybmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJuYW1lO1xuICB9LFxuICBzZXRVc2VybmFtZTogZnVuY3Rpb24gKHVzZXJuYW1lKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHVzZXJuYW1lKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnVzZXJuYW1lID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXNzd29yZFxuICBnZXRQYXNzd29yZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhc3N3b3JkO1xuICB9LFxuICBzZXRQYXNzd29yZDogZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHBhc3N3b3JkKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnBhc3N3b3JkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBhc3N3b3JkICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0XG4gIGdldEhvc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnXG4gICAgICA6IHBvcnQgPT09IG51bGwgPyBzZXJpYWxpemVIb3N0KGhvc3QpXG4gICAgICA6IHNlcmlhbGl6ZUhvc3QoaG9zdCkgKyAnOicgKyBwb3J0O1xuICB9LFxuICBzZXRIb3N0OiBmdW5jdGlvbiAoaG9zdCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3QsIEhPU1QpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgZ2V0SG9zdG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcbiAgfSxcbiAgc2V0SG9zdG5hbWU6IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3RuYW1lLCBIT1NUTkFNRSk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wb3J0XG4gIGdldFBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gcG9ydCA9PT0gbnVsbCA/ICcnIDogJHRvU3RyaW5nKHBvcnQpO1xuICB9LFxuICBzZXRQb3J0OiBmdW5jdGlvbiAocG9ydCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCgpKSByZXR1cm47XG4gICAgcG9ydCA9ICR0b1N0cmluZyhwb3J0KTtcbiAgICBpZiAocG9ydCA9PSAnJykgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICBlbHNlIHRoaXMucGFyc2UocG9ydCwgUE9SVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICBnZXRQYXRobmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHJldHVybiB0aGlzLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBqb2luKHBhdGgsICcvJykgOiAnJztcbiAgfSxcbiAgc2V0UGF0aG5hbWU6IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhdGggPSBbXTtcbiAgICB0aGlzLnBhcnNlKHBhdGhuYW1lLCBQQVRIX1NUQVJUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBnZXRTZWFyY2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgIHJldHVybiBxdWVyeSA/ICc/JyArIHF1ZXJ5IDogJyc7XG4gIH0sXG4gIHNldFNlYXJjaDogZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgIHNlYXJjaCA9ICR0b1N0cmluZyhzZWFyY2gpO1xuICAgIGlmIChzZWFyY2ggPT0gJycpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJz8nID09IGNoYXJBdCQzKHNlYXJjaCwgMCkpIHNlYXJjaCA9IHN0cmluZ1NsaWNlJDMoc2VhcmNoLCAxKTtcbiAgICAgIHRoaXMucXVlcnkgPSAnJztcbiAgICAgIHRoaXMucGFyc2Uoc2VhcmNoLCBRVUVSWSk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoUGFyYW1zLnVwZGF0ZSgpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNocGFyYW1zXG4gIGdldFNlYXJjaFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaFBhcmFtcy5mYWNhZGU7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gIGdldEhhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG4gIH0sXG4gIHNldEhhc2g6IGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgaGFzaCA9ICR0b1N0cmluZyhoYXNoKTtcbiAgICBpZiAoaGFzaCA9PSAnJykge1xuICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgnIycgPT0gY2hhckF0JDMoaGFzaCwgMCkpIGhhc2ggPSBzdHJpbmdTbGljZSQzKGhhc2gsIDEpO1xuICAgIHRoaXMuZnJhZ21lbnQgPSAnJztcbiAgICB0aGlzLnBhcnNlKGhhc2gsIEZSQUdNRU5UKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoUGFyYW1zLnNlcmlhbGl6ZSgpIHx8IG51bGw7XG4gIH1cbn07XG5cbi8vIGBVUkxgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1jbGFzc1xudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCAvKiAsIGJhc2UgKi8pIHtcbiAgdmFyIHRoYXQgPSBhbkluc3RhbmNlKHRoaXMsIFVSTFByb3RvdHlwZSk7XG4gIHZhciBiYXNlID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgc3RhdGUgPSBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIG5ldyBVUkxTdGF0ZSh1cmwsIGZhbHNlLCBiYXNlKSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICB0aGF0LmhyZWYgPSBzdGF0ZS5zZXJpYWxpemUoKTtcbiAgICB0aGF0Lm9yaWdpbiA9IHN0YXRlLmdldE9yaWdpbigpO1xuICAgIHRoYXQucHJvdG9jb2wgPSBzdGF0ZS5nZXRQcm90b2NvbCgpO1xuICAgIHRoYXQudXNlcm5hbWUgPSBzdGF0ZS5nZXRVc2VybmFtZSgpO1xuICAgIHRoYXQucGFzc3dvcmQgPSBzdGF0ZS5nZXRQYXNzd29yZCgpO1xuICAgIHRoYXQuaG9zdCA9IHN0YXRlLmdldEhvc3QoKTtcbiAgICB0aGF0Lmhvc3RuYW1lID0gc3RhdGUuZ2V0SG9zdG5hbWUoKTtcbiAgICB0aGF0LnBvcnQgPSBzdGF0ZS5nZXRQb3J0KCk7XG4gICAgdGhhdC5wYXRobmFtZSA9IHN0YXRlLmdldFBhdGhuYW1lKCk7XG4gICAgdGhhdC5zZWFyY2ggPSBzdGF0ZS5nZXRTZWFyY2goKTtcbiAgICB0aGF0LnNlYXJjaFBhcmFtcyA9IHN0YXRlLmdldFNlYXJjaFBhcmFtcygpO1xuICAgIHRoYXQuaGFzaCA9IHN0YXRlLmdldEhhc2goKTtcbiAgfVxufTtcblxudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcylbZ2V0dGVyXSgpO1xuICAgIH0sXG4gICAgc2V0OiBzZXR0ZXIgJiYgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKVtzZXR0ZXJdKHZhbHVlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaHJlZmAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hyZWYnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ3NlcmlhbGl6ZScsICdzZXRIcmVmJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5vcmlnaW5gIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdvcmlnaW4nLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldE9yaWdpbicpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUucHJvdG9jb2xgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wcm90b2NvbFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncHJvdG9jb2wnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFByb3RvY29sJywgJ3NldFByb3RvY29sJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS51c2VybmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXVzZXJuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICd1c2VybmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0VXNlcm5hbWUnLCAnc2V0VXNlcm5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnBhc3N3b3JkYCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3Bhc3N3b3JkJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRQYXNzd29yZCcsICdzZXRQYXNzd29yZCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hvc3QnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3QnLCAnc2V0SG9zdCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0bmFtZVxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnaG9zdG5hbWUnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3RuYW1lJywgJ3NldEhvc3RuYW1lJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wb3J0YCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcG9ydFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncG9ydCcsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UG9ydCcsICdzZXRQb3J0JykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wYXRobmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdwYXRobmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UGF0aG5hbWUnLCAnc2V0UGF0aG5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnc2VhcmNoJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRTZWFyY2gnLCAnc2V0U2VhcmNoJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5zZWFyY2hQYXJhbXNgIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNocGFyYW1zXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdzZWFyY2hQYXJhbXMnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFNlYXJjaFBhcmFtcycpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaGFzaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhhc2hcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hhc2gnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhhc2gnLCAnc2V0SGFzaCcpKTtcbn1cblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbmRlZmluZUJ1aWx0SW4kMShVUkxQcm90b3R5cGUsICd0b0pTT04nLCBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlcmlhbGl6ZSgpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI1VSTC1zdHJpbmdpZmljYXRpb24tYmVoYXZpb3JcbmRlZmluZUJ1aWx0SW4kMShVUkxQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuaWYgKE5hdGl2ZVVSTCkge1xuICB2YXIgbmF0aXZlQ3JlYXRlT2JqZWN0VVJMID0gTmF0aXZlVVJMLmNyZWF0ZU9iamVjdFVSTDtcbiAgdmFyIG5hdGl2ZVJldm9rZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5yZXZva2VPYmplY3RVUkw7XG4gIC8vIGBVUkwuY3JlYXRlT2JqZWN0VVJMYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCkgZGVmaW5lQnVpbHRJbiQxKFVSTENvbnN0cnVjdG9yLCAnY3JlYXRlT2JqZWN0VVJMJywgYmluZChuYXRpdmVDcmVhdGVPYmplY3RVUkwsIE5hdGl2ZVVSTCkpO1xuICAvLyBgVVJMLnJldm9rZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvcmV2b2tlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIGRlZmluZUJ1aWx0SW4kMShVUkxDb25zdHJ1Y3RvciwgJ3Jldm9rZU9iamVjdFVSTCcsIGJpbmQobmF0aXZlUmV2b2tlT2JqZWN0VVJMLCBOYXRpdmVVUkwpKTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcblxuJCQxKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIFVSTDogVVJMQ29uc3RydWN0b3Jcbn0pO1xuXG52YXIgZmFpbHMkNCA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkbztcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDIgPSBnbG9iYWwkMy5SZWdFeHA7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDEgPSBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZJDEgfHwgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhJFJlZ0V4cCQyKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kkMSB8fCBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XG4gIHZhciByZSA9ICRSZWdFeHAkMignXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZJDFcbn07XG5cbnZhciBmYWlscyQzID0gZmFpbHMkaztcbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRvO1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMSA9IGdsb2JhbCQyLlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsID0gZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMSgnLicsICdzJyk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG52YXIgZmFpbHMkMiA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkbztcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsJDEuUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWROY2cgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnKD88YT5iKScsICdnJyk7XG4gIHJldHVybiByZS5leGVjKCdiJykuZ3JvdXBzLmEgIT09ICdiJyB8fFxuICAgICdiJy5yZXBsYWNlKHJlLCAnJDxhPmMnKSAhPT0gJ2JjJztcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQ0O1xudmFyIHJlZ2V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG52YXIgVU5TVVBQT1JURURfRE9UX0FMTCA9IHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsO1xudmFyIFVOU1VQUE9SVEVEX05DRyA9IHJlZ2V4cFVuc3VwcG9ydGVkTmNnO1xuXG52YXIgbmF0aXZlUmVwbGFjZSA9IHNoYXJlZCgnbmF0aXZlLXN0cmluZy1yZXBsYWNlJywgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBjaGFyQXQkMiA9IHVuY3VycnlUaGlzJDMoJycuY2hhckF0KTtcbnZhciBpbmRleE9mID0gdW5jdXJyeVRoaXMkMygnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyQzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlJDIgPSB1bmN1cnJ5VGhpcyQzKCcnLnNsaWNlKTtcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgY2FsbCQyKG5hdGl2ZUV4ZWMsIHJlMSwgJ2EnKTtcbiAgY2FsbCQyKG5hdGl2ZUV4ZWMsIHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmckMShzdHJpbmcpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IGNhbGwkMihwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gY2FsbCQyKHJlZ2V4cEZsYWdzLCByZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IHJlcGxhY2UkMShmbGFncywgJ3knLCAnJyk7XG4gICAgICBpZiAoaW5kZXhPZihmbGFncywgJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyaW5nU2xpY2UkMihzdHIsIHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBjaGFyQXQkMihzdHIsIHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBjYWxsJDIobmF0aXZlRXhlYywgc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gc3RyaW5nU2xpY2UkMihtYXRjaC5pbnB1dCwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UkMihtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBjYWxsJDIobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG52YXIgcmVnZXhwRXhlYyQyID0gcGF0Y2hlZEV4ZWM7XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciBleGVjID0gcmVnZXhwRXhlYyQyO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS5leGVjXG4kKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xuICBleGVjOiBleGVjXG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQyO1xudmFyIGZhaWxzJDEgPSBmYWlscyRrO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDU7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sJDEoJ3NwZWNpZXMnKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbCQxKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kID0gdW5jdXJyeVRoaXMkMigvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMkMihuYXRpdmVNZXRob2QpO1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMkMSB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgY2hhckF0JDEgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDEgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQkMShTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQ1O1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzJDEoJycuY2hhckF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkMSgnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkMSgnJy5zbGljZSk7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGR7MSwyfXw8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCYnYF18XFxkezEsMn0pL2c7XG5cbi8vIGBHZXRTdWJzdGl0dXRpb25gIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbnZhciBnZXRTdWJzdGl0dXRpb24kMSA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZSQxKHN0ciwgMCwgcG9zaXRpb24pO1xuICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0cmluZ1NsaWNlJDEoc3RyLCB0YWlsUG9zKTtcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tzdHJpbmdTbGljZSQxKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoYXJBdChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQoY2gsIDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG5cbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGc7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDE7XG52YXIgcmVnZXhwRXhlYyA9IHJlZ2V4cEV4ZWMkMjtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xudmFyIHJlZ2V4cEV4ZWNBYnN0cmFjdCA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAoaXNDYWxsYWJsZSQxKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwkMShleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdCQxKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDEocmVnZXhwRXhlYywgUiwgUyk7XG4gIHRocm93ICRUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbn07XG5cbnZhciBhcHBseSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYztcbnZhciBmYWlscyA9IGZhaWxzJGs7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRnO1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJG47XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDI7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyQ0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQ7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4JDE7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDQ7XG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gZ2V0U3Vic3RpdHV0aW9uJDE7XG52YXIgcmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFJFUExBQ0UgPSB3ZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAyNDY2Ni9nZXR0aW5nLWllLXRvLXJlcGxhY2UtYS1yZWdleC13aXRoLXRoZS1saXRlcmFsLXN0cmluZy0wXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvcHJlZmVyLWVzY2FwZS1yZXBsYWNlbWVudC1kb2xsYXItY2hhciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcbn0pKCk7XG5cbi8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoLy4vW1JFUExBQ0VdKSB7XG4gICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tdXNlbGVzcy1kb2xsYXItcmVwbGFjZW1lbnRzIC0tIGZhbHNlIHBvc2l0aXZlXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGdldE1ldGhvZChzZWFyY2hWYWx1ZSwgUkVQTEFDRSk7XG4gICAgICByZXR1cm4gcmVwbGFjZXJcbiAgICAgICAgPyBjYWxsKHJlcGxhY2VyLCBzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IGNhbGwobmF0aXZlUmVwbGFjZSwgdG9TdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PSAnc3RyaW5nJyAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgVU5TQUZFX1NVQlNUSVRVVEUpID09PSAtMSAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgJyQ8JykgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVSZXBsYWNlLCByeCwgUywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSBpc0NhbGxhYmxlKHJlcGxhY2VWYWx1ZSk7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSB0b1N0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcHVzaChyZXN1bHRzLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXJPckluZmluaXR5KHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHB1c2goY2FwdHVyZXMsIG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IGNvbmNhdChbbWF0Y2hlZF0sIGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcHVzaChyZXBsYWNlckFyZ3MsIG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHRvU3RyaW5nKGFwcGx5KHJlcGxhY2VWYWx1ZSwgdW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IHN0cmluZ1NsaWNlKFMsIG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG59LCAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgIVJFUExBQ0VfS0VFUFNfJDAgfHwgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgaWNvbiA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVN3QUFBRXNDQU1BQUFCT28zNUhBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQUZ6VWtkQ0FLN09IT2tBQUFEOFVFeFVSVWR3VEd4NXJwTE84WU9ZeDFPZzBseTI5WDVlelI0bVQwdGlqaTRlV0o5NTNLR24xSnhzN3FCOXh2ZkQvVXMwZ2R1dTh5ZWg0SE9xNzRkRDY0N1I5MTI1NmVTeitqODJjYnZnL2RTai9MdUw3OVdwNnpDZjI0S045eEFOR1JBTkY1OWQvMFcrL3RhYS84aU4vM0hMOXVPbi96NjM4QmlsN2wzRzg0VFArRkhCOG81QS8waTkvWmpVKzQ3Uyt2cTgvNFF5L1M2dzhPK3gvNVJwL3d5ZzdHMlQvcytUL3ZPMi8rcXQvMXFwL3FEVi9IeUQva2k0KzRSNy9xblkvdHloLzFHeC9wdFUvNzZFLzJiSjlMZDgvNHQwL3B4ZStYdk45aU9xN3JCMC8waTg4YVJrLzZwcy96KysvbmFML21hYi9tR2gvcFZNL3d1YjVtR2QrZkFFT2hFQUFBQWdkRkpPVXdCRXlXS0E0N0VLSmhuRmx1R0E2bDNINjdEdTZjcmROT1hzNXEvSTY1cmNRYmZCOUFBQUlBQkpSRUZVZU5yc25FOXI0em9YeGlkT0c5dE5RcUJ2U3JMS2VLR0Y3V0l6NEowV2dTQ3VEYzFzN3ZmL01xLytTMGQycDdaa2Q3aTBTc1pKaDN0aCtQR2NSNCtPcFA3NDhUMys0eU5PRG9mREtZMi9TWXhnZGJoY2ZsNHVsOU0zclk5WnBaZWZiRnd1NlRlTUQ4ZEp3UHA1U2I2bDllRklMNXpXNVREb1dyRWMzNXdFanRPRkRXUHhqRTJhSk1rcVdhM1c2L1dldnVpZ1B5VkordFduZ1RnK0hRNThQbVNEUWxxdnQ1RWF4K2pJQnYyVVk3dW15TDZ1MEppTUJLNkRwRVRwNEtxbUwvbmdYOWhud2NFSllsOFRHSVYxRXB6T0VhTlVDVUJxRlB3UGZSWDBXOEdmRlNQR2dYMjU1SkNjVHB3VUJ5VlkxV0FVL0ZId0x4UldWM1JkSVlHdHZoSXZLcW9WSTBXcml3b0dLMUNEdkxpOEpEb3VzZTVMOFlxVDA4TTJPcCt2VkZPWWw1NHdKKzVQa3Bwa0pVa0paWWxpcE45UlYxTmU2OVVYbUNPVDB6WTZYcSs0S2lwN0dFWUdtS1pWeU5GMWdoajl3aHgvL1pmbHRYUVlURS9iOHhuVFVlRnIxUjgyTG03dnd1UGg2Q2d6OWpyK1RWeDhNdCt6Y1RndDB3NklrMzEweElKVkpYeGRVYXFnc0l6SDF3NnRqbGVreHJWZHBYL0ZTbGI3elc2M2ErbHJ0M3Zhekc4SkZpcUhWYTJld09RTGxSNzBXMW9YNThYbGhTaXY3YWVyS3o0eFV2ZDdSc2U5cFdPMzJ4eG0vVmZFNlRvNjR5dDFLeUVzZ1V0OGNrVDk5R0RzSFVwTDZvcTlFYUtUNCtjV1k1d2VOcnZmYlp0bE53cUxma3BjTTBvOFh0Rk1oWmxSVVQ3WVlETEtFdG1oc3VyUUpOTzZSMHNFTDBicmszRlJXZTMreWRwTUR2Ymx6cER0bnZZei9TUGloSVlGekhSRllZRTZ4TWF6Qm5KV1lUeXJoc3JpNHVxRWZTRVNQWCtXZGNXbnphN05iamVtS3lZcFZvYi9NbDVadTl2UDBjbU1FMWFCeFpYRHVTcGRLV1NHbEswcXhVcXRlU3hVcGhBN2hMb09zZWRuV1ZlOFlpVjR5MzR6VFlrWDlhNGJoWGVqdGJnSnA4VlFjVm1KdURBNEd5cDdkMks4VEZuMW9HbkpXYkVqcU81eXduTEU1K2lLOG1HeUVuYkZsTVYwZFdPMUdFeUxtaFdkQTFrS3JkaVRHN3kyZHVQdnNzM1FXeDFxVkxWTFN4WmlKd1JXZE9RVHhKWHNkOXFyR0t2TUhzem5uNEpvY2JOaWM2QjVLV1c1d2xMTUJtYkRlc2pjT3pONEtaTGowdUtLRDd0V2NzbGNWSUpnaUxiaTFmYXNTWWszcDJXVUpUc09kc3FxSEdWQnc5STVxN0JRY1ZwMFhseFlYS2ROYTRUbHFrcDgvdU5OaTBVcnp1cHFhd3NMZDhjWXFxb1hTa0hPcXUwRUQ1U0YxQXNoUW8xK3RSeXRlTStGMVJoR2pYeTBvaXdaTFU5dHhXd2RLRWhwVEtJSWpXdjFwRFVRSEdwWFc2NnVVR2ZUV2k4V0lrNVBkNkFvNVZxTk5EQ0dxNzE3MFdJeDlJcUZxcTRpdVhOVVZ5V3I5NVJWRGVZc1NLcXdQRXZTa3JnUUxjWEZoSFcvU1R6OFQydXF6OURLZkh3clBWaXNNUC9HU1YwdFpka3h2cTZxZ2Y2Znp1KzFoUXNvQyttd1JRZC9QaTVrWE9ubXQrSmg1M2ZING1rRzIyMG0vZ09TaDBncHl1QlNWVmhodU54UnNiUmZoKzVzQ0gxTENxcGp2TmczOWtIWXJMaUljZkVxWkh3YWg1RHpNOHRiazJnbGJCYkVWZ0hLcVZBTk14VmlKenZBcFdGZDl3T1djbmc5RlNySFF0THBhVUpkZ0ZhOGV1cUhoZUV4emVXcHRSdXpNZ3F6Z3BhTzhiQ2xWVlh1aG9YU1ZUMGtMQ0V0d1VvK21HMmh4d1ZveGV0ZE5oWVcwOVlrWFVGUTNMSU1KMU9KR1BKeUZvaXFWVnJENks2VnBTZENwUzB4bHFqRWREOGExaFJhOGZZczhEaXVCVXJScFNXRjFlLytEYlN6ckNxMFlwYWFEanYybUo5V3V0bGw5dzh4TldLR3BMVDI0MmdsMGZuREVzUkR5bEtrcW9GMlZ1MjRGb3hZY3NHanlwRFFFYTNucFJWdlJsbFd3OE1YWFdHUHBKVkUwYlh2V0NhZDJzTENmYzl5WmtTb3FrSTNzdXlsam5RcnJpbU9pK1E1bXBsV3VobnA3ektxVW0ybG82d1FscUdxUXlnc3RlREJvQUZmdVdzZHAxT3F1dSs4MmRCWnlvS3VSZGhyM2txa3NNYlNvdjhkamE4anRaVnNveUZseWU2RHJTd3RMVnhieWRRQTA1aHFXMXFPWjFtclExR0VOR3l4eDd5MEtLemJPRmdOejZhalhUNXhvZ08rMmowSDRGbTJ0TnhlcVpYZ0I1U0YzSlFGQm5XdGVmUFcyREpzVkxSdlI5S0trNEdncFYxTFNRdjBIakRjd2g4Q3BUZkNRSFBHV0phbXBGMSt6cncxMnJQRWxEZ2hRWEJhMlBWM0xGYzlsckl3YkN0YnMyRXhCTXpPbzlaRXFDdFFVcExGbU9mSDU5bFcxZW1ZQU4rMnJiMXNuRURySFdtNTZRRTd1QVptUTFpSW5iM1FrYVRFZ3doZ2lJZ1BOQ2V0ZE54cXB6VW1uNGtleEZoYXVPZGJZRFZ0ZHdBcjl6emI4SmFoeXFTd0NqdGtTNHZ3d1gvSzgyZzdUMzhybnFnczlSZjMwUzUveFg5UWxoTzFhdk55bGRWemVLZWpiS3BRU29zSTQ2SmhpK1J6eGExMDlEb2FqRnMybnRZZnBOV2JFSHN0bXJvZnNtUVpGckQ1RGsyTENKTm5wa1dCb1hsTVBoNEpxNEVORzU2M3ZMVFZDMXFnRHV0K0Y3NS81QWlVSWZSMzZlcjZXeTRVUnJwNWJDc1pCYXZwYjJmY1J2YTMrdHFDTWI3Q1RnK3c2cDhxZmI4TWtlYmxtcGF3ZU9aYmxGbDVuS1BSSEh1VzRmaitGc2hiZUlnWFBQQlFnU05hOGl3cG5BanRJalR1VG9CcHlhVzBHdlBZRmxYV1BZVFdoRG5STkpjeDFyczh5ckMwWmZXT080Q0dBNWdMa1cxWnJKMnNrQWxCV1FQbDVDWGN0cGl5ZkdHMTJjaVZ6MGxXSWpaTGE2T3N5ajNYVnRmdkc1WW1WVmlHWmExMXBHVVJFVXBGZXBEU0lqUFlscWV5R3RYZm1wSzNzTlVBdEdqMVRtbkIzcCs3YVdpT04xalcza2xKNlRvRXdxS29hTnA2aVA4S3JFYTUvZGk4ZGJMblJOeHJsMVoyMUpMTFJKZ2QzTU16cnJ1cjdFNlFlUUJZcENSUk1rUE84aXREdGJjNHRtTnpCZ1p2dzNLYjhBTTdQRUpibWhYWU1FU2dqMFYweURJMW1ITnBsY2RnYWZrYlBLZkY5aFBIbkEwY1dQbUFyR1YxYWNDSnR0NStZUUg5eW5Zc2d2UzZFRGxsU0duUktCL3M4UUVHYjNZeHhzNkpnNVlGdHl5QXJBcG5iU2pQZFBjU0tRTEtVZ2J2ZUZZZTd2RkIwV0ZLZjZ1M2tZaEI5d0gybGpVckZVcnJvZTFDSTZxT0dHRVJoRkNmRS84SWxWYVlzcVowYk5US0IyT1ZJckJUaWZKeTRjQVIzSGNXT2hLWUcwZDdNK0ZjMHZKVGxsZC9DODZKSUdycEpRL29sYXFMVFhWdG9TcXNSR3BXT1RDNW0zREZLVEZRM0xWQ2M3eVhzdHArZjJ2VW5vL0pXMDQzWHNiU3VocTRrREowN2hadXJNSkFPbUJYaWxvWkppM2ZCTi9Db3lOc1B6R2RzUEt4WVptenk4S3ZzSzVGOVdVb2swTFhJcUNmYkNKRHJsamxZcFJoMGtyRHl0QmFKMDdSbHVOYThKajNVVjBpZjViM3B1MkRwSTZ5WU1BeWpRWXJNaEQ5Q3BWV0hCd2RWSC9yOXhSYUlNVGJUUm9CYXI5YUpXS3MrSDFYU3F4bjhKcFZKMmREaVFyQktFcUFzZ0tsRmJhUWhubHJkQ1Zld1RhK1ZoYS9YODkraVVNTS80OUVBQ3NLYy9JZHdmTU5CTFJJa1d0WXVmYjVJR2t4WmJFN0F0TVhoOW5BZWZudDZQMUVyTmZWOGlZUHhtZDJRZUtkUzN0eHNscFRYUEplVTFjZzVQUm5VSy8rQkI5TFZETklpKzBidHUyZjNHZzB2WkZuYkhRUG9tSzNVMFFncmE3bmoyNklzOXMveHlPbFV4UkRaOWQwS0xYamxlYWxQQ3NuUWRKSytDWnJtODB3MmltVktMcUIvSG9LVjlXN29vSzRva0oxc3hDTVdVUWxkMlFiRnZBcnVwYm1yWnBWZ0xMK3h5NkRaZmR3VXF6TE5TMXZpV1hPOVJwdGsxRTdlMXhkdEFhVmJTSFUyNm9Bd1QwM1ppV1psYlFPL1pzUEZOYnJMYnNOSDdxZDBnelU1N2ZTOFZtZVg5U2tGVGora0grU2JLTmFuR0NUSjdFNjN2Z2pDRVlzb3VaQlJZbTdPelA0a0w0V2hmWHI5WFliM0grZVBqZmVzbVlDTGQ2SnYwNjhiTVBFcFkvTzJDZG0xRTQwc3FyUXJVVE95OS9pR1N4RnF3bGdwYzl2TlU5aks1SGRBSjRrSzNXKyt2a0l0K3c3cXptSyt2MEdDMVFlbGg0NHJGLy8zdVRONkNiTXVXNmo4OWFQbEhkc3p0SDB5N3JzQXJHcXhNNXErQkYzQlczbEswV0xMUkQ5TFY3QW90cTZaekp2TmI3UndmUzNSczJKbEJhTm1sN1hScEx0OFVpb3JBcHd5a2pIaHR3T0M0WlVLVC9LUjk4NmxMQW9yWUVyZEY3cjYzYTB0dGJlZHdPcGNSSFNkWENYQXNZRzFmSWpEaS8yOEsxREJZdlRhbHZ2NE9EMHQwWnBLL2IvSlJ1TWxyTUpUZHc4Q3JPN3BhejhKUlNXMEZaSXg5VGE4aG1wclpCdUNhV1Z5LzFDR0xHc3VLNTRsY0xkcGJKeTd6bzBzTGh2WmQ3N1lnMDROSEpmbnRZMk1nMWxnbnJ0UHVEclNsb1MxK056R2dwTEpvaDdnTEltOTdkQ0d1TGJJNEU3OW82L1c3aElxVm1WdEF4OTY5Q0cxVStuUG5PaXpCQy9GNmUxaXRSMkRobFk1cGp1cU8xWlVsb3ZxM0JZZ2xicjVmT05YMzhycENXK2p1ejlIT1Qwc0d6TEtxVnhsZUx0YTFvUUZ2ZXRXM1p2NStsQmJCZitIUXZVdHVTQm9qL1ZvUEg0VXFBcWMrSm5XZzRzT1NlMlFjdEVmZEJtd3YxRVA5dUtPblVlQzJncUgvWXJTWW85L0pLV0M0dlR1czBnckFucE5MQVFZY0p5bHM5bGJtSkRLUTJlUGw3bWdSV1V0NXlZMml4Tkszays4Z1BKVHNDeWRTVlFLVXhTV1crUFhodjVmVmdpYjRWMkE2ZjF0L3lsZFJ3TURVNVRSdkF5MGFFczBjTk1zR2JwYjhsZm50RTB5OUpLb2lNNzZPNElLN2VET3pBc2h1cU5LZXNoblFtV1M2djF0cTN4OXhQOVhZdllzS3lPZThuZW1wWXNRRVhNeitGRjgyK1lWdHVHMnRadGNkK2l5WlJZVzZudktjdFFrdU1sbVV0WnByL1ZodnNXcGJWZGpsYTZQWlpjV1E0cUtDcmJzZGg0SzcweXZGYlc2OENjNk4reVVibTBiVGl0NWJRVnI2Sjh1TjBPRE10VzFodWZEbjB5UE52ZCtUV3NMZjlFcWhZKzdMTloyT1dUbDM3LzJPN0o2TGhnQVhzTGdjVnh2YzZZdDh6dlNXS0x4bVpKV3VuenNYUnhsZHphUzl1dGNoc1Zlejk0Syt2MTErdXdid1ZLcTJrRnJIWTVXalJxbFdZamg2akZvRnc4QTFCdkZxdkg1eUJsRFduTHQyVWo5cWNiUnF2aHltcitUOXZadFRhT1pHRzRtNTFPM00zQXNET0VnYUVEWGhqc3hyNkpjWHhoM0FLTEhRbkZEazY4L3YvL1phdk9WNTFUVmZLSHBKUmt4VWw2THViaE9XK2RLdGxPOVZHMGZHaEZyYWpzeGlpaGZxaThnclBMVXBwaHRiaFY5bGhINHdkTjRmakEzUHI4OFBjUHZjYWhYUVpkZ1JvVnNlclVhSEVaaWx1R0dkNVA3QkQwVHFleUZxMTh4bjhZcmRIdmY0Zm1YV0pkMW9OUmc3V2o4ejhQM1dBOXpjbXNsdHdxTzlKeWJRTWRPRDZvRXUvL2xYUlkwWDZNVElFRUNpNGRZYzBGMUR6ZlFkeTh2K1VKNGJuVTQvRkRhRUdubFpnbHBIN3NvZzZMYUhXR1Jiam11WmlIL2EzNkpxZkdKYkdLWURtM1B1SkRNU0hoQ2RSL2JSZjZROVhlenVUN3JwZFo4L1pLN0hESGd1dFBUb0wxN1FOb3VlVWh2eGc1dEEyemREbTRJMmE3Zm1YSWF1VjUzWFkvc1E1MWFNV3EzT0hkdXY4UVdET0pMSVhxaDQ3MDNVeWZ1eTZMUXpJTGVjM1QrVEI3UDdFK3F4YVFxbU9yaU5jSDBCbzl5RXZWZUI2Y21iVGF4Y0IySFZmU2JCWUF3MkpNN2JweWZ3dUxjSW1KdFJ3bmlRV1g2dHZRdEQ0L1NOZE9HNk42Y2FQN2RqbmMrUEo1Z014cTcwNnZ1Wis0WkxlWVZTU1dnelc0Vzg2c3pLNk1YVGRyV2p0NGRIazduWmcxbjgvVnRCaFhJK3h2amMvdWJ5M0pxbVdtYVNDeE1MYUdkb3RnaGJVZzM1VUlNczB3MXluZWQyaldmZWZNMHAzcHZHVVA0cUpad291Y0d1c0NKRnArZkJ2MGsvaEdEei8wWXREczhkbmVLcUNhREdLV1pOZFQ0dGJsanJUV2RiaE1wa0ptVlQzK09pUXRCMnVtN2puYnhZMHFRSjFZUGN5YWkxeTZpOGoyVy90MnFaWVJxWEVvdnpwWVZRM3VGcG8xaTdZWlF2MzU4NmNwUVc5V2w5Mi9YR2FaNkRLNWRiNC9MVG15SXJHcWNId0VMYzRzbStuY0pFU1Vob0wxRkJxdXJGcFA2dDBGN1F2Q2pGZHdGbHFzUVduNU1reFd6cnRNdHlDZ0p1NHloRm1tNDVvbmJwWG5iMUVzV3hvc2ExV0J0SWFhRXdGV3ZCWlVDNXVJRmRMcUR1c1lWYUVxUXVzWHZWNytUT2ZPaytCWU5lMitYWWk4OG1Pb2xJZUFUMi9naEVsd05yT29lcG5sV1Izbjg0eGhtUTZpOWZWYjNGMk4wNjRka1NtekNqOGVCM0pyOUNETmxlN1dkN3N3RDA1MlA5R25jQm1vRE1QTStEVFAzL05KdG13OG9uS1ptd2k1Rncya2lvcU9vaGlHbG9jRmJ1MVV0eERTUFZTZU9YcVU0VEZITEp2MTRGWU43eFZlMmkwc3RjaXhhYlhVTlZpd1dKVjNhNGhLRkxObWloZFR3aWZDS0R6cFVZWkhDMHphaHl3dGlLMTlWSURwUk1pTnU4MHJKWmFqOWZzQXRCaldUalVNTzkydWE3WHc3Qm53U09xWW1wVnUyK0E2TWJ6Ymx4djNmSWRseTdDQU1neGppQTRDWWFtSmI1Wk1mZ0dWWEwvODBzTXNWcXRsWm16dElKWnhneFVDcTlMclFjMEtjRzM4dVJtZ0VvMVp5cWJKMmFNN0xNYVZacGZzM2N5enRQQ3RGUm12S3U1SWJicUhDZ1JhZzFRaXdGSlRuMkdsbWFuSTZtK1crSFdNYUNWdUhabFczZGE1aTFUV3JGQ0RIdFZtc3htQWxvTWxRVFdUWFFXS3Awa1VWU0hnZitrZDhNZnNuSmoyWEVmY0NvVHcya3RvUmZ2dFVlTWVFcXNpcTF3WkFxMStmNnVLek9KZFBWMkNreFNTNTljUFZub2tYVmZjY2RXditIbVMvaVZZKzJYWXc0cTJSVFdxUW9lN3c3UVpoaGFZdFRQclpRM0pjdUpISDFoSC83RGhkY3hGbDR3Ny81ZEphOXBwMk9kV2c4czQyeXVOaXNYeW95Y3RiMWF5VXRaSkJYQW1oSXRwZFlTRmxFSXRKbEgveEl2cm9OY2ZkMy8rZGtldnZ2S3ZXRXYzUmRNYU5EMERtTVcwTnIxb2ViTnlMZFhFcm5DaTBSa1dEN2FMV0oxeDY0L2Z2bjc5ZklkLzdIWlppMWUxd2hSdDkxRllWUm16ZXJwRlpYaTJYNWpJVjhiV0RWWjlMQVdVa01vMUV0SjFBYXo3VC9mT3JWZXZWVDNXVnNVYjdySnlqa2l4V1FkMzlISUx6VEpOZWtCanJoT0ZxeGVzU0s0NHVwNFVMb0wxNmV0dmQvdFh2UGRzMDcycWtpb3NLcWExa2NaQnhQSzR1dE5DV0pOcy9jazFIb3Zlc0NEb2JYVGxObTNtSGhiOHg4NnQydDdJQ2JjbW9zQ3k2YjdoQTgwNjlLRkZac1ZhN1ZTcTZ5ZVR2bVZZR3J0RU1OdWk2bTFuTU12OTE1L3ZLS2RxdWxUU3Q1dHRHZGxwVUdGbHhEb2NEbzkzM1dpTkh0S0V1akFXUGMwcUxhdTVqcTlvd1JoZ2ViZDB1SHVwaW5RYldhOEhxWFVuWEFjZ0JheFdoNDV1eGJBbXFsZFFlT2lFUjY4eUxNc1NjU2xrOHpwZFd3c3loZ1dWaUZwVnl6VFprL1dnbEtBU0M2cnc0SEYxb3hWZ3RYUUpBNXRWbG9LcTFEbXZwOGZqWEcxeUNTeFBxd3B1S2JWVU14b2wxbWF6NFhUSHFSQmp5ejIrZEtFMWVqZ1BDWXl5aHpzN3dnSlNaVWxma3V5aXNyU0dCVmkrZzZqaUZXR1ZxRVcwZ2xncXNDQ3l3SzFPS2U5Z1JZMUNXbnhjZnd1QjF4a1djNEluY1RXYTNZZ2pOUkFLRnRHcWxybDkwY2lxV0N6TWR1QUVvMU51ZVZpWk9tT0ZCSnZGMVFYV0NNMkN6RUpteDFTeE9PYWZEQ3hQQ3pqVjBHQXBYb1haZEdlcENoMVg5R0JZcXc2NWhXWWxyR3dKbWt0dnN4QVhTRVd0UkdublJ0TjZHVmpnVnBYWmtwRVZZZFVhN29lTjlzckJXdDJjV3ptekp0cXN1Qmk3WjlZM2dDVTFTSlhJbHFYdFJBNFdwM3l5SG94UThSWldDQ3NLOWtETGZYY3JMUTlya1laNWtDZ04rSzVtTVN4R0ZxcVI3S3FqK0lKTEJBdHpxMXFtUFlQZHdySzlhSmdIb1FMSnJNT3R1UVZtSllqZ1hPZ2lOTjlNQm9DbEhIT1V5cml6NStnNnhyREFyYWdPdzNLd2tQV05GQ0V0Y2dRVmtzTHI2VFphWkZiN0taUjZaNWFETmZidi9pcjVVcW9xbEdxc2ZZdXE2akdCaGJSeU4xUE5QRmdZczZRQVYrSHd4RzdMTFFlcm5VLzRickhBaTc5TytwaFYrM09zMVFwVmlka1B2S2l2ZDVjVVZrUkxibnBWSWxaaDU4R0Rxa0dzUWpwWGI3ZjE4bFNHaHRXQ1NqQkFtcWpyb3J0Wlk0K3BSckVTd1VxRlM2bVZnV1ZwRllsYUc3VjhQdGk4SWtqMFpYWGpuQWhtTGZRNVlWRHFxWURxbDFrZTFqalFNcnk0RW8vWTUzUFk1OHlpRHNKc001Z0d5L2J1QjkxZkhZaFZHRGVrL09pN0FXTjFraHFrbjZGWVBjMUNZZ3hwckhEUlVzaTJxVmxZd2ExQ1o5YUdPeXluMVNGYU80Y0dTK042VzUxdWNHdjBmVEd4WGxuQkZndHRGei92Q3N2ZkxHVmE0TmhZY0NHeVk2MnYzckE4ck9CVzZMQTIwalVVZWkzSW0xaGhLZ3lrNFBwMjlhcmF3Ykpqb3A0M090MG44ck5GRDFqME1WQkF5ckhTdVB4M1pvS0VhbXlCeGJRS2ZUZEhsamdGcHhVdm5pMHFLY00zaDhxTjFaWDNxaFdzaVNxL0pzS21ZUHBmL2JzcnJKSSs2aGZ0R2t0ZGNvSkZSWGxzTll0cEZYYUpZelpHRDNieHZESmluVWdzcjlicHlrcU16R3FVUG5TTnFQa2ZUanJDMnFjZmtGeU9wU3hybmZpeU9mRnJHeXlrcGVmQlRhRVh6OUU4dUpKK1ZJbmxJNHZkdW9KV0JHdlNMSzRaQThFU1pQaTFER1ZaY3BOUnRwb0Z0RXpQWUJwUm5BTHRyb3dwUWM0c3hIWDZja1VsT2xnTituUUJrOWFyaDFsN09yTEFhbFdUWEpYdFpxRmJVUzlxYms0YzFFWXlMUWtGMXh0VklNWFcrK21LU2lTekNGZERsd3k1WmpDejhOUFlXcWpweU1jZTlnd3NjTXZjZGk0TXFEaXdiSVBsaWc5SnJRRFc2WExLczFsR0wvdTBTZEIxTjJ2dnhoZ2VsdFdlUU9Gbk8yRi9BVzdWNTh6Q2Zxc3c5N3owZ3JBdDNGRXNaUFVPUlhnNmdWc1hhT25NYW9TT01vMS8xYWgvMW5TSHhRY3o0eFBKN2VVem5zU3pzMlpSSlJaRjFMZFQ5VzNPb3VMR3dVMkdEdGE3dzNhSkZwblZoUEpyREo3Ry9nd2YvY3hpdTFneE9lR280YUFQZlBlZm5Id2VsbmVMMmxIZGltN09zcElxcEhIeTQvMzlJaTBkOEUyc1VmaEJOQXYwZ0lWQTlxS1h5TVdvOE04UXdNY2UrdU1TTE1vdHV4cTAyd3dacnp3cVlZVzBQS3dMdER3c0I2S2hTeE5VRW9LTnFWUDRUVmRZMlJGd3VWSFRROFpGV09CV1llN1FtM1Z6YnBIRG5UdE9oRy92UE5idnAzTzBSdCtiaGxHRmNtekVwc1k4NGNlZ3NPendSWWlWQ0k4cllIbTNIam5pRHh1N01hck1zbXFGeERvSnFiVzdubk9MWVpGWUdsbGpac2Ztdzh3NlA2NkFCYlNDVlhiL0tyQ0twc0ZRZ0dUV3liRmFyOC9SRWxndGdrWE5GM3pwRE92Vi9jKy93dGsya2wrOTFsZkE4cSt4ZVRRTlZuVFhLK01WOGpvUnJUY1F5N3QxV3JmVDhyQ203ckRFd2hGQ0t5UlpEMWl2Uk9zVlR6N0NVNDhIamozOTQydk1ndHg2REh0WXVSb00rd3pnRmRlZ0V3cmFCakRydFBabmUyNDVXRk9EYTVFeVcxaGluYzE2SlJwQkw0V0lrZmtUQm43emNoMnNUL2QvM2xWS0xMTXpHdEw5emV6TVlMeEx1SzlKcm5Xclc2UHYweW1nbXZxdkxRT0xrODlGSDFpdlRJVWhBUk90R1A4Uy8rWHJsYkErM1ZNbDR2YlZKb2NxNnE1d0luUzAza0xDcjVsVzlwMWNEaFp5aW11eGFUTEp6NXIxTVV0WG5zWWtITVV0UDE2dWhvVzBIS2VWZVFWSTNHQ3RRc0MvMjY1QnhQSXBuLzNrQ2pacmluS2RJN1lJMEhxWkpWd1VNRXRJZjNjdExLakV4NDFlNTZSM2NsQ3NsWGdsV2dHa2R6cldiWlVJc0lEVjlLSmJJZlM3d29wTnVqeGVyb2YxNlN2UVN0YlBxaDE5VzBXc3RGbHJNV3Zyamh3dGhCV0FZWDQxVFd0K05VMC9XRmNSZW4yaDgrVVdXT2lXYmJIUzJ4T3JSS3QzVVlwVGZ1dHdaV2dGV09RV3hEeE5rUGtrVzB5N3duclpueVVFcHg5TXl6LzU1d1pZUUN1OFNrWmUwaERGTyt6NXVhN2h6WGdsZ1lWamtxSGxZVDFQWTJEeXBTWDNoemJyaFZHRmc4UzZ5U3lpdFVuN2R0VzRVek5LdlpVbXBWazV1VkphRHRZelk5SzB6ckxxQ3VzbDhRaUJ2SVRuOGlNZWY5MEVpOTNLUkx0WjVtU0xrT05xNjF2VEhLM1I5MmVqMXRSWTFVaUc2VEh0QVl2Tm9aTXR3cnJqSWxUam45dk1JbHE1bGJQYWsxRzVya2dKTGpkbXArMDJwZVZoQWE3bkprbjZXTEplc080QkZ2SUpHVzRqS2dMMThvODdialRMRGFBVnJRZERXdEVzcUhDWnVOcWlYT3N0RHR0dkVheXA4YXQ1YmtJM2thdkhIbWE5aEhLVFFFOG9NU2wzM0E0cmRTdnBHVUpnU1h2bHppMkgxUmFLTVhXTHlqQ3V4UVNVVXF5eldWSnNKcGhTVE15cG8xbWY3a2RJSzREU2VhWGJxeld0Q1kxWkFzcVBuNXFXZy9YOGpMUUkyclQ1bnlSK25sZFhzMTVVUU9reU5KZzBLVDg2d0xLMDFCN3k2aTFlNWRpMmZjc1p2eVc5dHR2LzgzWitQWTNrV0JTSHBka2taQnRsSGpZdFFyOVVsYUNrbGlYVUtHdUlaQ2xSS1E4UWJRbFUrZjdmWmUxNy9lZGVsOU1UWE1sV01tbUdIcVRoMStjZUh4OVhCMEZwQVN4blc3WFYxOXV5YjE2MVR4VFpCdjlPRWtIcTJ2TEhGdjdKZWpzblE0dDJvazVaZThmS1ZET2ZldEV6amQrS2k4ckw2cGNSMXVyeE1kQ2EvRFNvR0MrdHJDNm82NDFSc21JYkFvdk8zbjhQaU1xajBzcktlaThHVDR0Vzd2dWVydllybGtZQmxNZTEydUVnQm0xNVpjRkxaNEIxYjV5VHcxVVA4aXlBbFJCV3dCTmU2TFhJZk9NS29QWHhZVzlZMi8vblk3K1BodERQbjk4UGtoRlU5bFhweTd2ODVDZm9hcm5VY3FxSnZLemZMOThJdDhCc0FLd2VLZnZxVENwb2F0dVlSNDVuTVczdDlkT2RPbitRTEpySzdadlZocnE3c2F5Tk1OckNCREg1MlNFcWEvUEU2T2wrMFVzTVgwOEVhK3VsNWZod1ZUWDZ1Y2grUzVUeFA2L2hGaG04RlFzc2EwK25jUFVaenlDYlE2MHRZWEJwWUtxNC9vZjUzeGdqTEZSV1I1VEZva1NjVS9OZ2JXT0hzb01YSnBDQmdzY0FXQ05EQzZLb3plNTdYN2Y3Sk9wWmJieXVnckxFQnFkUUNWR1llMnhHWm0rNHRMeWN0cFo4RkQyd042K3ZYRmhiTW4zYlNGUkpWRU9VaGRyNmNKRVU3cFFCVGg5aEN0bkZTQ25yV1JxVlZsWnIxc1R4ajUrMVFRVzRuTGFpV1h6anUreEJ5dG9HVWZFNDlaNGdCZGNRV0liV0I0bWpFTm8veUFqUy9UT0Nvcm9DZXpkaktJcTJiYS8vL2UzYno4N3BDclZGdlFzY2ZzbEJ3Y2REWVBVaVFrcFNJQ29BTmdqV2hadEVSMnRGOTRNc3RxK1l0eXNySzQxS0dHS0Z4blY5ZmYyWGh0V2h0R3FucmJBcThqMlFQOXNZTUlZOVViMGZHc0FUS0l2UjZqVU5uL0V5U01ZUWRXWHNTcjhhYmNIMVdIZUl5MHFycGh2cjVWc29JMnF5Q2NxSEZSQzlwNDNLVThLcldneDlnN0J2ZWsyMDQ3Zkh6U0F4ckUvcjdEd3lXRjJaMENCVUlkUXY3VnBGV3hRYVdXMEdzZXZxOUN4YWVYR3Z6NFMxNVZ1Wjl5Z2xiUGtBR2xURFlSbGFSbFFtdi9lUFUxMHJzK0VKU3hoWE43VEVwb0E1ZE5KcTJ6ZXFyYzV2clAwdnhNTHNKT2JDT2p4N3lDcFNWblVDWmVrRW9Xa1paZTAvVVZ1cno1NWZSYkp5am1XRVpVU2xnUmxWYVpFaHJTV1pSS2V0bEtnR0tpdXNmTzlwVDJjajJGVFZjRmlnTFh1bnpIN2ZXd1hqQXNzcUMwaHRRRnFnS0dHWUFTelUxcktqcTJMdGFIbU5MVU0xbUE4cjdWVjlYQld3YWs0Q3kyZ0xJdForNy9zcm5xNzRNaWlVM1JRS3E2eTJMZHpWSWkzQ3FyWlBqd3NGOXJZOGpiS1NzZ0pNMjBoV3AvQXNxNjFQY3dpeC80eld3WTJ2R3J5eWhOMC9ZMnd3Qmwrd3kyc3JUbHhkV0J4SmpsaldBMkF4YVRWK0RXeElEbldpQWx3bmdXVzBaZS9zNDl2Qk9MZTdyZ0cyaFBwaHJwMEExNElSTElUbzA2cHRvZ2RwOVRZL2c1V1ZTRlhjMXdPdXhXbmV5OTFNNGlxeEVyTGNEbnZuWUZkR1dJQk1HVllRVEF0TTgyM05KdEUzZ2gxZkdIRTlQQW1zSGlTTmFGdjUrVHVsc3F4dk9WUjdYdld0SWxsWlVnQkl1Q24wdzRqYXdyeTFyTGwxOFlyTGZtSWdyS2Ivb0ZiVkJGUW5nNFcrRlVoNVdhMkl0VnRaYlVCUk9pa1FRdTZESFg0NnNTWjZZRnhheTJHd0dwNFhtamd2ZUdXZEZoYlNZc3RnY1BjSTZGSmlBQUFTRTBsRVFWUlFOSUJaYVdJR2lqUDN5T0ozenVVSnJNNlZ6WFh3ZUV0dEFLd21tcjh0RDFhb3FTWU00dUtFUHdtRzBOcTRqTVdtVU9BaXVBRmRDY1FVeGhBLzJyWHBOYkdydlhlQmRYVnVITE5oTmR0RDgwZWlGVkdXbENlRVpYeUxuVHZUZ0FVcklMUlgySTNpSTlKVUFWdEVLeTNVVm5TaHBycndTejBFVmpLcnV4WFE2Y29QNFVtVkJkcGlMWExRbFlJTzJjY3JFMFZWYXdheGNONmxHRE5WSkdqVjRlaUg5RGI1c0pyZVpwbUppbkVDYVowVWx0ZldwaCt3YkNWajk0UFdzNHFJa0dpRGlmVjJQbVJ4N0l5c3JNQnlZVG12MnZaVVpYbjVMSG9lV0pnZ3JGV3R3cm16Y3Iwb3FxcFZyZkF6VnhSOWFqdUJuVTFicC9lSi9tQ3h5eDlEYis2OUZGcjVkRVZSeVpQRHNyVDRhV3JRRlpiSWtCc0VpaXRlQ3AyeUlLUVdwTjg2RkNLV3kyeFl5VzZoWWNIS2ZTQlBidkRCdDFqWi9tanJtTEFPcXA2dGsyVVJneWt3MVovNlhkTTFzYU41M2hsWVBxd21Ia05uVjAyd2RtbEZCUi9jWFo3OHg5QWlyZmhBRlZWbEhaMGFGcXlKN1k2amN3a2ZzcnpSRmR2K2tJNHJYMWwvUnVVRUZTWlJ5bXB4K3A5dzdHZ0JzY2ZReWVCMk1LMHNsMGE5c2l5dVZBZmhaUVh0YzZheUZnY21rR3dHdmJTa2U5eWRIdGJJMGxJclVybWJHVlQrWkNJTnJHV0RDS1BvKzYxKzVITE9sUVZydXFqNnNpS0pvVUZoeVdCWUFHdDZjbGhXV3l0K2tBTkhYZ0o5WGJYVXJMeWlSRzhRZDNycEpOcEtLbXdBck1RRWVsUWtaVW1VbDRGMWhoOWliN1FGdGg0T0NLRVlSYyt5V2FGVlRGSENLNHBvUzdUSzU2MXVtUjdHSEZpajc0c2txb3J0Y0dTUWxRRW01ZDNOR1dCZFhGeHFXdVNHQmhoQ0pVUlI5TU9vb0ZHTHdDcHNNNmhoL2E1VHNBWW9hM1QxcjJqTFRMYk5UVURsRTVhOVp1Tnp3THJ3MmpMaEFScStYODZ3cURmeHJOVXpNbkN1b25EOUZqaDZGODFqRnF6TEJlSGtIY3VMU3BJQk5KcXl0TXJaNWVoc3RBRFc0d1pFRlE0SHYzSXBseURJbXVpUCtGRmRXYkIrek1MV3BncDdHLzJBa1NOUkZKRlpYUE9yODhCQzM0SmJpb0FURnNpMHdISkJWSmlRSmVLa2hUb1Q5b3VpZm11b3NpNEFWdC9WVVZtTmRKeDhhTERYbVV6TDB3S2JoKzhiVGlqY3JLVlZKckNEVU5HcXlQc3RycXc4V09PYmxMSFRua0hhNUVBY1M4cjFtVXdMYVlHcXJMZWJVZXd6T3BSUWhiY3RWRmJjMkhqSHo0S0ZFYjZpNVVLdmtlRVRLTTg2aDRHV3U1bEI0YkdYbFk3b2MxSUpYbTU5RExUNDNxZk9oMVZ4dy9MYm0vUU1scklzenhOTEtTMTdXSThuTjJuOUdNY1NFVElWQmhHK09KeFZXMlNXV0JhczBYUkJXNzRxTHZ1Y2ErRVFWbzdXR2VmUStaYUFBVFRESkJJeFFkamFQU0V4NWZlSnFxRG5pUjNORDNuS3VyemJWdEdwb0krZnZwSUpVMWppbzZ6bTMwZG5wYVZzaFNBU1hWK1VUNm5BcU1VWHp1eHMzaUp4cTh0VDF1V0MxWHhFWUJWdHNJaGZsUkxtOFA1ODBnSmFRclYyWjZpSy9qWXdsQTV0NnQ5Y0E0Rng5cmZiK1hoOTVTbExad2ZhV2pXVmJMeXNuTGhvSG5YS2t0WDVMTjdSYW4yUHdEQ0ZJb3Q4TnFqTEhaYlpTV1Q5bGgvRFBHWHA3Q0NkUjVIa3dIVkZVRmxhOHN6U3NpNFAzN0xkOFlpQ0hVZi9JVDhVZU1Cdng5aW4wODZaVnBjOWhwUHBYUlh2bm9Pa1lBTDlRbGphcFJDZTVWbWxCYlIrcVZhbjBoMWZEbmxvSjVtK0pUVWdmdElCTTBZZnRZRjV5aHBkTFhwNm9uME16ZTBXRjhCYXk3dlpPYVVGKzBUalc1amdSVEpPYVk4U0NYSWljSEw3eElMM1c1bGpxQjIrQ21jNFRjVExTVXdHd3lwUldtdFpubk5CZExUZ2hpSVJPMVBVdjhNMnNXREJ3WCtOemhnQy80YkJHMG1sbWJBdWZ0eWtNcnNreXlCUFdHQlphN2t1eTd0emRRK0VsakwzcWhYK2tFdUlZN1krOXI0a1A1SUdGNzkvS3hjV21KWXZaV1E0d21INXlwS3lub1VLTzdQSE8xcHdzN3ZwaW5ITHAwWHk5NGNYQ1hpK2d4Z3dobUJhdERxV2RQdE1BbFlwMGF5a3hFRXN5L1Y2UGowL0xmTnRLdlZvSm9sMm92RStjUmNYaEl3VjNsSDVPL2hXTHF6TFdXeFU5SkNRMGlxOXNOQzVqRzFOemt0cmdyN2xUcmlDSFNsQ1NkQktYdkd6VjhHMFplOE56SVpsa2hidDJ5VVZWa3dLSjNGdG51WGFET0xzYW5UeGYvRXRrRWJSTXZPbWRiUDR3M0YxM0c5MStiRE1DWStNaFNYalVxYU0xMEtZUXprZlFHczBHbjNGNVRGZHVqckIxNlJoWlZRcHoxZE1XZjRlbTF4WWJBNWxoQXVBbGZ4aFJMV0cxNGNodEVhWDA4c2phWVc4aFNJcjR2MVB3dUVWS3lsWXZ6VkFXYVB4VGNSS1ZnZDBGZUk3c0NvMXJUS1gxdVRxZG42YzVRRXRQSWFBYjNmM3g5T0s1RytMcUEzTWhnVnpTSm8rQ3dwUlZTRXlCRnBJU3NzTFh2Tm9qYWUzdDArM3Q4ZlMrcVVLNTF2b1VqYTc3OUtwUVNTYVU4aGVlSjQ0QUpZTzhiS0orL2FvUmk1dFlDRENrbXZnWldoOUgzOVp6ZmUzVC9vNm50YWovallkclNNYmVVRktWYmVsQm5WcGJXWEQwdXZoWGNPUEo2U2tyRXB1V1dZcFJIV3RnZFo2UHB0KzdRYzRqaTQxcTVlbnA1ZVgyK01tMFNRSUUwYWhhRmJwTGd2VkpaenN6Ry82L3lEdXQrcDhXS01ySGVKbFF4SkRmL2NjUkdXVlZlSVVtcXQ4bU45ZmZTRndqYi9QYjE4MEs4UHJlRzM1eEtRT25ZbWxUMXpkRVByTFpQbDhXQmMvWmpKcTI2WFhWaG1DdTkvbnJPMkt1TVlMYlA1b2NlblZkMzc3K3ZvRTE4dnI4YlIyMkcvdEZIZWtIYXNmMUNGN3h6SUNucHJXQUZpNFAvVFppdXFxbEwwdG9adEJNQ3lBOWZDZzQrbjk5eU53alVianFaV1YxaFg4OHZRRmwyOWRoRWplRG4rd0RQU29YSzNmWHVmRDBuL1lNajRmckRnck5vbHJxaXN6aGxwYjJybG1mNGRyTkJsUGpheGVZQUx4K2ZUeWhVbUVObENJZzg2K2EvSGdKL3hGRE9IdmZSQys1akp2emZKdHdOdDQzTnc1czVMOVpaQnBTdHBsa1BQUzZqSkdyNGR4TWpvc3FxdjcrZTB6eU9uMStjbGRMMS94cmZadzVkRDdHd1NocStmN2IrTjZRMkNaNmtHeTRDNTd3ZDBxYXgxQ1ZnUkxQelV1UFkzajNqNUc3MnpHbDA1VXowL1AxdDJmM0NBZVRjdjBVaVNSMjhyNWJ5WnlKNEljYllnWUF1dGljbk1YV25ldUxSbTFEVFNVTWxSdzNSbGUwKytYNC9Ga01qTFhaRElaajYrbTl6T042dm41NWZuRlhkNnp2a2dMZDlNNzVUcFJ5S25oNkhCM2pJdTFnMkJwYWNuK3pUSlMwc0FRTWtPSVdMZ1lQb1RudzhQcmVqNmZHV1Q2bXBxWDJiM21kS3ZuNzVuQ2VxSW0vM0treTAvaWZtc254SUdCM1AwcHNLcEJzTFJycmRsSkRzdFlzcy9LMDNwQVhFUmNtdGZENjZ2T0JITzg3bTcvMTk3VjlDYU9CTkd3QkdFbUNrSklPRUtjTUhLMFFwYlErR0Qzd1ZMZmtmai9mMmU3K3JPcXVzMEFOdEZxRXE4MnlhejJzUHZ5NnZXclY5VkcxT3JQdGNHcXRsQTl4cTNlZkN0aTFTVlJubjZMY0ZnWmdqRU5uRHJ3OHFOb0JjVXFVc3dDcEVvUWZLRi9CcEQwRjhDS1ZLRVZMZjFEZlR1M3J1ZGJVWHRZUlhjeEJqTkxxVlp4T0hDbDhrMGh5eHUwZDBkMWlMQ3kzREx3Q0EwVC9LRnRNVnduODNjZzFsM2NZdmxXVmJHQ08vdVVTeCtIUHF6cC9OMnhnY3hTMU1wVHZpRjRkOWNUMGlyVVNBV3NaQ2tNVnNKOGhRSjAzMFdvUW91VkY2MzJQcFZuK1JidWY3cmVLSDVNWnVrRE1aVmdGVGh5d05UQ0NpOHRWRTZ5TkVDR1g3NEVxY0MzdmdJOXYrN1FMWlJ2N2F2ZUN1enpZb09acGFpMU9qUjhXY1lOYzV6SmdrQlpVa3RxcVdYeDBsaFo1UUkyYVZKNXlCeTFUcjRLMnhPcXhkdlJ3dmxXbUUyZmsxSnZERDNaeFJuTXJKYzVkSWltdjRGcUxJakFHK2NPS1pZc1VsakpjQktXWlcycDViRUtBbys1Ulk3RE85SDZWT3JlbDIrbHI5aGh5bDBHZy9YeThVczJoNEtPQ2FQRDBIYzd4R1ZKeEN3Tm1BaDQxZUZBYkpGc0JZK0ZFYnZIYi9GOGkzR3E2MTNqR2w2R0VJdHZpME5Uc0FtMG14SzYzRjJ5WG9jQjVjQUtTQWw3S0NhWWRXcXh3dC9ydCt5UWl3Y1FmQTBDcndnNkNJZURCYzYwY1lZaDJJVVFZN2ttT25DclJKSkZrY0p3K2FjbHR0U1RDakdydlQyeCtjVDVWbnJOcGtmcXgyQVdSRFVXTGRvUk5yZ2xiSkxkRHZaWWxGbVdYYlZ4RGduTmFpbGNqK1ZiektLZkE2dlE2azNnMkFoZ3ZTemVWU0ZhZ015aUxVbG1jUFJleEw1QjRtNG53SVVmNUxTUXVqK2s4bkcrZGI0aTltYzh1UjZGV1ZDSUJXNmc0ZnZCVFZZYkh6ZHd6WkpNdEl3akxTbXpySDhQNWdFejYxRzBYTDdWNGJ2VDFSOXMxa2pNZ2tJc0Rpd1p0VVZJbVJWcEZyV2syRHRZNnlBOFdpeDNpQXpFNC9sV3hVdXlTMXJWa1pnMVZ5ZGlPQWxsZzZZNXdWL2h4TUVwbGtNTWthb014NkVYZVNaYXFLTm1hTDNkM0NjYXYvVnA3aUNldmZQcTJGVXh2QkZSZGFPQUJhUGlMWnBRU0xjRVFqeERpUDFLS1ZPK29jZVV1azQ2eERSTzNlTlN2R05DZHRINzh0SCtGdEV3c2h6UlZTT0JOUWZaS2hCZVpQWkZBdVVTNXpPbzE2RkZhTXRRSkpsMWFvUFRhaDlBeStWYm5YLzluNEdyU3ZzSE4zc2NpMWxhdGtqZ3dFSy9va2ZjMFZtSVRzT2ErQ3gySEJJYlQ1ODdzbE9VTDhmNTF2bkNPRmFOeVN6akgyQjMyekhMalNoNDZPZlI0azEwS1lpOFk4QjBxaFh4cWswWWlNZnpyYTdxM1paM3VqVWVXREJ6RFdaVWF4YXFRNG5TR2R3VUJvVVgxR2ZoM3RBVVlVM0w4SlFvd2tINUZyMitFdTFNamxtR0dxMjhDZGtNN2dtNXlYSXBLWkg0a2pZN3RCUlJ0T3pyTU1rc2pWWjJvMjUxYUx2dmZHV1N1QitkV2VxM3Rjc0xuTXp3c1U3QmlwRDdkMUtJZGJJM0pNUksyWWZiMFlMT3B3cUp6WVYyaDFxdmlOOGFPR1JON0U5dG5WNDFYTnVqcnBDR015VS9DeU9oSjNGcEd3eEVvaEpYdCs5djBYeXJaNC9TQlBLcURLZWp2bHNPMERKV3EwbGk1YVlVL2lpVVVhdGpvYXByRmp4UVQ0cnowcmdTODNzMmtuQysxWEduRmU3NWpBMldRY3RjYVlLL0dobDVVcTlXVnhUTHdjVmtpNHd0eUZnczV0WnRsOCt5Sy9sV2REUldZNE9sMGRLR2xKNkVFdHQzcEZnc280bThROEpuT1dhUnlYUWJOejQzL1cveGZPdmFOalA0ck1uTHFNOThzdHRhd1VvNVVqb0NJNzFPRDdGU0h2N1B6RnJkdUNRWDUxdm4zcmNES3JER3ZrZXpBTFNra1huY1FJYytHaXY4TldheDdyREZWb3ZNcGFNdWNYbjd6VE9TYi9rYkt1SGxCZWo5TEYyMUdmM1MwZnpqMTFZU1ZrV3REbWRXMUJjR1dtSE5RdmxmMjlzZEFsYTdPMjdweGZ0YkZkZXR5akZyZkxCQXQzSnJTTU5lSk5Pc01OeWgxS0o0bVdGK0d6c3RObWx0cVY3dDd0cUNEdmtXOWFNOG43K01hZUFqbFpjUzJYZ2k4YktrWGJSSGlsbDR3Ukt0T0hsSWxPRHkzaHQ2MmRUZlQ2enN4L0xBenhjU0N5cjIvUjViM3gxYWI3a3hXcVYxRVFWTHNpUTE3d252UUp2RDFJRVlwaGEySUZ1emFucDNyU2kwck4rQ3p6R2k0MFIvR1ZaaHQzN1NQY21QOXh4RXZwVFI4Z3hheTVMSm1XSGlMQXpNWWtFTnBwVlpFMWxOSDdqTGFLYXY1aDc1SitTbWxWdVV0RG1YTnZsUHFVSTdlbDJaN3JERUsxbmNPa2htU3Z0OFZpSlpwaTdMYlprK2VBSGJ2UFVIQUR0M3grNm90QnpzUk5pRzF4SDA1bWtYY09lTGlUa1VyYllYa2t3cUpHMTE2bFJ2R0tqVitqS2tJay9qNVJiazZ0RnJXNkR5blh0M01MMi9hZDRmY3B3OTlXVW5IMis1a0VWQkFtVzI3OGZOUThsTlZwL0FlM2x2VVVpYXZ6Lyt1OWQrcXpPdnNLRXB2TjNqbXEyZmVyTjduazFYVzFXR0RxMlNSTXBzTjZ1a0R0NXpxN2NNd3c2ZytiYk1kNFBlZ2FEekxmUHBNdTRkYmRVK3ZQUG9NbnZ5R3hiQXplY05HWUtWdmROVjZ1QjlDWXEwd0xQRk5oMDBaSU0vRWZDb0RkZGxiMS9DNWQ2VnBQN0IrWG5xamdlS0sxQXV2Vm5MaDJEU3JkNWE4eEF4NjlydzhHUkZ5OUpxdVJ1dUtJdnA1dmlwaHoxZGR6enF0LzhZQVZOMmRQYWF2VHovV1V6ZVZ0dXlBUmZoRm1lU0FVM1p3NnhveEJOeW1sTnRMcW0wSWw4TnBaWDliOTNNOXIvdHJPZTgxNStHQ0hWWnpkYlRyOERLd0pXTDBvdFdnZFJkOWdhbHhHaUpWQUo0RWdZcEVQYTN5Vmp6dk5mWldjdFdlUGEvai8rOFp2T1hMM29XSVBTbHVUVFhvMW9SczVLVFE4b3REVlhkS21FZjhkZWVUZGY2cnJDV0x2MzFjN2I1S2xxWlg5ajg0MzIxRFBmQVBLZDZOYXRHVHFzdkFUeWRoRkRXYXB3S3hFZjRadmJ2MGI1SmR6YmJyTCtRVmtpNmNqcTV2K2F6Qks1QU1ySUlraVhxOGFFeWNFMWUxeHY5ckYrbmt5K0h5cHcxQ2k0VS9QSFdzRXhyVmp6RGQzQ0paZjRFcUV3bExMSnNrbVdKVzMxZlZveUdYVEpLMzBXc1dYVXFLaVhNV2o0TnF2L0xBOW9WdEY1N0w1czNoSEVZbVJ0cXVQUWxIcnZ3b0trbGFsVi9TdGIvWnFqTXlhaXZwdGFsYktSYkNIR3BneUR4bjJoeENScmtORkxDa0dyeHQwTmxxdkZqcXZHU09wWng4UXhDeTIrVittdGlVSTNLcWdPQ0xTQTF5YjREVWdTdnJiWVNOYnBzV0NZeWVDQ1U4bE9hVzhDcHQrazNRc3JocFc5QUEyQ1dYTFdndVhKdEw3SUtXNE1BMUU1eGF2SGRvUEtHUmhGc3BSQURXa2tNViswV1ErRDhnNXZBNmw5N24zNVhvSkNqbWI3clMvWTVZTVlhUkdDVHZwWS96YjQ1VUtRbWdXUTdoUmw1ZGo4d1hhUFpRci9QUWVHVExmUUxIbjVBK1hsK25wL241M25DOHgvdEFNbGpXa2VCbkFBQUFBQkpSVTVFcmtKZ2dnPT1gO1xuXG5jb25zdCByZXNvbHZlV2FsbGV0VXJsID0gKG5ldHdvcmssIHdhbGxldFVybCkgPT4ge1xuICBpZiAod2FsbGV0VXJsKSB7XG4gICAgcmV0dXJuIHdhbGxldFVybDtcbiAgfVxuICBzd2l0Y2ggKG5ldHdvcmsubmV0d29ya0lkKSB7XG4gICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgIHJldHVybiBcImh0dHBzOi8vYXBwLm15bmVhcndhbGxldC5jb21cIjtcbiAgICBjYXNlIFwidGVzdG5ldFwiOlxuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly90ZXN0bmV0Lm15bmVhcndhbGxldC5jb21cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3YWxsZXQgdXJsXCIpO1xuICB9XG59O1xuY29uc3Qgc2V0dXBXYWxsZXRTdGF0ZSA9IChwYXJhbXMsIG5ldHdvcmspID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBrZXlTdG9yZSA9IG5ldyBuZWFyQVBJLmtleVN0b3Jlcy5Ccm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmUoKTtcbiAgY29uc3QgbmVhciA9IHlpZWxkIG5lYXJBUEkuY29ubmVjdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgIGtleVN0b3JlLFxuICAgIHdhbGxldFVybDogcGFyYW1zLndhbGxldFVybFxuICB9LCBuZXR3b3JrKSwge1xuICAgIGhlYWRlcnM6IHt9XG4gIH0pKTtcbiAgY29uc3Qgd2FsbGV0ID0gbmV3IG5lYXJBUEkuV2FsbGV0Q29ubmVjdGlvbihuZWFyLCBcIm5lYXJfYXBwXCIpO1xuICByZXR1cm4ge1xuICAgIHdhbGxldCxcbiAgICBrZXlTdG9yZVxuICB9O1xufSk7XG5jb25zdCBNeU5lYXJXYWxsZXQgPSAoe1xuICBtZXRhZGF0YSxcbiAgb3B0aW9ucyxcbiAgc3RvcmUsXG4gIHBhcmFtcyxcbiAgbG9nZ2VyLFxuICBpZFxufSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IF9zdGF0ZSA9IHlpZWxkIHNldHVwV2FsbGV0U3RhdGUocGFyYW1zLCBvcHRpb25zLm5ldHdvcmspO1xuICBjb25zdCBnZXRBY2NvdW50cyA9ICgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFjY291bnRJZCA9IF9zdGF0ZS53YWxsZXQuZ2V0QWNjb3VudElkKCk7XG4gICAgY29uc3QgYWNjb3VudCA9IF9zdGF0ZS53YWxsZXQuYWNjb3VudCgpO1xuICAgIGlmICghYWNjb3VudElkIHx8ICFhY2NvdW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIGFjY291bnQuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KGFjY291bnQuYWNjb3VudElkLCBvcHRpb25zLm5ldHdvcmsubmV0d29ya0lkKTtcbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRJZCxcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5ID8gcHVibGljS2V5LnRvU3RyaW5nKCkgOiBcIlwiXG4gICAgfV07XG4gIH0pO1xuICBjb25zdCB0cmFuc2Zvcm1UcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWNjb3VudCA9IF9zdGF0ZS53YWxsZXQuYWNjb3VudCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ldHdvcmtJZCxcbiAgICAgIHNpZ25lcixcbiAgICAgIHByb3ZpZGVyXG4gICAgfSA9IGFjY291bnQuY29ubmVjdGlvbjtcbiAgICBjb25zdCBsb2NhbEtleSA9IHlpZWxkIHNpZ25lci5nZXRQdWJsaWNLZXkoYWNjb3VudC5hY2NvdW50SWQsIG5ldHdvcmtJZCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhY3Rpb25zID0gdHJhbnNhY3Rpb24uYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKTtcbiAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IHlpZWxkIGFjY291bnQuYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCwgYWN0aW9ucywgbG9jYWxLZXkpO1xuICAgICAgaWYgKCFhY2Nlc3NLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBtYXRjaGluZyBrZXkgZm9yIHRyYW5zYWN0aW9uIHNlbnQgdG8gJHt0cmFuc2FjdGlvbi5yZWNlaXZlcklkfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCBwcm92aWRlci5ibG9jayh7XG4gICAgICAgIGZpbmFsaXR5OiBcImZpbmFsXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5lYXJBUEkudHJhbnNhY3Rpb25zLmNyZWF0ZVRyYW5zYWN0aW9uKGFjY291bnQuYWNjb3VudElkLCBuZWFyQVBJLnV0aWxzLlB1YmxpY0tleS5mcm9tKGFjY2Vzc0tleS5wdWJsaWNfa2V5KSwgdHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCwgYWNjZXNzS2V5LmFjY2Vzc19rZXkubm9uY2UgKyBpbmRleCArIDEsIGFjdGlvbnMsIG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZGVjb2RlKGJsb2NrLmhlYWRlci5oYXNoKSk7XG4gICAgfSkpKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2lnbkluKHtcbiAgICAgIGNvbnRyYWN0SWQsXG4gICAgICBtZXRob2ROYW1lcyxcbiAgICAgIHN1Y2Nlc3NVcmwsXG4gICAgICBmYWlsdXJlVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBY2NvdW50cyA9IHlpZWxkIGdldEFjY291bnRzKCk7XG4gICAgICAgIGlmIChleGlzdGluZ0FjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0FjY291bnRzO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdGF0ZS53YWxsZXQucmVxdWVzdFNpZ25Jbih7XG4gICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lcyxcbiAgICAgICAgICBzdWNjZXNzVXJsLFxuICAgICAgICAgIGZhaWx1cmVVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduT3V0KCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKF9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpKSB7XG4gICAgICAgICAgX3N0YXRlLndhbGxldC5zaWduT3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0QWNjb3VudHMoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudHMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdmVyaWZ5T3duZXIoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBub3Qgc3VwcG9ydGVkIGJ5ICR7bWV0YWRhdGEubmFtZX1gKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5vbmNlLFxuICAgICAgcmVjaXBpZW50LFxuICAgICAgY2FsbGJhY2tVcmwsXG4gICAgICBzdGF0ZVxuICAgIH0pIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJzaWduIG1lc3NhZ2VcIiwge1xuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZCAhPT0gXCJteS1uZWFyLXdhbGxldFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBzaWduTWVzc2FnZSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSAke21ldGFkYXRhLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb25VcmwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBjYWxsYmFja1VybCB8fCBsb2NhdGlvblVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWxsYmFja1VybCBpcyBtaXNzaW5nIGZvciAke21ldGFkYXRhLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaHJlZiA9IG5ldyBVUkwocGFyYW1zLndhbGxldFVybCk7XG4gICAgICAgIGhyZWYucGF0aG5hbWUgPSBcInNpZ24tbWVzc2FnZVwiO1xuICAgICAgICBocmVmLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgICAgICBocmVmLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub25jZVwiLCBub25jZS50b1N0cmluZygpKTtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicmVjaXBpZW50XCIsIHJlY2lwaWVudCk7XG4gICAgICAgIGhyZWYuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNhbGxiYWNrVXJsXCIsIHVybCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGhyZWYuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgc2lnbmVySWQsXG4gICAgICByZWNlaXZlcklkLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGNhbGxiYWNrVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICAgIHNpZ25lcklkLFxuICAgICAgICAgIHJlY2VpdmVySWQsXG4gICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyYWN0XG4gICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIV9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpIHx8ICFjb250cmFjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3Qgc2lnbmVkIGluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfc3RhdGUud2FsbGV0LmFjY291bnQoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRbXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCJdKHtcbiAgICAgICAgICByZWNlaXZlcklkOiByZWNlaXZlcklkIHx8IGNvbnRyYWN0LmNvbnRyYWN0SWQsXG4gICAgICAgICAgYWN0aW9uczogYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKSxcbiAgICAgICAgICB3YWxsZXRDYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKHtcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgIGNhbGxiYWNrVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgY2FsbGJhY2tVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghX3N0YXRlLndhbGxldC5pc1NpZ25lZEluKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IHNpZ25lZCBpblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N0YXRlLndhbGxldC5yZXF1ZXN0U2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb25zOiB5aWVsZCB0cmFuc2Zvcm1UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSxcbiAgICAgICAgICBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYnVpbGRJbXBvcnRBY2NvdW50c1VybCgpIHtcbiAgICAgIHJldHVybiBgJHtwYXJhbXMud2FsbGV0VXJsfS9iYXRjaC1pbXBvcnRgO1xuICAgIH1cbiAgfTtcbn0pO1xuZnVuY3Rpb24gc2V0dXBNeU5lYXJXYWxsZXQoe1xuICB3YWxsZXRVcmwsXG4gIGljb25VcmwgPSBpY29uLFxuICBkZXByZWNhdGVkID0gZmFsc2UsXG4gIHN1Y2Nlc3NVcmwgPSBcIlwiLFxuICBmYWlsdXJlVXJsID0gXCJcIlxufSA9IHt9KSB7XG4gIHJldHVybiBtb2R1bGVPcHRpb25zID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwibXktbmVhci13YWxsZXRcIixcbiAgICAgIHR5cGU6IFwiYnJvd3NlclwiLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogXCJNeU5lYXJXYWxsZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTkVBUiB3YWxsZXQgdG8gc3RvcmUsIGJ1eSwgc2VuZCBhbmQgc3Rha2UgYXNzZXRzIGZvciBEZUZpLlwiLFxuICAgICAgICBpY29uVXJsLFxuICAgICAgICBkZXByZWNhdGVkLFxuICAgICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgICAgIHN1Y2Nlc3NVcmwsXG4gICAgICAgIGZhaWx1cmVVcmwsXG4gICAgICAgIHdhbGxldFVybDogcmVzb2x2ZVdhbGxldFVybChtb2R1bGVPcHRpb25zLm9wdGlvbnMubmV0d29yaywgd2FsbGV0VXJsKVxuICAgICAgfSxcbiAgICAgIGluaXQ6IG9wdGlvbnMgPT4ge1xuICAgICAgICByZXR1cm4gTXlOZWFyV2FsbGV0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHdhbGxldFVybDogcmVzb2x2ZVdhbGxldFVybChvcHRpb25zLm9wdGlvbnMubmV0d29yaywgd2FsbGV0VXJsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzZXR1cE15TmVhcldhbGxldCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/wallet-utils/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   signTransactions: () => (/* binding */ signTransactions)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n\n\n\nconst {\n  transactions,\n  utils\n} = /*#__PURE__*/ (near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(near_api_js__WEBPACK_IMPORTED_MODULE_1__, 2)));\nconst getAccessKey = permission => {\n  if (permission === \"FullAccess\") {\n    return transactions.fullAccessKey();\n  }\n  const {\n    receiverId,\n    methodNames = []\n  } = permission;\n  const allowance = permission.allowance ? new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(permission.allowance) : undefined;\n  return transactions.functionCallAccessKey(receiverId, methodNames, allowance);\n};\nconst createAction = action => {\n  switch (action.type) {\n    case \"CreateAccount\":\n      return transactions.createAccount();\n    case \"DeployContract\":\n      {\n        const {\n          code\n        } = action.params;\n        return transactions.deployContract(code);\n      }\n    case \"FunctionCall\":\n      {\n        const {\n          methodName,\n          args,\n          gas,\n          deposit\n        } = action.params;\n        return transactions.functionCall(methodName, args, new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(gas), new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(deposit));\n      }\n    case \"Transfer\":\n      {\n        const {\n          deposit\n        } = action.params;\n        return transactions.transfer(new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(deposit));\n      }\n    case \"Stake\":\n      {\n        const {\n          stake,\n          publicKey\n        } = action.params;\n        return transactions.stake(new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(stake), utils.PublicKey.from(publicKey));\n      }\n    case \"AddKey\":\n      {\n        const {\n          publicKey,\n          accessKey\n        } = action.params;\n        return transactions.addKey(utils.PublicKey.from(publicKey),\n        // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?\n        getAccessKey(accessKey.permission));\n      }\n    case \"DeleteKey\":\n      {\n        const {\n          publicKey\n        } = action.params;\n        return transactions.deleteKey(utils.PublicKey.from(publicKey));\n      }\n    case \"DeleteAccount\":\n      {\n        const {\n          beneficiaryId\n        } = action.params;\n        return transactions.deleteAccount(beneficiaryId);\n      }\n    default:\n      throw new Error(\"Invalid action type\");\n  }\n};\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar fails$d = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$c = fails$d;\n\nvar functionBindNative = !fails$c(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$e = FunctionPrototype$2.call;\nvar uncurryThis$d = NATIVE_BIND$3 && bind$5.bind(call$e, call$e);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? function (fn) {\n  return fn && uncurryThis$d(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$e.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar toString$2 = uncurryThis$c({}.toString);\nvar stringSlice = uncurryThis$c(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice(toString$2(it), 8, -1);\n};\n\nvar uncurryThis$b = functionUncurryThis;\nvar fails$b = fails$d;\nvar classof$5 = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$b(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$b(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$5(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$b = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function (it) {\n  if (it == undefined) throw $TypeError$b(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\n\nvar toIndexedObject$5 = function (it) {\n  return IndexedObject(requireObjectCoercible$1(it));\n};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$j =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar shared$3 = {exports: {}};\n\nvar global$i = global$j;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$4(global$i, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$i[key] = value;\n  } return value;\n};\n\nvar global$h = global$j;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$h[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$3.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible = requireObjectCoercible$2;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function (argument) {\n  return $Object$3(requireObjectCoercible(argument));\n};\n\nvar uncurryThis$a = functionUncurryThis;\nvar toObject$1 = toObject$2;\n\nvar hasOwnProperty = uncurryThis$a({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$1(it), key);\n};\n\nvar uncurryThis$9 = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$9(1.0.toString);\n\nvar uid$2 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$k = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar global$g = global$j;\nvar isCallable$j = isCallable$k;\n\nvar aFunction = function (argument) {\n  return isCallable$j(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$g[namespace]) : global$g[namespace] && global$g[namespace][method];\n};\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$f = global$j;\nvar userAgent$3 = engineUserAgent;\n\nvar process$3 = global$f.process;\nvar Deno$1 = global$f.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$a = fails$d;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$a(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar global$e = global$j;\nvar shared$2 = shared$3.exports;\nvar hasOwn$a = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$2('wks');\nvar Symbol$1 = global$e.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\n\nvar wellKnownSymbol$e = function (name) {\n  if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar isCallable$i = isCallable$k;\n\nvar isObject$7 = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$i(it);\n};\n\nvar isObject$6 = isObject$7;\n\nvar $String$3 = String;\nvar $TypeError$a = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$c = function (argument) {\n  if (isObject$6(argument)) return argument;\n  throw $TypeError$a($String$3(argument) + ' is not an object');\n};\n\nvar objectDefineProperties = {};\n\nvar fails$9 = fails$d;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar DESCRIPTORS$9 = descriptors;\nvar fails$8 = fails$d;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$9 && fails$8(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar objectDefineProperty = {};\n\nvar global$d = global$j;\nvar isObject$5 = isObject$7;\n\nvar document$3 = global$d.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$8 = descriptors;\nvar fails$7 = fails$d;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$8 && !fails$7(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$d = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function () {\n  return call$d.apply(call$d, arguments);\n};\n\nvar uncurryThis$8 = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$h = isCallable$k;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar $Object$2 = Object;\n\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$h($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$2(it));\n};\n\nvar $String$2 = String;\n\nvar tryToString$4 = function (argument) {\n  try {\n    return $String$2(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$g = isCallable$k;\nvar tryToString$3 = tryToString$4;\n\nvar $TypeError$9 = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$g(argument)) return argument;\n  throw $TypeError$9(tryToString$3(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$6(func);\n};\n\nvar call$c = functionCall;\nvar isCallable$f = isCallable$k;\nvar isObject$4 = isObject$7;\n\nvar $TypeError$8 = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n  if (isCallable$f(fn = input.valueOf) && !isObject$4(val = call$c(fn, input))) return val;\n  if (pref !== 'string' && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n  throw $TypeError$8(\"Can't convert object to primitive value\");\n};\n\nvar call$b = functionCall;\nvar isObject$3 = isObject$7;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$d = wellKnownSymbol$e;\n\nvar $TypeError$7 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$d('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function (input, pref) {\n  if (!isObject$3(input) || isSymbol$1(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$b(exoticToPrim, input, pref);\n    if (!isObject$3(result) || isSymbol$1(result)) return result;\n    throw $TypeError$7(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\nvar DESCRIPTORS$7 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$1 = toPropertyKey$2;\n\nvar $TypeError$6 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$7 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$1(P);\n  anObject$b(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$b(O);\n  P = toPropertyKey$1(P);\n  anObject$b(Attributes);\n  if (IE8_DOM_DEFINE$1) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$6('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\n\nvar max = Math.max;\nvar min$1 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function (index, length) {\n  var integer = toIntegerOrInfinity$1(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$2 = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$2;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$1(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\nvar hiddenKeys$4 = {};\n\nvar uncurryThis$7 = functionUncurryThis;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar push = uncurryThis$7([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$9(hiddenKeys$3, key) && hasOwn$9(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$9(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar DESCRIPTORS$6 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$4 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys = objectKeys$1;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$6 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$a(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$4.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$5 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$5('document', 'documentElement');\n\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\n\nvar keys = shared$1('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html$1.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$2[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$9(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$c = wellKnownSymbol$e;\nvar create$1 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$c('unscopables');\nvar ArrayPrototype$1 = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n    configurable: true,\n    value: create$1(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function (key) {\n  ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\n\nvar iterators = {};\n\nvar uncurryThis$6 = functionUncurryThis;\nvar isCallable$e = isCallable$k;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$6(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$e(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$c = global$j;\nvar isCallable$d = isCallable$k;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$c.WeakMap;\n\nvar nativeWeakMap = isCallable$d(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar createPropertyDescriptor$3 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$3;\n\nvar createNonEnumerableProperty$4 = DESCRIPTORS$5 ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor$2(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$b = global$j;\nvar uncurryThis$5 = functionUncurryThis;\nvar isObject$2 = isObject$7;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$b.TypeError;\nvar WeakMap = global$b.WeakMap;\nvar set$1, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set$1(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$2(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis$5(store.get);\n  var wmhas = uncurryThis$5(store.has);\n  var wmset = uncurryThis$5(store.set);\n  set$1 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$1('state');\n  hiddenKeys$1[STATE] = true;\n  set$1 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$3(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$1,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar DESCRIPTORS$4 = descriptors;\nvar call$a = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$3;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey = toPropertyKey$2;\nvar hasOwn$7 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$4 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$1(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$7(O, P)) return createPropertyDescriptor$1(!call$a(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$3 = descriptors;\nvar hasOwn$6 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$6(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || (DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar fails$6 = fails$d;\nvar isCallable$c = isCallable$k;\nvar hasOwn$5 = hasOwnProperty_1;\nvar DESCRIPTORS$2 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$2 && !fails$6(function () {\n  return defineProperty$2(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$5(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {\n    if (DESCRIPTORS$2) defineProperty$2(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, 'arity') && value.length !== options.arity) {\n    defineProperty$2(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$5(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$2) defineProperty$2(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn$5(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$c(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$b = isCallable$k;\nvar definePropertyModule$2 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$6 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$b(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$2.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$4 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\n\nvar concat = uncurryThis$4([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$4 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$1.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$5 = fails$d;\nvar isCallable$a = isCallable$k;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$a(detection) ? fails$5(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$a = global$j;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$a;\n  } else if (STATIC) {\n    target = global$a[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$a[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$2(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$5(target, key, sourceProperty, options);\n  }\n};\n\nvar fails$4 = fails$d;\n\nvar correctPrototypeGetter = !fails$4(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$3 = hasOwnProperty_1;\nvar isCallable$9 = isCallable$k;\nvar toObject = toObject$2;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$9(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype : null;\n};\n\nvar fails$3 = fails$d;\nvar isCallable$8 = isCallable$k;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$e;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$3(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$8(IteratorPrototype$2[ITERATOR$5])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar defineProperty$1 = objectDefineProperty.f;\nvar hasOwn$2 = hasOwnProperty_1;\nvar wellKnownSymbol$a = wellKnownSymbol$e;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$a('toStringTag');\n\nvar setToStringTag$3 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {\n    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });\n  }\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$3;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$4[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar isCallable$7 = isCallable$k;\n\nvar $String$1 = String;\nvar $TypeError$5 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$7(argument)) return argument;\n  throw $TypeError$5(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$3 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$3(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$7(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$6 = _export;\nvar call$9 = functionCall;\nvar FunctionName = functionName;\nvar isCallable$6 = isCallable$k;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$9 = wellKnownSymbol$e;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$9('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$4]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$1) {\n          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$6(CurrentIteratorPrototype[ITERATOR$4])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$9(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$3[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$1 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$1 && values.name !== 'values') try {\n  defineProperty(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$9 = global$j;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$e;\n\nvar ITERATOR$3 = wellKnownSymbol$8('iterator');\nvar TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR$3] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$2]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$9[COLLECTION_NAME] && global$9[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nvar classof$4 = classofRaw$1;\nvar global$8 = global$j;\n\nvar engineIsNode = classof$4(global$8.process) == 'process';\n\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$7 = wellKnownSymbol$e;\nvar DESCRIPTORS = descriptors;\n\nvar SPECIES$2 = wellKnownSymbol$7('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n    defineProperty(Constructor, SPECIES$2, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\n\nvar $TypeError$4 = TypeError;\n\nvar anInstance$1 = function (it, Prototype) {\n  if (isPrototypeOf$2(Prototype, it)) return it;\n  throw $TypeError$4('Incorrect invocation');\n};\n\nvar wellKnownSymbol$6 = wellKnownSymbol$e;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$6('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$1] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$5 = isCallable$k;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$5 = wellKnownSymbol$e;\n\nvar TO_STRING_TAG = wellKnownSymbol$5('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$3 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$5(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$d;\nvar isCallable$4 = isCallable$k;\nvar classof$2 = classof$3;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$2('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$2(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$4;\n\nvar $TypeError$3 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw $TypeError$3(tryToString$2(argument) + ' is not a constructor');\n};\n\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$e;\n\nvar SPECIES$1 = wellKnownSymbol$4('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function (O, defaultConstructor) {\n  var C = anObject$6(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function () {\n  return call$8.apply(apply$1, arguments);\n});\n\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar uncurryThis = functionUncurryThis;\n\nvar arraySlice$1 = uncurryThis([].slice);\n\nvar $TypeError$2 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$2('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\n\nvar global$7 = global$j;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$k;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$d;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\n\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$7.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$1(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$7.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$3(handler) ? handler : Function$1(handler);\n    var args = arraySlice(arguments, 1);\n    queue$1[++counter] = function () {\n      apply(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$2) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$3(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$7.addEventListener &&\n    isCallable$3(global$7.postMessage) &&\n    !global$7.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$1(post)\n  ) {\n    defer = post;\n    global$7.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set,\n  clear: clear\n};\n\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$j;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\n\nvar userAgent = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\n\nvar global$5 = global$j;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\n\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$2(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$1) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$2(macrotask, global$5);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$4 = global$j;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$4.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$3 = global$j;\n\nvar promiseNativeConstructor = global$3.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$2 = global$j;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$k;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$e;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$4 = aCallable$7;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$4(resolve);\n  this.reject = aCallable$4(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$j;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$1 = isCallable$k;\nvar isObject$1 = isObject$7;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$1('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$7(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$1.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$7(task, global$1, function () {\n    var promise = state.facade;\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$1 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$7(then, value,\n            bind$1(internalResolve, wrapper, state),\n            bind$1(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance(this, PromisePrototype);\n    aCallable$3(executor);\n    call$7(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$1(onRejected) && onRejected;\n    reaction.domain = IS_NODE ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$1(internalResolve, state);\n    this.reject = bind$1(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$2(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$7(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf) {\n      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$5({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\n\nvar wellKnownSymbol$2 = wellKnownSymbol$e;\nvar Iterators$1 = iterators;\n\nvar ITERATOR$2 = wellKnownSymbol$2('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function (it) {\n  return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\n\nvar classof$1 = classof$3;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$e;\n\nvar ITERATOR$1 = wellKnownSymbol$1('iterator');\n\nvar getIteratorMethod$2 = function (it) {\n  if (it != undefined) return getMethod$1(it, ITERATOR$1)\n    || getMethod$1(it, '@@iterator')\n    || Iterators[classof$1(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar $TypeError$1 = TypeError;\n\nvar getIterator$1 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n  throw $TypeError$1(tryToString$1(argument) + ' is not iterable');\n};\n\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$4(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$5(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$4(innerResult);\n  return value;\n};\n\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$2;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$4(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol = wellKnownSymbol$e;\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$1(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$3($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$k;\nvar defineBuiltIn$1 = defineBuiltIn$6;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$1(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable(C.resolve);\n      iterate(iterable, function (promise) {\n        call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$1(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$2 = anObject$c;\nvar isObject = isObject$7;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$2(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nvar classof = classof$3;\n\nvar $String = String;\n\nvar toString = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar anObject$1 = anObject$c;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function () {\n  var that = anObject$1(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\n\nvar RegExpPrototype$1 = RegExp.prototype;\n\nvar regexpGetFlags = function (R) {\n  var flags = R.flags;\n  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)\n    ? call(regExpFlags, R) : flags;\n};\n\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString;\nvar fails = fails$d;\nvar getRegExpFlags = regexpGetFlags;\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var pattern = $toString(R.source);\n    var flags = $toString(getRegExpFlags(R));\n    return '/' + pattern + '/' + flags;\n  }, { unsafe: true });\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst signTransactions = (transactions, signer, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_1__.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const signedTransactions = [];\n  for (let i = 0; i < transactions.length; i++) {\n    const publicKey = yield signer.getPublicKey(transactions[i].signerId, network.networkId);\n    const [block, accessKey] = yield Promise.all([provider.block({\n      finality: \"final\"\n    }), provider.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: transactions[i].signerId,\n      public_key: publicKey.toString()\n    })]);\n    const actions = transactions[i].actions.map(action => createAction(action));\n    const transaction = near_api_js__WEBPACK_IMPORTED_MODULE_1__.transactions.createTransaction(transactions[i].signerId, near_api_js__WEBPACK_IMPORTED_MODULE_1__.utils.PublicKey.from(publicKey.toString()), transactions[i].receiverId, accessKey.nonce + i + 1, actions, near_api_js__WEBPACK_IMPORTED_MODULE_1__.utils.serialize.base_decode(block.header.hash));\n    const response = yield near_api_js__WEBPACK_IMPORTED_MODULE_1__.transactions.signTransaction(transaction, signer, transactions[i].signerId, network.networkId);\n    signedTransactions.push(response[1]);\n  }\n  return signedTransactions;\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL3dhbGxldC11dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyQjtBQUNZOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsMk1BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQ0FBK0MscUNBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtEQUErRCxxQ0FBRSxXQUFXLHFDQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUNBQXlDLHFDQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQ0FBc0MscUNBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQixnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTyxJQUFJLGNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLG1GQUFtRjtBQUN6RjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLHFEQUFvQiw2Q0FBNkMsOENBQWEscUdBQXFHLDhDQUFhO0FBQ3hOLDJCQUEyQixxREFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRiYXNlbWludC8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3Ivd2FsbGV0LXV0aWxzL2luZGV4LmpzP2Y0NGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQk4gfSBmcm9tICdibi5qcyc7XG5pbXBvcnQgKiBhcyBuZWFyQVBJIGZyb20gJ25lYXItYXBpLWpzJztcblxuY29uc3Qge1xuICB0cmFuc2FjdGlvbnMsXG4gIHV0aWxzXG59ID0gbmVhckFQSTtcbmNvbnN0IGdldEFjY2Vzc0tleSA9IHBlcm1pc3Npb24gPT4ge1xuICBpZiAocGVybWlzc2lvbiA9PT0gXCJGdWxsQWNjZXNzXCIpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmZ1bGxBY2Nlc3NLZXkoKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcmVjZWl2ZXJJZCxcbiAgICBtZXRob2ROYW1lcyA9IFtdXG4gIH0gPSBwZXJtaXNzaW9uO1xuICBjb25zdCBhbGxvd2FuY2UgPSBwZXJtaXNzaW9uLmFsbG93YW5jZSA/IG5ldyBCTihwZXJtaXNzaW9uLmFsbG93YW5jZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB0cmFuc2FjdGlvbnMuZnVuY3Rpb25DYWxsQWNjZXNzS2V5KHJlY2VpdmVySWQsIG1ldGhvZE5hbWVzLCBhbGxvd2FuY2UpO1xufTtcbmNvbnN0IGNyZWF0ZUFjdGlvbiA9IGFjdGlvbiA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiQ3JlYXRlQWNjb3VudFwiOlxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5jcmVhdGVBY2NvdW50KCk7XG4gICAgY2FzZSBcIkRlcGxveUNvbnRyYWN0XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb2RlXG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmRlcGxveUNvbnRyYWN0KGNvZGUpO1xuICAgICAgfVxuICAgIGNhc2UgXCJGdW5jdGlvbkNhbGxcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBnYXMsXG4gICAgICAgICAgZGVwb3NpdFxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5mdW5jdGlvbkNhbGwobWV0aG9kTmFtZSwgYXJncywgbmV3IEJOKGdhcyksIG5ldyBCTihkZXBvc2l0KSk7XG4gICAgICB9XG4gICAgY2FzZSBcIlRyYW5zZmVyXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZXBvc2l0XG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLnRyYW5zZmVyKG5ldyBCTihkZXBvc2l0KSk7XG4gICAgICB9XG4gICAgY2FzZSBcIlN0YWtlXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzdGFrZSxcbiAgICAgICAgICBwdWJsaWNLZXlcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuc3Rha2UobmV3IEJOKHN0YWtlKSwgdXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSk7XG4gICAgICB9XG4gICAgY2FzZSBcIkFkZEtleVwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgIGFjY2Vzc0tleVxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5hZGRLZXkodXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSxcbiAgICAgICAgLy8gVE9ETzogVXNlIGFjY2Vzc0tleS5ub25jZT8gbmVhci1hcGktanMgc2VlbXMgdG8gdGhpbmsgMCBpcyBmaW5lP1xuICAgICAgICBnZXRBY2Nlc3NLZXkoYWNjZXNzS2V5LnBlcm1pc3Npb24pKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRGVsZXRlS2V5XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwdWJsaWNLZXlcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuZGVsZXRlS2V5KHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJEZWxldGVBY2NvdW50XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBiZW5lZmljaWFyeUlkXG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmRlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWN0aW9uIHR5cGVcIik7XG4gIH1cbn07XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgZmFpbHMkZCA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkYyA9IGZhaWxzJGQ7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCQ1ID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkZSA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRkID0gTkFUSVZFX0JJTkQkMyAmJiBiaW5kJDUuYmluZChjYWxsJGUsIGNhbGwkZSk7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkZChmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkZS5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDIgPSB1bmN1cnJ5VGhpcyRjKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzJGMoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyQyKGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGIgPSBmYWlscyRkO1xudmFyIGNsYXNzb2YkNSA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJGIoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDQoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJDUoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkNChpdCk7XG59IDogJE9iamVjdCQ0O1xuXG52YXIgJFR5cGVFcnJvciRiID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciRiKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKGl0KSk7XG59O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJGogPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIHNoYXJlZCQzID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCRpID0gZ2xvYmFsJGo7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JDQoZ2xvYmFsJGksIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJGlba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkaCA9IGdsb2JhbCRqO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDIgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUkMyA9IGdsb2JhbCRoW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkkMihTSEFSRUQsIHt9KTtcblxudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcblxuKHNoYXJlZCQzLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjIzLjMnLFxuICBtb2RlOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjMuMy9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDI7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkMjtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkYSh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkMShpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckMSA9IHVuY3VycnlUaGlzJDkoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDEoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkayA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkajtcbnZhciBpc0NhbGxhYmxlJGogPSBpc0NhbGxhYmxlJGs7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaihhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRnW25hbWVzcGFjZV0pIDogZ2xvYmFsJGdbbmFtZXNwYWNlXSAmJiBnbG9iYWwkZ1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ3KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCRqO1xudmFyIHVzZXJBZ2VudCQzID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyQzID0gZ2xvYmFsJGYucHJvY2VzcztcbnZhciBEZW5vJDEgPSBnbG9iYWwkZi5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucyB8fCBEZW5vJDEgJiYgRGVubyQxLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQzKSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRhID0gZmFpbHMkZDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQxICYmIFY4X1ZFUlNJT04kMSA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdsb2JhbCRlID0gZ2xvYmFsJGo7XG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDIoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJGUuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQxO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRhKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24kYShTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQkMSAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgaXNDYWxsYWJsZSRpID0gaXNDYWxsYWJsZSRrO1xuXG52YXIgaXNPYmplY3QkNyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGkoaXQpO1xufTtcblxudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCQ3O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkYSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDYoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkYSgkU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGQ7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkOCA9IGZhaWxzJGQ7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkOSAmJiBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkajtcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkNztcblxudmFyIGRvY3VtZW50JDMgPSBnbG9iYWwkZC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkNShkb2N1bWVudCQzKSAmJiBpc09iamVjdCQ1KGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDcgPSBmYWlscyRkO1xudmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkOCAmJiAhZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQkMSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGQgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDIgPyBjYWxsJGQuYmluZChjYWxsJGQpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRkLmFwcGx5KGNhbGwkZCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyQ4KHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkaztcbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRoKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkMygkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQyKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDIoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkaztcbnZhciB0cnlUb1N0cmluZyQzID0gdHJ5VG9TdHJpbmckNDtcblxudmFyICRUeXBlRXJyb3IkOSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRnKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDkodHJ5VG9TdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkNztcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDYoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRjID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkaztcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkNztcblxudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRmKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkYyhmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkYyhmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkOChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JDc7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDI7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciAkVHlwZUVycm9yJDcgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGQoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JDMoaW5wdXQpIHx8IGlzU3ltYm9sJDEoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMihpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRiKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkMyhyZXN1bHQpIHx8IGlzU3ltYm9sJDEocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJDcoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMjtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkYztcbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDI7XG5cbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDcgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGIoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGFuT2JqZWN0JGIoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciQ2KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcblxudmFyIHRydW5jID0gbWF0aFRydW5jO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDI7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyQ3KFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMyhvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093biQ5KGhpZGRlbktleXMkMywga2V5KSAmJiBoYXNPd24kOShPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJDkoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQxID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBlbnVtQnVnS2V5cyQyKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQxO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxub2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkNiAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCRhKE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkMihQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkNC5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBnZXRCdWlsdEluJDUgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBodG1sJDIgPSBnZXRCdWlsdEluJDUoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG52YXIgc2hhcmVkJDEgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIHVpZCA9IHVpZCQyO1xuXG52YXIga2V5cyA9IHNoYXJlZCQxKCdrZXlzJyk7XG5cbnZhciBzaGFyZWRLZXkkMyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cblxudmFyIGFuT2JqZWN0JDkgPSBhbk9iamVjdCRjO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sJDEgPSBodG1sJDI7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcbnZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQzO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQyKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxKCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sJDEuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMkMS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzJDFbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXMkMltJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0JDkoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRlO1xudmFyIGNyZWF0ZSQxID0gb2JqZWN0Q3JlYXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2wkYygndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkMyhBcnJheVByb3RvdHlwZSQxLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlJDEobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRrO1xudmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ2KEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJGUoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbnZhciBpbnNwZWN0U291cmNlJDQgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbnZhciBnbG9iYWwkYyA9IGdsb2JhbCRqO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkaztcbnZhciBpbnNwZWN0U291cmNlJDMgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkYy5XZWFrTWFwO1xuXG52YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkZChXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlJDMoV2Vha01hcCQxKSk7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzO1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBERVNDUklQVE9SUyQ1ID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBuYXRpdmVXZWFrTWFwO1xudmFyIGdsb2JhbCRiID0gZ2xvYmFsJGo7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDc7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkMztcbnZhciBoaWRkZW5LZXlzJDEgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJDIgPSBnbG9iYWwkYi5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCRiLldlYWtNYXA7XG52YXIgc2V0JDEsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQkMShpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdCQyKGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkMignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzJDUoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMkNShzdG9yZS5oYXMpO1xuICB2YXIgd21zZXQgPSB1bmN1cnJ5VGhpcyQ1KHN0b3JlLnNldCk7XG4gIHNldCQxID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDIoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0KHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDEoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkMVtTVEFURV0gPSB0cnVlO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDgoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyhpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQkMSxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMztcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDI7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJDQgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQxKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24kNyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKCFjYWxsJGEocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ2ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkMyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJDYoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkMyB8fCAoREVTQ1JJUFRPUlMkMyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciBmYWlscyQ2ID0gZmFpbHMkZDtcbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJGs7XG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQyICYmICFmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDIoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDUodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkMikgZGVmaW5lUHJvcGVydHkkMih2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ1KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDIodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDUob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDIpIGRlZmluZVByb3BlcnR5JDIodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDUoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGModGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkaztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDYgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkYih2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQ4ID0gYW5PYmplY3QkYztcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzJDQoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIG93bktleXMkMSA9IGdldEJ1aWx0SW4kNCgnUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdCQ4KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDQodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNChleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJDUgPSBmYWlscyRkO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkaztcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkYShkZXRlY3Rpb24pID8gZmFpbHMkNShkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkYSA9IGdsb2JhbCRqO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciBkZWZpbmVCdWlsdEluJDUgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQkMSA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkYTtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkYVtUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwkYVtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkJDEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGZhaWxzJDQgPSBmYWlscyRkO1xuXG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkaztcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDI7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDM7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0JDEucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdCQxLmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzT3duJDMob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlJDkoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCQxID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cbnZhciBmYWlscyQzID0gZmFpbHMkZDtcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGs7XG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIGRlZmluZUJ1aWx0SW4kNCA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMiwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDEoZ2V0UHJvdG90eXBlT2YkMShhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlJDIgPT0gdW5kZWZpbmVkIHx8IGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkNV0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUkOChJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDVdKSkge1xuICBkZWZpbmVCdWlsdEluJDQoSXRlcmF0b3JQcm90b3R5cGUkMiwgSVRFUkFUT1IkNSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQyLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRhKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDIodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDMpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMSh0YXJnZXQsIFRPX1NUUklOR19UQUckMywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSQxID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDM7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyQyKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcbiAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkaztcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkNyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JDcgPSBhbk9iamVjdCRjO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyQzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCQ3KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRrO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDE7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciBkZWZpbmVCdWlsdEluJDMgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJDkgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJDkoJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBkZWZpbmVJdGVyYXRvciQxID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YkMSkge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUkNihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkNF0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkNCwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSQxICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmIChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoSXRlcmFibGVQcm90b3R5cGUsICduYW1lJywgVkFMVUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIGNhbGwkOShuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkJDYoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmIChJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ0XSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQ0LCBkZWZhdWx0SXRlcmF0b3IsIHsgbmFtZTogREVGQVVMVCB9KTtcbiAgfVxuICBJdGVyYXRvcnMkM1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gYWRkVG9VbnNjb3BhYmxlcyQxO1xudmFyIEl0ZXJhdG9ycyQyID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMTtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxudmFyIGVzX2FycmF5X2l0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycyQyLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQyLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKERFU0NSSVBUT1JTJDEgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJGo7XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJDgoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJDgoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkM10gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SJDMsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQzXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBRyQyXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUckMiwgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWwkOVtDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbCQ5W0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG5cbnZhciBjbGFzc29mJDQgPSBjbGFzc29mUmF3JDE7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkajtcblxudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2YkNChnbG9iYWwkOC5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRlO1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG5cbnZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkNygnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQzKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFUyQyXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTJDIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMSA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDIoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ0KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkNigndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBRyQxXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkaztcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDUoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkNShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQyID0gZmFpbHMkZDtcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGs7XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiQzO1xudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kODtcbnZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDQ7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbiQyKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMkMihjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkNChhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkNChhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mJDIoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlJDEoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gIWNvbnN0cnVjdCB8fCBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDE7XG52YXIgdHJ5VG9TdHJpbmckMiA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJDMgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3IoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkMyh0cnlUb1N0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkYztcbnZhciBhQ29uc3RydWN0b3IgPSBhQ29uc3RydWN0b3IkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sJDQoJ3NwZWNpZXMnKTtcblxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0JDYoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QkNihDKVtTUEVDSUVTJDFdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhQ29uc3RydWN0b3IoUyk7XG59O1xuXG52YXIgTkFUSVZFX0JJTkQkMSA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5JDEgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBjYWxsJDggPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1yZWZsZWN0IC0tIHNhZmVcbnZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkMSA/IGNhbGwkOC5iaW5kKGFwcGx5JDEpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCQ4LmFwcGx5KGFwcGx5JDEsIGFyZ3VtZW50cyk7XG59KTtcblxudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDc7XG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBiaW5kJDQgPSB1bmN1cnJ5VGhpcyQxKHVuY3VycnlUaGlzJDEuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlJDUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQkNChmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGFycmF5U2xpY2UkMSA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93ICRUeXBlRXJyb3IkMignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciB1c2VyQWdlbnQkMiA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSW9zID0gLyg/OmlwYWR8aXBob25lfGlwb2QpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50JDIpO1xuXG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkajtcbnZhciBhcHBseSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgYmluZCQzID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGs7XG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGZhaWxzJDEgPSBmYWlscyRkO1xudmFyIGh0bWwgPSBodG1sJDI7XG52YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2UkMTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xudmFyIElTX0lPUyQxID0gZW5naW5lSXNJb3M7XG52YXIgSVNfTk9ERSQyID0gZW5naW5lSXNOb2RlO1xuXG52YXIgc2V0ID0gZ2xvYmFsJDcuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsJDcuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyQyID0gZ2xvYmFsJDcucHJvY2VzcztcbnZhciBEaXNwYXRjaCA9IGdsb2JhbCQ3LkRpc3BhdGNoO1xudmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkNy5GdW5jdGlvbjtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbCQ3Lk1lc3NhZ2VDaGFubmVsO1xudmFyIFN0cmluZyQxID0gZ2xvYmFsJDcuU3RyaW5nO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlJDEgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBsb2NhdGlvbiwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnRyeSB7XG4gIC8vIERlbm8gdGhyb3dzIGEgUmVmZXJlbmNlRXJyb3Igb24gYGxvY2F0aW9uYCBhY2Nlc3Mgd2l0aG91dCBgLS1sb2NhdGlvbmAgZmxhZ1xuICBsb2NhdGlvbiA9IGdsb2JhbCQ3LmxvY2F0aW9uO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgcnVuID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChoYXNPd24kMShxdWV1ZSQxLCBpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZSQxW2lkXTtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJ1bihpZCk7XG4gIH07XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuKGV2ZW50LmRhdGEpO1xufTtcblxudmFyIHBvc3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG4gIGdsb2JhbCQ3LnBvc3RNZXNzYWdlKFN0cmluZyQxKGlkKSwgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDMoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICBxdWV1ZSQxWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseShmbiwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKElTX05PREUkMikge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzJDIubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUyQxKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBiaW5kJDMocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbCQ3LmFkZEV2ZW50TGlzdGVuZXIgJiZcbiAgICBpc0NhbGxhYmxlJDMoZ2xvYmFsJDcucG9zdE1lc3NhZ2UpICYmXG4gICAgIWdsb2JhbCQ3LmltcG9ydFNjcmlwdHMgJiZcbiAgICBsb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgICFmYWlscyQxKHBvc3QpXG4gICkge1xuICAgIGRlZmVyID0gcG9zdDtcbiAgICBnbG9iYWwkNy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4oaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIHRhc2skMSA9IHtcbiAgc2V0OiBzZXQsXG4gIGNsZWFyOiBjbGVhclxufTtcblxudmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xudmFyIGdsb2JhbCQ2ID0gZ2xvYmFsJGo7XG5cbnZhciBlbmdpbmVJc0lvc1BlYmJsZSA9IC9pcGFkfGlwaG9uZXxpcG9kL2kudGVzdCh1c2VyQWdlbnQkMSkgJiYgZ2xvYmFsJDYuUGViYmxlICE9PSB1bmRlZmluZWQ7XG5cbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc1dlYm9zV2Via2l0ID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQpO1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkajtcbnZhciBiaW5kJDIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIG1hY3JvdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgSVNfSU9TID0gZW5naW5lSXNJb3M7XG52YXIgSVNfSU9TX1BFQkJMRSA9IGVuZ2luZUlzSW9zUGViYmxlO1xudmFyIElTX1dFQk9TX1dFQktJVCA9IGVuZ2luZUlzV2Vib3NXZWJraXQ7XG52YXIgSVNfTk9ERSQxID0gZW5naW5lSXNOb2RlO1xuXG52YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbCQ1Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsJDUuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBkb2N1bWVudCQyID0gZ2xvYmFsJDUuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyQxID0gZ2xvYmFsJDUucHJvY2VzcztcbnZhciBQcm9taXNlJDEgPSBnbG9iYWwkNS5Qcm9taXNlO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwkNSwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSQxLCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFJDEgJiYgKHBhcmVudCA9IHByb2Nlc3MkMS5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkkMSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIC8vIGFsc28gZXhjZXB0IFdlYk9TIFdlYmtpdCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODk4XG4gIGlmICghSVNfSU9TICYmICFJU19OT0RFJDEgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50JDIpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudCQyLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZSQxICYmIFByb21pc2UkMS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAvLyB3b3JrYXJvdW5kIG9mIFdlYktpdCB+IGlPUyBTYWZhcmkgMTAuMSBidWdcbiAgICBwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZSQxO1xuICAgIHRoZW4gPSBiaW5kJDIocHJvbWlzZS50aGVuLCBwcm9taXNlKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUkMSkge1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdlXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5iaW5kKGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kJDIobWFjcm90YXNrLCBnbG9iYWwkNSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1pY3JvdGFzayQxID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5JDEoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRqO1xuXG52YXIgaG9zdFJlcG9ydEVycm9ycyQxID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwkNC5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG5cbnZhciBwZXJmb3JtJDMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxudmFyIFF1ZXVlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG59O1xuXG5RdWV1ZSQxLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBlbnRyeSA9IHsgaXRlbTogaXRlbSwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV4dDtcbiAgICAgIGlmICh0aGlzLnRhaWwgPT09IGVudHJ5KSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW07XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUgPSBRdWV1ZSQxO1xuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkajtcblxudmFyIHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCQzLlByb21pc2U7XG5cbnZhciBlbmdpbmVJc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHR5cGVvZiBEZW5vICE9ICdvYmplY3QnO1xuXG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkajtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBJU19CUk9XU0VSID0gZW5naW5lSXNCcm93c2VyO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG5cbk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzLnByb3RvdHlwZTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sJDMoJ3NwZWNpZXMnKTtcbnZhciBTVUJDTEFTU0lORyA9IGZhbHNlO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxID0gaXNDYWxsYWJsZSQyKGdsb2JhbCQyLlByb21pc2VSZWplY3Rpb25FdmVudCk7XG5cbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1ID0gaXNGb3JjZWQoJ1Byb21pc2UnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSA9IGluc3BlY3RTb3VyY2UoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICB2YXIgR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSA9IFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFICE9PSBTdHJpbmcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMpO1xuICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAvLyBXZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAvLyBXZSBjYW4ndCB1c2UgQEBzcGVjaWVzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxuICBpZiAoVjhfVkVSU0lPTiA+PSA1MSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gbmV3IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUoMSk7IH0pO1xuICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICB9O1xuICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gRmFrZVByb21pc2U7XG4gIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIElTX0JST1dTRVIgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxO1xufSk7XG5cbnZhciBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSB7XG4gIENPTlNUUlVDVE9SOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1LFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxLFxuICBTVUJDTEFTU0lORzogU1VCQ0xBU1NJTkdcbn07XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyID0ge307XG5cbnZhciBhQ2FsbGFibGUkNCA9IGFDYWxsYWJsZSQ3O1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlJDQocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlJDQocmVqZWN0KTtcbn07XG5cbi8vIGBOZXdQcm9taXNlQ2FwYWJpbGl0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW5ld3Byb21pc2VjYXBhYmlsaXR5XG5uZXdQcm9taXNlQ2FwYWJpbGl0eSQyLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgSVNfTk9ERSA9IGVuZ2luZUlzTm9kZTtcbnZhciBnbG9iYWwkMSA9IGdsb2JhbCRqO1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBkZWZpbmVCdWlsdEluJDIgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkaztcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkNztcbnZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQxO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHNwZWNpZXNDb25zdHJ1Y3RvciQxO1xudmFyIHRhc2sgPSB0YXNrJDEuc2V0O1xudmFyIG1pY3JvdGFzayA9IG1pY3JvdGFzayQxO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBob3N0UmVwb3J0RXJyb3JzJDE7XG52YXIgcGVyZm9ybSQyID0gcGVyZm9ybSQzO1xudmFyIFF1ZXVlID0gcXVldWU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xuXG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0ID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5SRUpFQ1RJT05fRVZFTlQ7XG52YXIgTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uU1VCQ0xBU1NJTkc7XG52YXIgZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIucHJvdG90eXBlO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyO1xudmFyIFByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDE7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkMS5UeXBlRXJyb3I7XG52YXIgZG9jdW1lbnQkMSA9IGdsb2JhbCQxLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwkMS5wcm9jZXNzO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzLmY7XG52YXIgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMTtcblxudmFyIERJU1BBVENIX0VWRU5UID0gISEoZG9jdW1lbnQkMSAmJiBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50ICYmIGdsb2JhbCQxLmRpc3BhdGNoRXZlbnQpO1xudmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSAndW5oYW5kbGVkcmVqZWN0aW9uJztcbnZhciBSRUpFQ1RJT05fSEFORExFRCA9ICdyZWplY3Rpb25oYW5kbGVkJztcbnZhciBQRU5ESU5HID0gMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcbnZhciBIQU5ETEVEID0gMTtcbnZhciBVTkhBTkRMRUQgPSAyO1xuXG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdCQxKGl0KSAmJiBpc0NhbGxhYmxlJDEodGhlbiA9IGl0LnRoZW4pID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIGNhbGxSZWFjdGlvbiA9IGZ1bmN0aW9uIChyZWFjdGlvbiwgc3RhdGUpIHtcbiAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gIHRyeSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnJlamVjdGlvbiA9IEhBTkRMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICByZWplY3QoVHlwZUVycm9yJDEoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY2FsbCQ3KHRoZW4sIHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgIHJlamVjdChlcnJvcik7XG4gIH1cbn07XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoc3RhdGUsIGlzUmVqZWN0KSB7XG4gIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuICBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlYWN0aW9ucyA9IHN0YXRlLnJlYWN0aW9ucztcbiAgICB2YXIgcmVhY3Rpb247XG4gICAgd2hpbGUgKHJlYWN0aW9uID0gcmVhY3Rpb25zLmdldCgpKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUubm90aWZpZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXN0YXRlLnJlamVjdGlvbikgb25VbmhhbmRsZWQoc3RhdGUpO1xuICB9KTtcbn07XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuICB2YXIgZXZlbnQsIGhhbmRsZXI7XG4gIGlmIChESVNQQVRDSF9FVkVOVCkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQkMS5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBldmVudC5yZWFzb24gPSByZWFzb247XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICBnbG9iYWwkMS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCAmJiAoaGFuZGxlciA9IGdsb2JhbCQxWydvbicgKyBuYW1lXSkpIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkNyh0YXNrLCBnbG9iYWwkMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBJU19VTkhBTkRMRUQgPSBpc1VuaGFuZGxlZChzdGF0ZSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoSVNfVU5IQU5ETEVEKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtJDIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCQ3KHRhc2ssIGdsb2JhbCQxLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgaWYgKElTX05PREUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQkMSA9IGZ1bmN0aW9uIChmbiwgc3RhdGUsIHVud3JhcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZm4oc3RhdGUsIHZhbHVlLCB1bndyYXApO1xuICB9O1xufTtcblxudmFyIGludGVybmFsUmVqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgbm90aWZ5KHN0YXRlLCB0cnVlKTtcbn07XG5cbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICB0cnkge1xuICAgIGlmIChzdGF0ZS5mYWNhZGUgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IkMShcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGwkNyh0aGVuLCB2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQkMShpbnRlcm5hbFJlc29sdmUsIHdyYXBwZXIsIHN0YXRlKSxcbiAgICAgICAgICAgIGJpbmQkMShpbnRlcm5hbFJlamVjdCwgd3JhcHBlciwgc3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlamVjdCh3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHN0YXRlLnN0YXRlID0gRlVMRklMTEVEO1xuICAgICAgbm90aWZ5KHN0YXRlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGludGVybmFsUmVqZWN0KHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTtcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmIChGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0KSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFByb21pc2VDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIGFDYWxsYWJsZSQzKGV4ZWN1dG9yKTtcbiAgICBjYWxsJDcoSW50ZXJuYWwsIHRoaXMpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSksIGJpbmQkMShpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluJDIoUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgICByZWFjdGlvbi5vayA9IGlzQ2FsbGFibGUkMShvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUkMShvblJlamVjdGVkKSAmJiBvblJlamVjdGVkO1xuICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuc3RhdGUgPT0gUEVORElORykgc3RhdGUucmVhY3Rpb25zLmFkZChyZWFjdGlvbik7XG4gICAgZWxzZSBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gIH0pO1xuXG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7XG4gICAgdGhpcy5yZWplY3QgPSBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTtcbiAgfTtcblxuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgaWYgKGlzQ2FsbGFibGUkMShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMikgJiYgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgbmF0aXZlVGhlbiA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS50aGVuO1xuXG4gICAgaWYgKCFOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORykge1xuICAgICAgLy8gbWFrZSBgUHJvbWlzZSN0aGVuYCByZXR1cm4gYSBwb2x5ZmlsbGVkIGBQcm9taXNlYCBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgICAgZGVmaW5lQnVpbHRJbiQyKE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNhbGwkNyhuYXRpdmVUaGVuLCB0aGF0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICAgIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8vIG1ha2UgYC5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLmNvbnN0cnVjdG9yO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuICAgIC8vIG1ha2UgYGluc3RhbmNlb2YgUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgc2V0UHJvdG90eXBlT2YoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuJCQ1KHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0IH0sIHtcbiAgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yXG59KTtcblxuc2V0VG9TdHJpbmdUYWcoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSk7XG5zZXRTcGVjaWVzKFBST01JU0UpO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBJdGVyYXRvcnMkMSA9IGl0ZXJhdG9ycztcblxudmFyIElURVJBVE9SJDIgPSB3ZWxsS25vd25TeW1ib2wkMignaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMkMS5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1IkMl0gPT09IGl0KTtcbn07XG5cbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDM7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkMztcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgnaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZCQxKGl0LCBJVEVSQVRPUiQxKVxuICAgIHx8IGdldE1ldGhvZCQxKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YkMShpdCldO1xufTtcblxudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ3O1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRjO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG52YXIgZ2V0SXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDEoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZSQyKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDUoY2FsbCQ2KGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyAkVHlwZUVycm9yJDEodHJ5VG9TdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkYztcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMztcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJDUoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ0KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQyO1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQxO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkNChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCQ0KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMShDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkMygkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRrO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kNjtcblxudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiQkMyh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDEoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDc7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiQkMih7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEuZihDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgY2FsbCQyKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuJCQxKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSB9LCB7XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYodGhpcyk7XG4gICAgY2FsbCQxKGNhcGFiaWxpdHkucmVqZWN0LCB1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGM7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQyKEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kODtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZXNvbHZlJDE7XG5cbmdldEJ1aWx0SW4oJ1Byb21pc2UnKTtcblxuLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxudmFyIGNsYXNzb2YgPSBjbGFzc29mJDM7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGM7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCQxKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVnZXhwRmxhZ3M7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUkMSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciByZWdleHBHZXRGbGFncyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUkMSkgJiYgIWhhc093bihSLCAnZmxhZ3MnKSAmJiBpc1Byb3RvdHlwZU9mKFJlZ0V4cFByb3RvdHlwZSQxLCBSKVxuICAgID8gY2FsbChyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGM7XG52YXIgJHRvU3RyaW5nID0gdG9TdHJpbmc7XG52YXIgZmFpbHMgPSBmYWlscyRkO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVnZXhwR2V0RmxhZ3M7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbiRUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuJFRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIG4kVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIGRlZmluZUJ1aWx0SW4oUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwYXR0ZXJuID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgZmxhZ3MgPSAkdG9TdHJpbmcoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBzaWduVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9ucywgc2lnbmVyLCBuZXR3b3JrKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgbmVhckFQSS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICB1cmw6IG5ldHdvcmsubm9kZVVybFxuICB9KTtcbiAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgc2lnbmVyLmdldFB1YmxpY0tleSh0cmFuc2FjdGlvbnNbaV0uc2lnbmVySWQsIG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICBjb25zdCBbYmxvY2ssIGFjY2Vzc0tleV0gPSB5aWVsZCBQcm9taXNlLmFsbChbcHJvdmlkZXIuYmxvY2soe1xuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIlxuICAgIH0pLCBwcm92aWRlci5xdWVyeSh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwidmlld19hY2Nlc3Nfa2V5XCIsXG4gICAgICBmaW5hbGl0eTogXCJmaW5hbFwiLFxuICAgICAgYWNjb3VudF9pZDogdHJhbnNhY3Rpb25zW2ldLnNpZ25lcklkLFxuICAgICAgcHVibGljX2tleTogcHVibGljS2V5LnRvU3RyaW5nKClcbiAgICB9KV0pO1xuICAgIGNvbnN0IGFjdGlvbnMgPSB0cmFuc2FjdGlvbnNbaV0uYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5lYXJBUEkudHJhbnNhY3Rpb25zLmNyZWF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uc1tpXS5zaWduZXJJZCwgbmVhckFQSS51dGlscy5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkudG9TdHJpbmcoKSksIHRyYW5zYWN0aW9uc1tpXS5yZWNlaXZlcklkLCBhY2Nlc3NLZXkubm9uY2UgKyBpICsgMSwgYWN0aW9ucywgbmVhckFQSS51dGlscy5zZXJpYWxpemUuYmFzZV9kZWNvZGUoYmxvY2suaGVhZGVyLmhhc2gpKTtcbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIG5lYXJBUEkudHJhbnNhY3Rpb25zLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVyLCB0cmFuc2FjdGlvbnNbaV0uc2lnbmVySWQsIG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICBzaWduZWRUcmFuc2FjdGlvbnMucHVzaChyZXNwb25zZVsxXSk7XG4gIH1cbiAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbn0pO1xuXG5leHBvcnQgeyBjcmVhdGVBY3Rpb24sIHNpZ25UcmFuc2FjdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js\n");

/***/ })

};
;